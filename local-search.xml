<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>剑指Offer-10-II-青蛙跳台阶问题</title>
    <link href="/2020/03/16/%E5%89%91%E6%8C%87Offer-10-II-%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98/"/>
    <url>/2020/03/16/%E5%89%91%E6%8C%87Offer-10-II-%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h4 id="10-II-青蛙跳台阶问题"><a href="#10-II-青蛙跳台阶问题" class="headerlink" title="(10-II)青蛙跳台阶问题"></a>(10-II)青蛙跳台阶问题</h4><h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><pre><code>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。示例 1：输入：n = 2输出：2示例 2：输入：n = 7输出：21提示：0 &lt;= n &lt;= 100</code></pre><h5 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h5><blockquote><p>从后往前思考，即最好一步有两种跳法,</p><ul><li>跳一步，则前面有$f(n-1)$种跳法</li><li>跳两步，则前面有$f(n-2)$种跳法</li></ul><p>则n级台阶的跳法有$f(n) = f(n-1) + f(n-2)$种跳法，与斐波那契数列的递推公式一致</p></blockquote><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">/**     * 面试题10-II     * 青蛙跳台阶问题     * @param n n级台阶     * @return n级台阶的跳法     */public static int numWays(int n) {    if (n &lt;= 1) {        return 1;    }    long num1 = 0, num2 = 1;    long temp = 0;    int i = 0;    while (i &lt; n) {        temp = (num1 + num2)%1000000007;        num1 = num2;        num2 = temp;        i ++;    }    return (int) temp;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>剑指Offer</tag>
      
      <tag>Fibonacci</tag>
      
      <tag>递归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer-10-I-斐波那契数列</title>
    <link href="/2020/03/16/%E5%89%91%E6%8C%87Offer-10-I-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"/>
    <url>/2020/03/16/%E5%89%91%E6%8C%87Offer-10-I-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h4 id="10-斐波那契数列"><a href="#10-斐波那契数列" class="headerlink" title="(10)斐波那契数列"></a>(10)斐波那契数列</h4><h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><pre><code>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：F(0) = 0,   F(1) = 1F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。示例 1：输入：n = 2输出：1示例 2：输入：n = 5输出：5提示：0 &lt;= n &lt;= 100</code></pre><h5 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h5><blockquote><ul><li>递归法：方法简洁，但是由于中间重复计算，会超时</li><li>循环法：从0开始计算可以记录中间值，避免进行重复计算</li><li>公式法：根据 <strong>$F_n = \frac{(\frac{1+\sqrt[]{5}}{2})^n -(\frac{1-\sqrt[]{5}}{2})^n}{\sqrt[]{5}}$</strong>,但是大数会有误差</li></ul></blockquote><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">/**     * 面试题10-I     * 斐波那契数列     * @param n 所求第n项     * @return 斐波那契数列第n项     */public static final long THRES_HOLD = 1000000007;public static int fib(int n) {    //递归法    if (n &lt; 1) {        return n;    }    return (fib(n - 1) + fib(n - 2)) % THRES_HOLD;    //循环法    if (n &lt;= 1) {        return n;    }    long num1 = 0, num2 = 1;    long temp = 0;    int i = 2;    while (i &lt;= n) {        temp = (num1 + num2)%THRES_HOLD;        num1 = num2;        num2 = temp;        i ++;    }    return (int) temp;    //公式法    double temp = Math.sqrt(5);    return (int) ((Math.pow((1 + temp) / 2, n) - Math.pow((1 - temp) / 2, n)) / temp % THRES_HOLD) ;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>剑指Offer</tag>
      
      <tag>Fibonacci</tag>
      
      <tag>递归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer-09-用两个栈实现队列</title>
    <link href="/2020/03/14/%E5%89%91%E6%8C%87Offer-09-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <url>/2020/03/14/%E5%89%91%E6%8C%87Offer-09-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h4 id="09-用两个栈实现队列"><a href="#09-用两个栈实现队列" class="headerlink" title="(09)用两个栈实现队列"></a>(09)用两个栈实现队列</h4><h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><pre><code>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )示例 1：输入：[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;][[],[3],[],[]]输出：[null,null,3,-1]示例 2：输入：[&quot;CQueue&quot;,&quot;deleteHead&quot;,&quot;appendTail&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;][[],[],[5],[2],[],[]]输出：[null,-1,null,null,5,2]提示：1 &lt;= values &lt;= 10000最多会对 appendTail、deleteHead 进行 10000 次调用</code></pre><h5 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h5><blockquote><p>首先必须记住栈的特点是：先进后出；队列的特点是先入先出</p><p>以此为基础则数据分别从两个栈先后进入弹出则可以实现队列的特点。</p><p>核心思想是两个栈一个为输出栈，一个为输入栈，在插入数据时可以直接将数据压到输入栈中；在删除头数据时就需要对不同情况进行分别处理：</p><p>1.输出栈不为空：直接弹出</p><p>2.输出栈为空，输入栈不为空：先将输入栈中的数据压到输出栈中，再从输出栈中弹出数据</p><p>3.输出栈为孔，输入栈为孔：则整个队列无数据，直接返回-1</p></blockquote><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class CQueue {    //输入,用于数据插入    private Stack&lt;Integer&gt; inStack;    //输出栈，用于将尾部数据弹出    private Stack&lt;Integer&gt; outStack;    public CQueue() {        inStack = new Stack&lt;&gt;();        outStack = new Stack&lt;&gt;();    }    /**     * 从尾部插入，则直接将数据压到输入当中     * @param value 压入数据     */    public void appendTail(int value) {        inStack.push(value);    }    /**     * 从头部删除，由于需要保持队列的顺序需要注意输入和输出栈之中的数据     * @return 删除元素     */    public int deleteHead() {        //如果输出栈中有元素，则直接弹出        if (!outStack.isEmpty()) {            return outStack.pop();        }        //如果输出栈不为空且输入栈也不为空，就需要将输入栈中数据全部压到输出栈中以保持其顺序正确        while (!inStack.isEmpty()) {            outStack.push(inStack.pop());        }        return outStack.isEmpty() ? -1 : outStack.pop();    }}class CQueue {    //输入,用于数据插入    private Stack&lt;Integer&gt; inStack;    //输出栈，用于将尾部数据弹出    private Stack&lt;Integer&gt; outStack;    public CQueue() {        inStack = new Stack&lt;&gt;();        outStack = new Stack&lt;&gt;();    }    /**     * 从尾部插入，则直接将数据压到输入当中     * @param value 压入数据     */    public void appendTail(int value) {        inStack.push(value);    }    /**     * 从头部删除，由于需要保持队列的顺序需要注意输入和输出栈之中的数据     * @return 删除元素     */    public int deleteHead() {        //如果输出栈中有元素，则直接弹出        if (!outStack.isEmpty()) {            return outStack.pop();        }        //如果输出栈不为空且输入栈也不为空，就需要将输入栈中数据全部压到输出栈中以保持其顺序正确        while (!inStack.isEmpty()) {            outStack.push(inStack.pop());        }        return outStack.isEmpty() ? -1 : outStack.pop();    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ProtocolBuffers-基本使用</title>
    <link href="/2020/03/12/ProtocolBuffers-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/03/12/ProtocolBuffers-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h4 id="Protocol-Buffers"><a href="#Protocol-Buffers" class="headerlink" title="Protocol Buffers"></a>Protocol Buffers</h4><p>​    <em>一种跨语言，跨平台的可扩展的序列化数据格式</em></p><ol><li><p>相比XML的优势</p><ul><li>更简单</li><li>更轻量（数据体积小3~10倍）</li><li>更快速（20～100倍）</li><li>自动化生成更易于编码方式使用的数据访问类</li></ul></li><li><p>使用方法</p><pre class="mermaid">   graph TD;   A[定义protobuf消息格式]　--> B[编译protobuf];   B --> C[使用protobuf API进行读写];</pre><ol><li><p>使用protobuf语法描述需要存储的数据结构（编写．proto文件）</p><pre><code class="protobuf">syntax = &quot;proto3&quot;; //默认为proto2,不能为空package tutorial;　//避免命名冲突option java_package = &quot;com.example.tutorial&quot;;　//生成类的包结构option java_outer_classname = &quot;AddressBookProtos&quot;;　//生成包括当前文件所有类的类名，默认是MyProto,生成my_proto.proto，不能与内部定义的类名称相同（不能设为AddressBook）message Person {   string name = 1;　//用于二进制编码的唯一标识   int32 id = 2;   string email = 3;  enum PhoneType {    MOBILE = 0;　//必须包含标识０，用于设置默认值和与proto2语义兼容    HOME = 1;    WORK = 2;  }  message PhoneNumber {     string number = 1;     PhoneType type = 2 [packed = HOME];  }   PhoneNumber phones = 4;}message AddressBook {   Person people = 1;}</code></pre><blockquote><p>基本语法（proto3）：</p><ol><li><p>消息是各种类型数据的集合，</p></li><li><p>可以包含<code>bool</code>,<code>int32</code>,<code>float</code>,<code>double</code>,<code>string</code>,枚举或者其他的消息</p></li><li><p>标识的范围为1 ~ 2^29^ - 1,1~15的标识比较高的数字少一个字节进行编码，适宜一些常用或者重复的字段;16以上的适用不太常使用的可选字段;19000 ~ 19999不可使用，为内置保留．</p></li><li><p>每个字段都必须标明注解：</p><ol><li><code>required</code>:该字段必须设置值，否则该消息将被视为“未初始化”,构建未初始化的消息将抛出RuntimeException,解析未初始化的消息将抛出IOException;除此之外与<code>optional</code>一致</li><li><code>optional</code>:该字段是可选字段，可以设置值也可以不设置值。如果不设置值，则使用默认值．</li><li><code>repeated</code>:该字段可以重复任意次数（包括零），重复值的顺序将保留在<strong>protobuf</strong>中。可将其视为动态大小的数组．</li></ol></li><li><p>Any字段：</p><pre><code class="protobuf">import &quot;google/protobuf/any.proto&quot;;message ErrorStatus {  string message = 1;  google.protobuf.Any details = 2;}</code></pre></li><li><p>Oneof字段：</p></li><li><p>一个.proto文件中可以定义多种消息</p></li><li><p>每个message类以及它的子类有自己的<code>builder</code>类 ，通过<code>builder</code>类来进行设置</p></li><li><p>数据类型</p></li><li><p>不能在proto3中直接导入proto2的枚举进行使用，要导入其消息．</p></li><li><p>Map类型</p><pre><code class="protobuf">map&lt;key_type, value_type&gt; map_field = N;map&lt;string, Project&gt; projects = 3;</code></pre><ol><li><code>key_type</code> 可以是任何 int 或者 string 类型(任何的标量类型，具体可以见上面标量类型对应表格，但是要除去 float、double 和 bytes)</li><li><code>value_type</code> 可以是除去 map 以外的任何类型。</li></ol></li><li><p>定义service</p><p>如果要使用 RPC（远程过程调用）系统的消息类型，可以在 <code>.proto</code> 文件中定义 RPC 服务接口，protocol buffer 编译器将使用所选语言生成服务接口代码和 stubs</p><pre><code class="protobuf">//参数为SearchRequest,返回值为SearchResponseservice SearchService {  rpc Search (SearchRequest) returns (SearchResponse);}</code></pre></li><li><p>JSON Map</p></li></ol><p>如果一个值在json编码的数据中丢失或者它的值是null, 在被解析成protocol buffer时它将设置为对应的默认值.如果一个字段的值正好是protocol buffer的默认值, 这个字段默认就不会出现在json编码的数据中以便节约空间.</p></blockquote></li><li><p>通过protobuf编译器编译．proto文件（生成对应平台的文件）</p><ul><li>使用命令</li></ul><pre><code class="shell">##命令格式protoc [option] PROTO_FILES##Javaprotoc -I=$SRC_DIR --java_out=$DST_DIR $SRC_DIR/addressbook.proto##Pythonprotoc -I=$SRC_DIR --python_out=$DST_DIR $SRC_DIR/addressbook.proto</code></pre><blockquote><ul><li><p>SRC_DIR:源代码路径，默认为当前文件夹</p></li><li><p>DST_DIR:生成的代码路径，默认与SRC_DIR相同</p></li><li><p>–Java_out:生成不同语言对应的文件</p></li><li><p>对于Android使用Java Lite可以减小生成类的体积</p><p>1.安装java_lite环境</p><p>2.编译java_lite版文件</p><pre><code class="shell">protoc --javalite_out=$DST_DIR PROTO_FILES</code></pre></li></ul></blockquote><ul><li><p>使用Android Studio</p><ol><li>安装Protocol Support插件</li><li>配置gradle</li><li>编写．proto文件</li><li>编译项目</li></ol><p><img src="https://img2.tuicool.com/AnMFRbi.jpg!web" srcset="/img/loading.gif" alt="img"></p></li></ul></li><li><p>使用protobuf进行数据读写</p><p> 除了访问器，生成的类中还有其它的方法：</p><p> 消息构建接口</p><ul><li><code>isInitialized()</code>:检测 所有<code>required</code>的字段是否有被设置</li><li><code>toString()</code>: 生成可读的字符串</li><li><code>mergeFrom(Message other)</code>: (builder only)与另一个消息进行合并</li><li><p><code>clear()</code>: (builder only) 将所有字段清除为空状态</p><p>解析接口</p></li><li><code>byte[] toByteArray();</code>: 序列化数据</li><li><code>static Person parseFrom(byte[] data);</code>: 反序列化数据</li><li><code>void writeTo(OutputStream output);</code>: 序列化数据并写入<code>OutputStream</code></li><li><code>static Person parseFrom(InputStream input);</code>: 从<code>InputStream</code>中解析读取消息</li></ul><ol start="4"><li>具体Demo</li></ol></li><li><p>兼容处理</p><p>如果要让新版本向后兼容，旧版本向前兼容，需要遵守以下规则</p><ol><li>不能修改已存在字段的标识（tag）</li><li>不能添加或删除<code>required</code>字段</li><li>可以删除<code>optional</code>或<code>repeated</code>字段</li><li>可以增加<code>optional</code>或<code>repeated</code>字段，但必须使用没有用过的标识，已经删除的也不能用</li></ol></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据编码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer-06-从尾到头打印链表</title>
    <link href="/2020/03/12/%E5%89%91%E6%8C%87Offer-06-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
    <url>/2020/03/12/%E5%89%91%E6%8C%87Offer-06-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h4 id="06-从尾到头打印链表"><a href="#06-从尾到头打印链表" class="headerlink" title="(06)从尾到头打印链表"></a>(06)从尾到头打印链表</h4><h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><pre><code>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。示例 1：输入：head = [1,3,2]输出：[2,3,1]限制：0 &lt;= 链表长度 &lt;= 10000</code></pre><h5 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h5><blockquote><p>问题难点在于链表无法知道长度，以及无法进行随机访问</p><ol><li>使用栈或类似栈先进后出机制的数据结构来保存链表遍历的结果，最后将结果转换成数组即可，由于Java中有装箱拆箱机制，所以会增加耗时</li><li>遍历两次链表，第一次取得链表的长度，以此来初始化数组长度；第二次遍历利用数组可以随机访问的特点，从数组的尾到头进行赋值。</li></ol></blockquote><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">public int[] reversePrint(ListNode head) {    int count = 0;    ListNode temp = head;    while (temp != null) {        count ++;        temp = temp.next;    }    int[] result = new int[count];    while (head != null) {        result[count - 1] = head.val;        count -- ;        head = head.next;    }    return result;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer-05-替换空格</title>
    <link href="/2020/03/12/%E5%89%91%E6%8C%87Offer-05-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/"/>
    <url>/2020/03/12/%E5%89%91%E6%8C%87Offer-05-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</url>
    
    <content type="html"><![CDATA[<h4 id="05-替换空格"><a href="#05-替换空格" class="headerlink" title="(05)替换空格"></a>(05)替换空格</h4><h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><pre><code>请实现一个函数，把字符串 s 中的每个空格替换成&quot;%20&quot;。示例 1：输入：s = &quot;We are happy.&quot;输出：&quot;We%20are%20happy.&quot;限制：0 &lt;= s 的长度 &lt;= 10000</code></pre><h5 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h5><blockquote><p>1.遍历字符串，遇到空格就加入“%20”，遇到非空格直接加入。</p><p>2.通过正则表达式进行匹配替换（java中的replace API，但是提交发现比较耗时）</p></blockquote><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">public static String replaceSpace(String s) {    StringBuilder sb = new StringBuilder(s.length() * 3);    for (char c : s.toCharArray()) {        if (c == &#39; &#39;){            sb.append(&quot;%20&quot;);        } else {            sb.append(c);        }    }    return sb.toString();//  return s.replaceAll(&quot; &quot;, &quot;%20&quot;);}</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>(剑指Offer-04)二维数组中的查找</title>
    <link href="/2020/03/11/(%E5%89%91%E6%8C%87Offer-03)%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
    <url>/2020/03/11/(%E5%89%91%E6%8C%87Offer-03)%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<h4 id="04-二维数组中的查找"><a href="#04-二维数组中的查找" class="headerlink" title="(04)二维数组中的查找"></a>(04)二维数组中的查找</h4><h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><pre><code>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。示例:现有矩阵 matrix 如下：[  [1,   4,  7, 11, 15],  [2,   5,  8, 12, 19],  [3,   6,  9, 16, 22],  [10, 13, 14, 17, 24],  [18, 21, 23, 26, 30]]给定 target = 5，返回 true。给定 target = 20，返回 false。限制：0 &lt;= n &lt;= 10000 &lt;= m &lt;= 1000</code></pre><h5 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h5><blockquote><p>最简单的就是使用暴力破解，遍历进行比较，但这会使复杂度达到$O(n *m)$</p><p>仔细阅读题目可以看到该数组是有规律的，即<strong>每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序</strong>,利用这个规律，可以减少比较的次数。</p><p>根据这个规律，我们可以得到该二维数组左下角的值($matrix[n - 1][0]$)为该列的最大值，也是该行的最小值;右上角的值($matrix[0][m - 1]$)为该行的最大值，也是该列的最小值。可以从这两个位置出发，遵循一下原则(从左下角开始为例)：</p><ul><li>如果$matrix[i][j] &gt; target$则该值的行肯定小于<code>i</code>,所以可以直接跳到上一行，即<code>i++</code></li><li>如果$matrix[i][j] &lt; target$则该值的列一定大于<code>j</code>，所以可以从该行往后找，即<code>j--</code></li><li>如果$matrix[i][j] == target$则找到了该值</li></ul></blockquote><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">/**     * 面试题04 二维数组中的查找     * @param matrix 二维数组     * @param target 目标数字     * @return 目标数字是否存在     *///从左下角开始查找public boolean findNumberIn2DArray(int[][] matrix, int target) {    if (matrix == null) return false;    int m = matrix.length;    if (m == 0) return false;    int n = matrix[0].length;    int i = m - 1, j = 0;    while (i &gt;= 0 &amp;&amp; j &lt; n) {        if (matrix[i][j] &gt; target) {            i--;        } else if (matrix[i][j] &lt; target) {            j++;        } else {            return true;        }    }    return false;}//从右下角开始查找public boolean findNumberIn2DArray(int[][] matrix, int target) {    if (matrix == null) return false;    int m = matrix.length;    if (m == 0) return false;    int n = matrix[0].length;    int i = 0, j = n - 1;    while (i &lt; m &amp;&amp; j &gt;= 0) {        if (matrix[i][j] &gt; target) {            j--;        } else if (matrix[i][j] &lt; target) {            i++;        } else {            return true;        }    }    return false;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>(剑指Offer-03)数组中重复的数字</title>
    <link href="/2020/03/10/(%E5%89%91%E6%8C%87Offer-03)%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <url>/2020/03/10/(%E5%89%91%E6%8C%87Offer-03)%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<a id="more"></a><h4 id="03-数组中重复的数字"><a href="#03-数组中重复的数字" class="headerlink" title="(03)数组中重复的数字"></a>(03)数组中重复的数字</h4><h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><pre><code>找出数组中重复的数字。在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。示例 1：输入：[2, 3, 1, 0, 2, 5, 3]输出：2 或 3 限制：2 &lt;= n &lt;= 100000</code></pre><h5 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h5><blockquote><ul><li><p>使用<strong>HashSet</strong>的特性，当添加到没有的数字时返回<code>True</code>即可判断是否为重复的数字；也可以使用一个数组辅助实现hash方法。</p></li><li><p>问题中<code>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内</code>为核心要点，这句的意思即为若该数组无重复且排序的话，则该数组的值与其序号是相同的。所以可以通过将nums[i]与nums[nums[i]]位置的数字进行交换，若数字相同则进行返回。</p></li></ul></blockquote><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">/**     * 面试题03     * 数组中重复的数字     * @param nums 所给数组     * @return 重复数字     *///HashSet方法public int findRepeatNumber(int[] nums) {    if (nums == null || nums.length &lt; 2 || nums.length &gt; 100000) {        return 0;    }    Set&lt;Integer&gt; set = new HashSet&lt;&gt;(nums.length);    for (int i : nums) {        if (!set.add(i)) {            return i;        }    }    return -1;}//自实现Hash方法public int findRepeatNumber(int[] nums) {    int[] temp = new int[nums.length];    for (int i = 0 ; i &lt; nums.length ; i++) {        temp[nums[i]] ++;        if (temp[nums[i]] &gt; 1) {            return nums[i];        }    }    return -1;}//原地交换public int findRepeatNumber(int[] nums) {    int temp = 0;    for (int i = 0 ; i &lt; nums.length ; i ++) {        while (nums[i] != i) {            if (nums[i] == nums[nums[i]]) {                return nums[i];            } else {                temp = nums[i];                nums[i] = nums[temp];                nums[temp] = temp;            }        }    }    return 0;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo基本命令</title>
    <link href="/2020/03/10/Hexo%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    <url>/2020/03/10/Hexo%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h4 id="init"><a href="#init" class="headerlink" title="init"></a>init</h4><pre><code>hexo init [folder]</code></pre><blockquote><p>新建一个网站</p></blockquote><h4 id="hexo-new"><a href="#hexo-new" class="headerlink" title="hexo new"></a>hexo new</h4><pre><code>hexo new [layout] &lt;title&gt;</code></pre><blockquote><ul><li>新建一个title.md文档</li></ul></blockquote><h4 id="hexo-generate-hexo-g"><a href="#hexo-generate-hexo-g" class="headerlink" title="hexo generate(hexo g)"></a>hexo generate(hexo g)</h4><table><thead><tr><th style="text-align:left">选项</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">-d, –deploy</td><td style="text-align:left">文件生成后立即部署网站</td></tr><tr><td style="text-align:left">-w, –watch</td><td style="text-align:left">监视文件变动</td></tr><tr><td style="text-align:left">-b, –bail</td><td style="text-align:left">生成过程中如果发生任何未处理的异常则抛出异常</td></tr><tr><td style="text-align:left">-f, –force</td><td style="text-align:left">强制重新生成文件 Hexo 引入了差分机制，如果 <code>public</code> 目录存在，那么 <code>hexo g</code> 只会重新生成改动的文件。 使用该参数的效果接近 <code>hexo clean &amp;&amp; hexo generate</code></td></tr><tr><td style="text-align:left">-c, –concurrency</td><td style="text-align:left">最大同时生成文件的数量，默认无限制</td></tr></tbody></table><blockquote><p>生成网站静态文件到默认设置的 public 文件夹</p></blockquote><h4 id="publish"><a href="#publish" class="headerlink" title="publish"></a>publish</h4><pre><code>hexo publish [layout] &lt;fileName&gt;</code></pre><blockquote><p>发表草稿</p></blockquote><h4 id="hexo-server-hexo-s"><a href="#hexo-server-hexo-s" class="headerlink" title="hexo server(hexo s)"></a>hexo server(hexo s)</h4><blockquote><p>启动服务器，默认网址为<code>http://localhost:4000/</code></p></blockquote><table><thead><tr><th style="text-align:left">项</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">-p, –port</td><td style="text-align:left">重设端口</td></tr><tr><td style="text-align:left">-s, –static</td><td style="text-align:left">只使用静态文件</td></tr><tr><td style="text-align:left">-l, –log</td><td style="text-align:left">启动日记记录，使用覆盖记录格式</td></tr></tbody></table><h4 id="hexo-deploy-hexo-d"><a href="#hexo-deploy-hexo-d" class="headerlink" title="hexo deploy(hexo d)"></a>hexo deploy(hexo d)</h4><blockquote><p>部署网站到服务器</p></blockquote><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">-g, –generate</td><td style="text-align:left">部署之前预先生成静态文件</td></tr></tbody></table><h4 id="hexo-clean"><a href="#hexo-clean" class="headerlink" title="hexo clean"></a>hexo clean</h4><blockquote><p>清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客</tag>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
