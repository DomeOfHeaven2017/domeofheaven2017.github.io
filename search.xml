<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[《Kotlin实战》学习笔记-注解与反射]]></title>
    <url>%2F2020%2F09%2F13%2F%E3%80%8AKotlin%E5%AE%9E%E6%88%98%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[注解与反射 声明并应用注解​ 一个注解会把额外的元数据关联到一个声明上，然后元数据就可以被相关的源代码工具访问。 应用注解 class MyTest&#123; @Test fun testTrue() &#123; ... &#125; &#125; 应用一个注解，以@字符作为名字的前缀，并放在要注解的声明最前面 注解支持的参数类型：基本数据类型，字符串，枚举，类引用，其他的注解类以及前面类型的数组 要把一个类指定为注解实参，在类名后加::class:@Annotation 要把另一个注解指定为一个实参，去掉注解名称前面的@ 要把一个数组指定为一个实参，使用arrayOf函数 注解实参需要在编译期就是已知的，要引用属性作为实参，需要用const修饰符标记为编译期常量 注解目标 使用点目标声明被用来说明要注解的元素 class HasTempFolder&#123; @get:Rule val folder = TemporaryFolder() //注解的是getter,不是属性 &#125; kotlin支持的使用点目标列表如下： | Name | Mean || ——– | ———————————— || property | Java的注解不能应用这种使用点目标 || field | 为属性生成的字段 || get | 属性的getter || set | 属性的setter || receiver | 扩展函数或扩展属性的接收者参数 || param | 构造方法的参数 || setparam | 属性setter的参数 || delegate | 为委托属性存储委托实例的字段 || file | 包含在文件中声明的顶层函数和属性的类 | 用注解控制Java API @JvmName : 改变由Kotlin生成的Java方法或字段的名称 @JvmStatic : 用在对象声明或伴生对象的方法上，暴露成Java的静态方法 @JvmOverloads:指导Kotlin编译器为带默认参数值的函数生成多个重载 @JvmField : 应用于一个属性，暴露成一个没有访问器的公有Java字段 注解使用实践 声明注解 //无参注解 annotation class JsonExclude //带参数注解 annotation class JsonName(val name: String) 元注解：控制如何处理一个注解 应用到注解类上的注解被称为元注解 @Target(AnnotationTarget.PROPERTY) annotation class JsonExclude Java中的注解默认会在.class文件中保留注解但不会使其在运行时访问到 Kotlin中的注解默认拥有RUNTIME保留期 使用类做注解参数 可以通过声明一个拥有类引用作为形参的注解类来引用类作为声明的元数据。 //定义 //KClass是Java的java.lang.Class在Kotlin中的对应类型，用来保存Kotlin类的引用 annotation class DeserializeInterface(val targetClass: KClass&lt;out Any&gt;) interface Company &#123;&#125; data class CompanyImpl() : Company //使用,使用类名称后面添加::class关键字来引用一个类 data class Person( @DeserializeInterface(CompanyImpl::class) val company: Company ) 使用泛型类做注解参数 //定义 annotation class CustomSerializer( val serializerClass: KClass&lt;out ValueSerializer&lt;*&gt;&gt; ) interface ValueSerializer&lt;T&gt; &#123; fun toJsonValue(value: T): Any? &#125; object DateSerializer : ValueSerializer&lt;Date&gt; &#123; private val dateFormat = SimpleDateFormat("dd-mm-yyyy") override fun toJsonValue(value: Date): Any? = dateFormat.format(value) &#125; //使用 data class Person( @CustomSerializer(DateSerializer::class) val birthDate: Date ) 反射：在运行时对Kotlin对象进行自省 Kotlin反射API KClass代表一个类，对应java.lang.class,可以用它列举和访问类中包含的所有声明。 interface KClass&lt;T: Any&gt; &#123; val members: Collection&lt;KCallable&lt;*&gt;&gt; val constructors: Collection&lt;KFunction&lt;T&gt;&gt; val nestedClasses: Collection&lt;KClass&lt;*&gt;&gt; &#125; KCallable是函数和属性的超接口，它声明了Call方法，允许调用对应的函数或者对应属性的getter KFunction1是合成的编译器生成类型，其表示为KFunction1&lt;Int, Unit&gt;,1表示该函数接收1个形参，Int为形参类型，Unit为返回类型 KProPerty是一个泛型类，其表示为KProperty&lt;XXX, Int&gt;第一个类型参数表示接收者类型，第二个表示属性类型 只能使用反射访问定义在最外层或者类中的属性，不能访问函数的局部变量 classDiagram KAnnotatedElement]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Kotlin实战》学习笔记-泛型]]></title>
    <url>%2F2020%2F09%2F06%2F%E3%80%8AKotlin%E5%AE%9E%E6%88%98%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%B3%9B%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[泛型 泛型类型参数​ 泛型允许定义带类型形参的类型。当这种类型的实例被创建时，类型形参被替换成称为类型实参的具体类型。Kotlin中要求类型实参要么被显式地说明，要么能被编译器推导出来。 泛型函数和属性 泛型函数有自己的类型形参，这些类型形参在每次函数调用时都必须替换成具体的类型实参。 graph LR A["fun < T > List< T >.slice(indices: IntRange): List< T >"] val letters = ('a'..'z').toList() //显式地指定类型实参 println(letters.slice&lt;Char&gt;(0..2)) //编译器推导出T的类型 println(letters.slice(10..13)) 可以给类或接口的方法，顶层函数，以及扩展函数声明类型参数。 val &lt;T&gt; List&lt;T&gt;.penutimate: T get() = this[size - 2] 声明泛型类 interface Comparable&lt;T&gt; &#123; fun compareTo(other: T): Int &#125; class String: Comparable&lt;String&gt; &#123; override fun compareTo(other: String): Int = /*****/ &#125; 类型参数约束 类型参数约束可以限制作为(泛型)类和(泛型)函数的类型实参的类型。 通过在类型参数后指定上界来定义约束 //Java中的上界约束 &lt;T extends Number&gt; T sum(List&lt;T&gt; list) //Kotlin中的上界约束 fun &lt;T ：Number&gt; List&lt;T&gt;.sum(): T //Kotlin中指定多个约束 fun test(seq: T) where T: CharSequence, T: Appendable&#123;&#125; 让类型形参非空 没有指定上界的类型形参默认使用Any?来作为上界，如果想保证替换类型形参的始终是非空类型，可以使用Any作为默认上界 class Processor&lt;T: Any&gt; &#123; fun process(value: T)&#123; value.hashCode() &#125; &#125; 运行时的泛型：擦除和实化类型参数 类型检查和转换 JVM上的泛型一般是通过类型擦除实现的，泛型类实例的类型实参在运行时是不保留的。与Java一样，Kotlin的泛型在运行时也被擦除了，泛型类实例不会携带用于创建它的类型实参的信息。擦除泛型类型信息可以使应用程序使用的内存总量较少。 //list1和list2在运行时都只是List，不会知道其中包含的是字符串还是整数 val list1: List&lt;String&gt; = listOf("a", "b") val list2: List&lt;Int&gt; = listOf(1, 2, 3) 声明带实化参数的函数 内联函数的类型形参能够被实化，可以在运行时引用实际的类型实参。使用inline标记一个函数，编译器会把每一次函数调用都换成函数实际的代码实现。 inline fun &lt;reified T&gt; isA(value: Any) = value is T println(isA&lt;String&gt;("abc")) //true println(isA&lt;String&gt;(123)) //false 带refied类型参数的inline函数不能在Java代码中调用。 使用实化类型参数代替类引用 inline fun &lt;reified T: Activity&gt; Context.startActivity() &#123; val intent = Intent(this, T::class.java) startActivity(intent) &#125; //调用 startActivity&lt;MainActivity&gt;() 实化类型参数的限制 可以按下面方式使用实化类型参数 用在类型检查和类型转换中(is, !is, as, as?) 使用Kotlin反射API 获取相应的java.lang.class 作为调用其他函数的类型实参 不能做以下事情 创建指定类型参数的类的实例 调用类型参数类的伴生对象的方法 调用带实化类型参数函数的时候使用非实化类型形参作为类型实参 把类，属性或者非内联函数的类型参数标记为reified 变型：泛型和子类型化 类，类型和子类型 对于非泛型类，类的名称可以直接当作类型使用；对于泛型类，要得到一个合法的类型，需要作为类型实参的具体类型替换类的类型形参。每一个泛型类都可能生成潜在无数数量的类型。例如List是一个类，List&lt;String&gt;,List&lt;Int&gt;等都是类型。 子类型：如果期望A的时候可以使用B,则B就是A的子类型 超类型：如果A是B的子类型，则B就是A的超类型 协变：保留子类型化关系 如果A是B的子类型，那么Product&lt;A&gt;是Product&lt;B&gt;的子类型，则子类型化被保留了。在Kotlin中要声明类在某个类型参数上是可以协变的，需在该类型参数的名称前加out关键字 interface Product&lt;out T&gt; &#123; fun product(): T &#125; 将一个类的类型参数标记为协变的，在该类型实参没有精确匹配到函数中定义的类型形参时，可以让该类的值作为函数的实参传递，也可作为函数返回值。 在类成员的声明中类型参数的使用可以分为in位置和out位置 in位置：函数参数的类型 out位置：函数的返回类型 构造方法的参数,私有方法的参数既不在in位置也不在out位置 类型参数T上的关键字out有两层含义： 子类型化会被保留 T只能用在out位置 逆变：反转子类型化关系 如果B是A的子类型，那么Comsumer&lt;A&gt;就是Comsumer&lt;B&gt;的子类型,子类型化被反转了。逆变可以看作是协变的镜像：对一个逆变类来说，它的子类型化关系与用作类型实参的类的子类型化关系是相反的。 interface Comparator&lt;in T&gt; &#123; fun compare(e1: T, e2: T): Int &#125; in关键字的意思是，对应类型的值是传递进来给这个类的方法的，并被这些方法消费。 | 协变 | 逆变 | 不变型 || :—————– | :————- | :————– || Product | Consumer | MutableList || 类的子类型化保留了 | 子类型化反转了 | 没有子类型化 || T只能在out位置 | T只能在in位置 | T可以在任意位置 | 一个类可以在一个类型参数上协变，同时在另外一个类型参数上逆变 interface Function1&lt;in P, out R&gt;&#123; operator fun invoke(p: P): R &#125; 点变型：在类型出现的地方指定变型 声明点变型：在类声明的时候指定变型修饰符 使用点变型：每次使用带类型参数的类型时，指定这个类型参数是否可以用它的子类型或超类型。 Kotlin的使用点变型对应Java的限界通配符 | Kotlin | Java || ——— | ————— || &lt;out T&gt; | &lt;? extends T&gt; || &lt;in T&gt; | &lt;? super T&gt; | 星号投影：使用*代替类型参数 当类型参数的信息并不重要的时候，可以使用星号投影的语法：不需要使用任何在签名中引用类型参数的方法，或者只是读取数据而不关心它的具体类型 fun printFirst(list: List&lt;*&gt;) &#123; if (list.isNotEmpty()) &#123; println(list.first() ) &#125; &#125;]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Kotlin实战》学习笔记-高阶函数Lambda]]></title>
    <url>%2F2020%2F09%2F02%2F%E3%80%8AKotlin%E5%AE%9E%E6%88%98%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0Lambda%2F</url>
    <content type="text"><![CDATA[高阶函数:Lambda作为形参和返回值 声明高阶函数 高阶函数即以另一个函数作为参数或返回值的函数.在Kotlin中,函数可以用lambda或者函数引用来表示.则任何以lambda或者函数引用作为参数或返回值的函数都是高阶函数. 函数类型 Kotlin中的函数类型语法:箭头左侧为参数类型,右侧为返回类型 graph LR A["(Int,String)"] --> B["Unit"] //声明返回值可空的函数类型 var canReturnNull: (Int,Int) -&gt; Int? = &#123; null &#125; //声明可空的函数类型的变量 var funOrNull : ((Int,Int) -&gt; Int)? = null 调用作为参数的函数 fun twoAndThree(operation : (Int,Int) -&gt; Int)&#123; println(operation(2,3)) &#125; 返回函数的函数 声明一个返回另一个函数的函数,需要指定一个函数类型作为返回类型 fun getShippingCostCalutor(delivery:Delivery) : (Order) -&gt; Double&#123; ..... return &#123;order -&gt; 1.2*itemcount&#125; &#125; 内联函数 lambda表达式会被正常编译为匿名类，每调用一次lambda就会额外创建一个类，带来运行时的额外开销 使用inline修饰符标记一个函数,在函数被使用时编译器不会生成函数调用的代码,而是使用函数实现的真实代码替换每一次的函数调用 当一个函数被声明为inline时,函数体会被直接替换到函数被调用的地方,而不是正常调用 给内联函数传递一个函数类型的变量为参数而不是lambda时不会被内联. 如果在两个不同的位置使用同一个内联函数,但是用的是不同的lambda,那么内联函数会在每一个被调用的位置被分别内联. 高阶函数中控制流 lambda中的返回语句-从封闭函数返回 在lambda中使用return关键字,会从调用lambda的函数中返回,并不只是从lambda中返回 只有在以lambda作为参数的函数是内联函数的时候才能从更外层的函数返回 从lambda返回-使用标签返回 从一个lambda表达式处返回需要在return关键字后面引用标签 people.forEach label@&#123; if(it.name == "Alice") return@label //返回表达式标签 &#125; 可以自定义标签名或者使用函数名作为标签，但显式地指定了lambda表达式之后，再使用函数名作为标签会没有任何效果。一个lambda表达式的标签数量不能多于一个。 匿名函数-默认使用局部返回 people.forEach(fun (person)&#123; if(person.name == "Alice") return println("$&#123;person.name&#125; is not Alice") &#125;) 在匿名函数中,不带标签的return表达式会从匿名函数返回,而不是从包含匿名函数的函数返回:return从最近的使用fun关键字声明的函数返回 尽管匿名函数看起来和普通函数很相似，但它其实是lambda表达式的另一种语法形式]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Kotlin实战》学习笔记-运算符重载及其他约定]]></title>
    <url>%2F2020%2F09%2F01%2F%E3%80%8AKotlin%E5%AE%9E%E6%88%98%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E5%8F%8A%E5%85%B6%E4%BB%96%E7%BA%A6%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[运算符重载及其他约定 重载算术运算符 重载二元算术运算 //定义一个plus运算符 data class Point(val x:Int,val y:Int)&#123; //使用operator关键字来进行声明 operator fun plus(other:Point):Point&#123; return Point(x+other.x,y+other.y) &#125; &#125; //val p1 = Point(10,20) //val p2 = Point(30,40) //println(p1+p2) 使用+号来调用"plus"方法 //把运算符定义为一个扩展函数 operator fun Point.plus(other:Point):Point&#123; return Point(x+other.x,y+other.y) &#125; 可重载的二元算术运算符 | 表达式 | 函数名 || —— | —— || a * b | times || a / b | div || a % b | mod || a + b | plus || a - b | minus | Kotlin运算符不会自动支持交换性(交换运算符的左右两边) Kotlin中用于执行位运算的完整函数列表: | 函数名 | 含义 || —— | ———- || shl | 带符号左移 || shr | 带符号右移 || ushr | 无符号右移 || and | 按位与 || or | 按位或 || xor | 按位异或 || inv | 按位取反 | 重载复合赋值运算符 +=, -=等这些运算符被称为复合赋值运算符 重载一元运算符 operator fun Point.unaryMinus():Point&#123; return Point(-x,-y) &#125; val p = Point(10,20) println(-p) 可重载的一元运算符 | 表达式 | 函数名 || ——- | ———- || +a | unaryPlus || -a | unaryMinus || !a | not || ++a,a++ | inc || –a,a– | dec | 重载比较运算符 等号运算符:“equals” graph LR A[a == b] --> B["a?.equals(b) ?: (b == null)"] Kotlin中的===恒等运算符与Java中的==运算符一致:检查两个参数是否为同一对象的引用(如果是基本类型则检查值是否相等).===运算符不能被重载 排序运算符:compareTo graph LR A[a >= b] --> B["a.compareTo(b) >= 0"] 集合与区间的约定 通过下标来访问元素:“get”和“set” graph LR A["x[a,b]"] --> B["x.get(a,b)"] 方括号的访问会被转换为get函数的调用 graph LR A["x[a,b] = c"] --> B["x.set(a,b,c)"] 方括号的赋值操作会被转换为set函数的调用 “in”的约定 用于检查某个对象是否属于集合,对应函数为contains graph LR A["a in c"] --> B["c.contains(a)"] rangeTo的约定 graph LR A["start..end"] --> B["start.rangeTo(end)"] 解构声明和组件函数 一个解构声明看起来像一个普通的变量声明,但它在括号中有多个变量.可以使用其返回多个值. graph LR A["val (a,b) = p"] --> B["val a = p.component1()"] A --> C["val b = p.component2()"] 使用解构声明来遍历map fun printEntries(map:Map&lt;String,String)&#123; for((key,value) in map)&#123; println("$key -&gt; $value") &#125; &#125; 委托属性 委托属性基本用法 //属性p将它的访问器逻辑委托给了Delegate对象 //通过关键词by对其后的表达式求值来获取这个对象 class Foo&#123; var p: Type by Delegate() &#125; 惰性初始化和“by lazy()” class Person(val name : String)&#123; val emails by lazy &#123; loadEmails(this) &#125; &#125; lazy函数返回一个对象,该对象具有一个名为getValue的方法. 实现委托属性 class ObservableProperty( var propValue: Int, val changeSupport: PropertyChangeSupport ) &#123; operator fun getValue(p: Person, prop: KProperty&lt;*&gt;): Int = propValue operator fun setValue(p: Person, prop: KProperty&lt;*&gt;, newValue: Int) &#123; val oldValue = propValue propValue = newValue changeSupport.firePropertyChange(prop.name, oldValue, newValue) &#125; &#125; class Person( val name: String, age: Int, salary: Int ) : PropertyChanggeAware&#123; var age: Int by ObservableProperty(age, changeSupport) var salary: Int by ObservableProperty(salary, changeSupport) &#125; 委托属性的变换规则 当访问属性时，会调用的getValue和setValue函数 graph LR a["val x = c.prop"] --> b["val x= < delegate>.getValue(c, < property>)"] c["c.prop = x"] --> d["< delegate>.setValue(c,< property>, x)"]]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Kotlin实战》学习笔记-Kotlin的类型系统]]></title>
    <url>%2F2020%2F08%2F31%2F%E3%80%8AKotlin%E5%AE%9E%E6%88%98%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Kotlin%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[Kotlin的类型系统 可空性 可空类型 Kotlin对可空类型显示的支持.问号?可以加在任何类型后面表示这个类型的变量是可空的。 类型的含义 类型:类型就是数据的分类,决定了该类型可能的值,以及在该类型的值上可以完成的操作. 安全调用运算符?. graph LR A[foo?.bar] --> B[foo.bar] A --> C[null] 如图所示,使用安全调用运算符时,如果foo对象不为null则会调用;否则不会调用bar方法 //使用安全调用处理可空属性 class Employee(val name:String,val manager:Employee?) fun managerName(employee:Employee):String? = employee,manager?.name Elvis运算符(null合并运算符)?: graph LR A[foo?:bar] --> B[foo] A --> C[bar] 如上图所示,当foo不为null时,结果为foo对象;否则为bar对象. fun strLenSafe(s:String?):Int = s?.length?:0 安全转换as? 该运算符会尝试将值转换为指定的类型,如果值不是合适的类型就返回null graph LR A[foo as? Type] --> B[foo as Type] A --> C[null] 非空断言!! graph LR A[foo!!] --> B[foo] A --> C[NullPointerException] !!可以将任何值转换为非空类型,但如果对null做非空断言,则会抛出NPE let函数 let函数会把一个调用它的对象变成lambda表达式的参数 //let函数只会在email的值非空时调用 email?.let&#123; email -&gt; sendEmailTo(email) &#125; 延迟初始化属性 使用lateinit修饰符来声明延迟初始化属性,因为需要在构造方法之外修改值,所以延迟初始化的属性都是var. private lateinit var myService: MyService 可空类性的扩展 为可空类型定义扩展函数来接收和处理可能为null的情况. fun String?.isNullOrBlank(): Boolean = this == null || this.isBlank() &gt; 扩展函数中的`this`可能为`null`,所以必须显式地检查. 类型参数的可空性 Kotlin中所有泛型类和泛型函数的类型参数默认都是可空的. fun &lt;T&gt; printHashCode(t:T)&#123; println(t?.hashCode()) //因为`t`可能为null,所以必须使用安全调用 &#125; //为类型参数声明非空上界来拒绝可空值作为实参 fun &lt;T:Any&gt; printHashCode(t: T)&#123; println(t.hashCode()) &#125; 可空性和Java Java中的@Nullable注解表达的参数被Kotlin当作可空类型,即Any?;而@NotNull注解表达的参数被Kotlin当作Any 基本数据类型和其他基本类型 基本数据类型:Int,Boolean及其他 Java中分为基本数据类型和引用类型.基本数据类型的变量直接存储了值,可以高效的存储和传递,但是不能调用方法;引用类型的变量存储了指向包含该对象的内存地址的引用.因此Java中增加了包装类型 数字转换 Kotlin不会自动把数字从一种类型转换为另一种,必须显式的进行转换. val x = 1 println(x.toLong() in listOf(1L,2L,3L)) ‘Any’和‘Any?’:根类型 Any类型是Kotlin所有非空类型的超类型;Any?是可空类型的超类型 Unit类型:Kotlin中的‘Void’ Unit可以作为类型参数,void不可以 interface Processor&lt;T&gt;&#123; fun process():T &#125; class NoResultProcessor : Processor&lt;Unit&gt;&#123; override fun process()&#123; //不需要显式的return &#125; &#125; Nothing类型 Nothing类型没有任何值,只有被当作函数返回值使用,或被当作泛型函数返回值的类型使用才有意义. 集合与数组 可空性和集合 与变量一样,可以使用?标记是否可以为null 声明一个包含可空类型的可空列表:List&lt;Int?&gt;? 只读集合与可变集合 只读集合(Collection):只能对集合中的数据进行读取操作 可变集合(MutableCollection):可以修改集合中的数据 只读集合不一定是不可变的,不总是线程安全的. | 集合类型 | 只读 | 可变 || ——– | —— | ———————————————- || List | listOf | mutableListOf,arrayListOf || Set | setOf | mutableSetOf,hashSetOf,linkedSetOf,sortedSetOf || Map | mapOf | mutableMapOf,hashMapOf,linkedMapOf,sortedMapOf | 对象和基本数据类型的数组 Kotlin中的一个数组是一个带有参数类型的类,其元素类型被指定为相应的类型参数; 数组类型的类型参数始终会变成对象类型. 创建数组: arrayOf:创建的数组包含的元素是指定为该函数的实参 arrayOfNulls:创建包含null元素的数组 Array构造方法:接收数组的大小和lambda表达式来创建数组 val letters = Array&lt;String&gt;(26)&#123; i -&gt; ('a' + i).toString()&#125;]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Kotlin实战》学习笔记-Lambda编程]]></title>
    <url>%2F2020%2F08%2F30%2F%E3%80%8AKotlin%E5%AE%9E%E6%88%98%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Lambda%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Lambda 编程 Lambda 简介 Lambda表达式(Lambda),本质上是可以传递给其他函数的一小段代码 Lambda表达式语法 可以把Lambda表达式存储在一个变量中,把这个变量当作普通函数对待. //定义 val sum = &#123;x:Int,y:Int -&gt; x + y &#125; //调用 println(sum(1,2)) Kotlin中当Lambda表达式是函数调用的最后一个实参时,可以将表达式放在括号外;且当Lambda式函数唯一的实参时,可以去掉调用代码中的空括号. //作用等价 people.maxBy(&#123; p:Person -&gt; p.age&#125;) people.maxBy()&#123; p:Person -&gt; p.age&#125; people.maxBy&#123; p:Person -&gt; p.age&#125; people.maxBy&#123; p -&gt; p.age&#125; //编译器能推导出参数类型 people.maxBy&#123; it.age &#125; Lambda也可以包含多条语句 val sum = &#123; x:Int,y:Int -&gt; println("Computing the sum of $x and $y") x + y &#125; 成员引用 使用::运算符,将函数转换成一个值传递给函数 val getAge = Person :: age //引用顶层函数 val action = &#123; person : Person,message : String -&gt; sendEmail(person,message) &#125; val nextAction = ::sendEmail 不管引用的是函数还是属性，都不要在成员引用的名称后面加括号 集合函数API filter:过滤掉不满足给定lambda表达式的元素,结果是一个新集合 //filter函数定义 /** * Returns a list containing only elements matching the given [predicate]. */ public inline fun &lt;T&gt; Iterable&lt;T&gt;.filter(predicate: (T) -&gt; Boolean): List&lt;T&gt;&#123; return filterTo(ArrayList&lt;T&gt;(), predicate) &#125; //filter函数使用 val list = listOf(1,2,3,4) println(list.filter &#123; it % 2 == 0 &#125;) //[2,4] map:对集合中的每个元素应用给定的函数,并把结果收集到一个新集合 //map函数定义 /** * Returns a list containing the results of applying the given [transform] function * to each element in the original collection. */ public inline fun &lt;T, R&gt; Iterable&lt;T&gt;.map(transform: (T) -&gt; R): List&lt;R&gt; &#123; return mapTo(ArrayList&lt;R&gt;(collectionSizeOrDefault(10)), transform) &#125; //map函数使用 val list = listOf(1,2,3,4) println(list.map&#123; it * 2&#125;) //[2,4,6,8] all:当所有元素都满足给定判别式时返回true //all函数定义 /** * Returns `true` if all elements match the given [predicate]. * * @sample samples.collections.Collections.Aggregates.all */ public inline fun &lt;T&gt; Iterable&lt;T&gt;.all(predicate: (T) -&gt; Boolean): Boolean &#123; if (this is Collection &amp;&amp; isEmpty()) return true for (element in this) if (!predicate(element)) return false return true &#125; //all函数使用 val people = listOf(Person("Stephanie",26),Person("Dome",24)) println(people.all&#123; it.age &lt; 27 &#125;) //true any:检查集合所有元素中是否至少存在一个匹配的元素 //any函数定义 /** * Returns `true` if collection has at least one element. * * @sample samples.collections.Collections.Aggregates.any */ public fun &lt;T&gt; Iterable&lt;T&gt;.any(): Boolean &#123; if (this is Collection) return !isEmpty() return iterator().hasNext() &#125; //any函数使用 val people = listOf(Person("Stephanie",26),Person("Dome",24)) println(people.any&#123; it.age &lt; 27 &#125;) //true count:返回集合中满足给定判断式的元素个数 //count函数定义 /** * Returns the number of elements matching the given [predicate]. */ public inline fun &lt;T&gt; Iterable&lt;T&gt;.count(predicate: (T) -&gt; Boolean): Int &#123; if (this is Collection &amp;&amp; isEmpty()) return 0 var count = 0 for (element in this) if (predicate(element)) count++ return count &#125; //count函数使用 val people = listOf(Person("Stephanie",26),Person("Dome",24)) println(people.count&#123; it.age &gt; 25 &#125;) //1 groupBy:将集合按照给定的规则分成组,结果是一个map /** * Groups elements of the original collection by the key returned by the given [keySelector] function * applied to each element and returns a map where each group key is associated with a list of corresponding elements. * * The returned map preserves the entry iteration order of the keys produced from the original collection. * * @sample samples.collections.Collections.Transformations.groupBy */ public inline fun &lt;T, K&gt; Iterable&lt;T&gt;.groupBy(keySelector: (T) -&gt; K): Map&lt;K, List&lt;T&gt;&gt; &#123; return groupByTo(LinkedHashMap&lt;K, MutableList&lt;T&gt;&gt;(), keySelector) &#125; //groupBy使用 val list = listOf(1,2,3,4) println(list.groupBy &#123; it &gt; 2 &#125;) //&#123;false=[1, 2], true=[3, 4]&#125; flayMap:对集合中的每个元素根据给定的函数作映射,然后将多个列表合并成一个 /** * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original collection. */ public inline fun &lt;T, R&gt; Iterable&lt;T&gt;.flatMap(transform: (T) -&gt; Iterable&lt;R&gt;): List&lt;R&gt; &#123; return flatMapTo(ArrayList&lt;R&gt;(), transform) &#125; //flatMap函数使用 val list = listOf("Stephanie","DomeOfHeaven") println(list.flatMap &#123; it.toList()&#125;) //[S, t, e, p, h, a, n, i, e, D, o, m, e, O, f, H, e, a, v, e, n] 惰性集合操作:序列 链式集合函数会及早地创建中间集合，每一步的中间结果都被存储在一个临时列表。序列中的元素求值是惰性的，可以使用序列(Sequence)更高效地执行链式操作，不会创建中间结果。 执行序列操作：中间和末端操作 序列操作分为中间的和末端的两类，一次中间操作返回的是另一个序列；一个末端操作返回的是一个结果。 中间操作始终都是惰性的，末端操作触发执行了所有延期运算。 序列中所有操作都是按顺序应用在每一个元素上，处理完第一个(先映射再过滤),然后完成下面的元素，依次类推。 创建序列 在集合上调用asSequence方法 val people = listOf(Person("mym", 26), Person("zzc", 28)) people.asSequence().map(Person.age).filter&#123;it &gt;= 27&#125;.toList() 使用generateSequence函数 //给定序列的前一个元素，该函数会计算出下一个元素 val naturalNum = generateSequence(0)&#123;it + 1&#125; 使用Java函数式接口 把lambda当作参数传递给Java方法 SAM构造方法：显式地把lambda转换成函数式接口 SAM代表单抽象方法，SAM构造方法是编译器生成的函数。 fun createAllDone(): Runnable &#123; return Runnable &#123;println("All Done")&#125; &#125; with函数 /** * Calls the specified function [block] with the given [receiver] as its receiver and returns its result. */ @kotlin.internal.InlineOnly public inline fun &lt;T, R&gt; with(receiver: T, block: T.() -&gt; R): R &#123; contract &#123; callsInPlace(block, InvocationKind.EXACTLY_ONCE) &#125; return receiver.block() &#125; //with函数使用 with(obj)&#123; //this:obj ... &#125; apply函数 /** * Calls the specified function [block] with `this` value as its receiver and returns `this` value. */ @kotlin.internal.InlineOnly public inline fun &lt;T&gt; T.apply(block: T.() -&gt; Unit): T &#123; contract &#123; callsInPlace(block, InvocationKind.EXACTLY_ONCE) &#125; block() return this &#125; //apply函数使用 obj.apply&#123; //this:obj ... &#125;]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Kotlin实战》学习笔记-类，对象和接口]]></title>
    <url>%2F2020%2F08%2F23%2F%E3%80%8AKotlin%E5%AE%9E%E6%88%98%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%B1%BB%EF%BC%8C%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[类，对象和接口 接口 //声明 interface Clickable&#123; fun click() fun showOff = println("click show off") //带默认实现的方法 &#125; interface Focusable&#123; fun showOff = println("focus show off") &#125; //实现 class Button : Clickable,Focusable&#123; override fun click() = println("button clicked") override fun showOff()&#123; //使用尖括号加父类型名字的＂super＂表明调用哪一个父类的方法 super&lt;Clickable&gt;.showOff() super&lt;Focusable&gt;.showOff() &#125; &#125; 接口中可以包含抽象方法的定义和非抽象方法的实现，但不能包含任何状态． 使用:代替了Java中的extends和implements． 使用override修饰符来标注被重写的父类或者接口的方法和属性，是强制要求的． 如果实现多个接口中有相同带默认实现的方法，不会使用任何一个，必须显式实现该方法． open,final和abstrace修饰符 open class RichButton : Clickable&#123; fun disable() &#123;&#125; open fun animate() &#123;&#125; override fun click() &#123;&#125; final override fun showOff() &#123;&#125; &#125; abstract class Animated&#123; abstract fun animate() //抽象函数，子类必须重写 open fun stopAnimating() &#123;&#125; fun animateTwice() &#123;&#125; &#125; Java中的类和方法默认是open的，而Kotlin中默认是final的，想继承或重写必须使用open修饰符 重写了的基类或者接口的成员默认是open的，可以使用final阻止重写 抽象类中抽象方法，子类必须实现，且抽象成员始终open的 | 修饰符 | 相关成员 | 备注 || ——– | ———————- | ——————————————- || final | 不能被重写 | 类中成员默认使用 || open | 可以被重写 | 需要明确表明 || abstract | 必须被重写 | 只能在抽象类中使用抽象成员不能有实现 || override | 重写父类或接口中的成员 | 没有使用final表明，重写的成员默认是开放的 | 可见性修饰符 | 修饰符 | 类成员 | 顶层声明 || ————– | ———— | ———— || public（默认） | 所有地方可见 | 所有地方可见 || internal | 模块中可见 | 模块中可见 || protected | 子类中可见 | － || private | 类中可见 | 文件中可见 | 类的基础类型和类型参数列表中用到的所有类，或者函数的签名都有与这个类或者函数本身相同的可见性 Kotlin中一个外部类不能看到其内部（或者嵌套）类中的private成员 内部类和嵌套类：默认是嵌套类 Java中在一个类中声明另一个类时，会默认变成其内部类。使用static修饰则会从这个类中删除包围它的类的隐式引用。 Kotlin中没有显示修饰符的嵌套类与Java中的static嵌套类是一样的。要把它变成一个内部类来持有一个外部类的引用的话需要使用inner修饰符。 | 类A在类B中声明 | 在Java中 | 在Kotlin中 || :————————–: | :————: | :———–: || 嵌套类（不存储外部类的引用） | static class A | class A || 内部类（存储外部类的引用） | class A | inner class A | //引用外部类实例 class Outer&#123; inner class Inner&#123; fun getOutReference(): Outer = this@Outer &#125; &#125; 密封类：定义受限的类继承结构 sealed类：为父类添加一个sealed修饰符，对可能创建的子类做出严格的限制．所有的子类必须嵌套在父类中． sealed修饰符隐含的表示这个类是一个open类，不需要显式地添加open修饰符 //将基类标记为密封的，将所有可能的类作为嵌套类列出 sealed class Expr&#123; class Num(val value:Int) : Expr() class Sum(val left:Expr,val right:Expr) : Expr() &#125; fun eval(e:Expr) : Int = when(e)&#123; is Expr.Num -&gt; e.value is Expr.Sum -&gt; eval(e.right) + eval(e.left) //when 表达式涵盖了所有可能的情况，不需要 else 分支 &#125; 密封类不能在类外部拥有子类 初始化类：主构造方法和初始化语句块 主构造方法： 表明构造方法的参数 定义使用这些参数初始化的属性 主构造方法不能包含初始化代码，相关初始化操作放在初始化语句块中执行 class User constructor (_nickname : String) &#123; //带一个参数的主构造方法 val nickname : String //初始化语句块 init&#123; nickname = _nickname &#125; &#125; class User(val nickname: String) //val表示相应的属性会用构造方法的参数来初始化 constructor : 用来开始一个主构造方法或从从构造方法的声明 init: 引入一个初始语句块 数据类和类委托 //数据类 data class Client(val name: String, val postalCode: Int) 定义了数据类之后，Kotlin会自动生成equals, hashCode, toString, copy方法 equals : 用来比较实例 hashCode : 用来作为例如HashMap这种基于哈希容器的键 toString : 用来为类生成按顺序排列的所有字段的字符串表达形式 copy : 拷贝类的实例，并可以在拷贝的同时修改某些属性的值 //类委托 class CountingSet&lt;T&gt; : MutableCollection&lt;T&gt; by innerSet&#123;&#125; 在实现一个接口时，可以使用by关键字将接口的实现委托到另一个对象。 object关键字:定义一个类并同时创建一个实例 应用场景: 定义单例: //定义 object Payroll&#123; val allEmployees = arrayListOf&lt;Person&gt;() fun calculateSalary()&#123; ... &#125; &#125; //调用 Payroll.allEmployees.add(Person()) Payroll.calculateSalary() 伴生对象 Kotlin中的类不能拥有静态成员(没有Java中的static关键字),为了能在外部访问类中的私有成员,可以使用伴生对象. 伴生对象是一个声明在类中的普通对象,可以实现接口或者有扩展函数或属性 伴生对象成员在子类中不能被重写 class A&#123; //可以省略名称,默认名称为 Companion companion object Example&#123; fun bar()&#123; println("Companion object called") &#125; &#125; &#125; //调用 A.bar() A.Example.bar() 匿名对象 替代了Java中的匿名内部类的用法. Java中匿名内部类只能扩展一个类或者实现一个接口;Kotlin中的匿名对象可以实现多个接口 匿名对象不是单例的,每次执行都会创建一个新的对象实例 windwo.addMouseListener( object : MouseAdapter()&#123; override fun mouseClicked(...)&#123; ... &#125; override fun mouseEntered(...)&#123; ... &#125; &#125; )]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Kotlin实战》学习笔记-函数的定义与调用]]></title>
    <url>%2F2020%2F08%2F19%2F%E3%80%8AKotlin%E5%AE%9E%E6%88%98%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E8%B0%83%E7%94%A8%2F</url>
    <content type="text"><![CDATA[函数的定义与调用 让函数更好调用 命名参数：当调用一个Kotlin定义的函数时，可以显式地标明一些参数的名称，如果在调用一个函数时，指明了一个参数的名称，在它之后的所有参数都要标明名称． joinToString(collection,separator = "",prefix = "",postfix = "") 默认参数值：在Kotlin中，可以在声明函数的时候，指定参数的默认值，避免创建重载的函数． fun &lt;T&gt; joinToString(collection : Collection&lt;T&gt;, separator: String = ",", prefix : String = ",", postfix : String = ""): String&#123;&#125; 顶层函数与属性：Kotlin中函数不依托于类而存在，可以把函数放到代码文件的顶层，使用时import; 属性也可以放到文件的顶层． 要改变包含Kotlin顶层函数的生成类的名称，需要为这个文件添加@JvmName的注解，将其放于文件开头，包名前面 &gt; @file:JvmName("StringFunctions") &gt; package strings &gt; fun joinToString(...):String&#123;...&#125; &gt; //调用 &gt; import strings.StringFunctions; &gt; 扩展函数和属性 扩展函数：定义在类外部的静态成员函数． 在扩展函数中，可以直接访问被扩展的类的其他属性和方法，但不能访问私有的或者是受保护的成员． 扩展函数不能被重写，扩展函数并不是类的一部分，是声明在类外的，如果父类和子类分别定义一个同名的扩展函数，当函数被调用时，结果由该变量的静态类型所决定． &gt; fun View.showOff() = println("I'm a view") //父类定义扩展函数 &gt; fun Button.showOff() = println("I'm a button") //子类定义同名扩展函数 &gt; &gt; val view : View = Button() &gt; view.showOff() //输出： I'm a view &gt; 如果一个类的成员函数和扩展函数有相同的签名，成员函数往往被优先使用． 扩展属性 var StringBuilder.lastChar:Char get() = get(length - 1) set(value : Char)&#123; this.setCharAt(length - 1,value) &#125; 不能初始化 必须定义getter函数 Java中调用和访问 调用扩展函数 //函数定义在 StringUtil.kt 中 char c = StringUtilKt.lastChar("Java") 访问扩展属性 StringUtilKt.getLastChar("Java") 集合 可变参数：可以传递任意个数的参数 //使用 vararg 进行修饰 fun listOf&lt;T&gt;(vararg values:T) : List&lt;T&gt; &#123;...&#125; ＊为展开运算符，可以解包数组 &gt; val list = listOf(*args) &gt; println(list) &gt; 中缀调用 //声明，使用infix修饰符 infix fun Any.to(other : Any) = Pair(this,other) //调用 1 to "one" var (number, name) = 1 to "one" //解构声明 三重引号 三重引号中的任何字符都不需要进行转义． """(.+)/(.+)\.(.+)""" 局部函数：嵌套函数 class User(val id:Int,val name:String,val address:String) fun saveUser(user:User)&#123; fun validate(value:String,fieldName:String)&#123; if(value.isEmpty())&#123; throw IllegalArgumentException("...") &#125; &#125; validate(user.name,"Name") validate(user.address,"Address") &#125; 局部函数可以访问所在函数中的所有参数和变量 //提取到扩展函数 class User(val id:Int,val name:String,val address:String) fun User.validateBeforeSave()&#123; fun validate(value:String,fieldName:String)&#123; if(value.isEmpty)&#123; throw IllegalArgumentException("...") &#125; &#125; validate(user.name,"Name") validate(user.address,"Address") &#125; fun saveUser(user:User)&#123; user.validateBeforeSave() &#125;]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法-链表]]></title>
    <url>%2F2020%2F08%2F19%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[链表 一. 定义链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。 二. 性质链表通常由一连串节点组成，每个节点包含任意的实例数据和一或两个用来指向上一个/或下一个节点的位置的链接，不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间。 优点 不需要预先知道数据大小 不必须顺序存储，可以充分利用内存空间 插入删除操作简单快速 缺点 增加了结点的指针域，空间开销较数组大 不能随机读取。 三. 类型graph LR a[链表] --> b[单向链表] a --> c[双向链表] a --> e[循环链表] 单向链表 一个单向链表的节点被分成两个部分。第一个部分保存或者显示关于节点的信息，第二个部分存储下一个节点的地址。单向链表只可向一个方向遍历。 public class ListNode &#123; public int val; public ListNode next; public ListNode(int x) &#123; val = x; &#125; &#125; 插入 根据插入位置分为插入头结点，插入中间节点，插入尾节点（例如需要将p结点插入单链表head中） 插入到头结点 直接将p结点的next指向头结点即可,p为新头结点 p.next = head 插入中间结点m后 遍历找到m结点，然后先将p的next指向m的next，再将m的next指向p ListNode tmp = head; while(tmp != null) &#123; if(tmp == m) &#123; p.next = m.next; m.next = p; break; &#125; tmp = tmp.next; &#125; 插入到尾结点 除了尾结点的判断条件，整体流程与插入到中间结点一致 ListNode tmp = head; while(tmp.next != null) &#123; tmp = tmp.next; &#125; tmp.next = p; 删除 与插入一致，删除也分为三种情况：删除头结点，删除中间结点，删除尾结点 删除头结点 将头结点自身设为null即可 ListNode newHead = head.next; head = null; 删除中间结点 只需要将目标结点的前一个结点的next指向目标结点的下一个结点，再进行自身删除即可 ListNode tmp = head; while(tmp.next != null) &#123; if(tmp.next == target) &#123; tmp.next = target.next; target = null; break; &#125; tmp = tmp.next; &#125; 删除尾结点 ListNode tmp = head; while(tmp.next != null) &#123; tmp = tmp.next; &#125; tmp = null; 双向链表 双向链表也叫双链表。双向链表中不仅有指向后一个节点的指针，还有指向前一个节点的指针。这样可以从任何一个节点访问前一个节点，当然也可以访问后一个节点，以至整个链表。 public class DoubleListNode &#123; public int index; public int val; public DoubleListNode prev; public DoubleListNode next; &#125; 插入 : 在值索引i后添加结点node //1.找到索引i的结点 DoubleListNode tmp = head; while (null != tmp.next) &#123; //2.在i后插入结点，先处理后续结点关系 if (tmp.index == i) &#123; node.next = tmp.next; tmp.next.prev = node; node.prev = tmp; tmp.next = node; break; &#125; tmp = tmp.next; &#125; 删除 ：删除索引为i的结点 //1.找到索引i的结点 DoubleListNode tmp = head; while (null != tmp) &#123; if (tmp.index = i) &#123; //2.将目标结点的前一个结点指向目标结点的后一个结点 tmp.prev.next = tmp.next; //3.判断是否为最后一个结点，最后一个结点不需要进行处理 if (tmp.next != null) &#123; tmp.next.prev = tmp.prev; &#125; break; &#125; tmp = tmp.next; &#125; 循环链表 在一个 循环链表中, 首节点和末节点被连接在一起。这种方式在单向和双向链表中皆可实现。(图中以单链表为例) public class CircleList&#123; //头结点 public ListNode head; //尾结点 public ListNode tail; //链表长度 private int length; &#125; 插入 ：循环链表末尾插入，新插入的结点需要指向头结点 public boolean insert(ListNode node) &#123; if (head == null) &#123; //空链表 head = node; tail = node; &#125; else &#123; node.next = head; tail.next = node; tail = node; &#125; length ++; return true; &#125; 删除 : 从循环链表中删除值为i的结点 public ListNode delete(ListNode node) &#123; ListNode tmp = head; //所找结点为头结点 if (node.equals(tmp)) &#123; head = head.next; tail.next = head; length -- ; &#125; else &#123; //遍历找该结点 while (tmp.next != null) &#123; if (node.equals(tmp.next)) &#123; ListNode n = tmp.next.next; tmp.next = n; length --; break; &#125; tmp = tmp.next; &#125; &#125; return tmp; &#125; 四. 常见应用​ 链表用来构建许多其它数据结构，如堆栈，队列和他们的派生。]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin基础]]></title>
    <url>%2F2020%2F08%2F16%2FKotlin%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Kotlin基础知识 函数 函数的基本构成 fun 函数名称 (参数列表): 返回类型 &#123; 函数体 &#125; fun max(a:Int,b:Int):Int&#123; return if(a&gt;b) a else b &#125; 表达式和语句 表达式：有值，并且能作为另一个表达式的一部分使用 语 句：总是包含着它的代码块中的顶层元素，并且没有自己的值 在Java中所有的控制结构都是语句； 在Kotlin中除了循环(for,do和do/while)以外大多数控制结构都是表达式 省略返回值类型 fun max ( a:Int,b:Int) = if(a&gt;b) a else b 如果函数体写在花括号中，则这个函数有代码块体，如果直接返回一个表达式，则它有表达式体 变量 如果指定了初始化器，那么在不指定类型的情况下，编译器会分析初始化器表达式的值，并把它的类型作为变量的类型， fun test():Int=&#123; val xValue = 2.5 val yValue = 3 return xValue + yValue &#125; 如果没有指定初始化器，需要显示地指定它的类型，因为此时编译器无法推断出它的类型。 fun test()&#123; val eValue : Int println("eValue = $eValue") &#125; 可变变量和不可变变量 Val(Value)-不可变引用：使用该关键字声明的变量不能在初始化后再次赋值． 对应JAVA中的final变量 如果编译器确保只有唯一一条语句会被执行，可以根据条件使用不同的值来初始化 val message:String if(canPerformOperation())&#123; message = "Success" &#125;else&#123; message = "Failed" &#125; 虽然val引用自身不可变，但指向的对象是可变的 val language = arrayListOf("Java") language.add("Kotlin") Var(Variable)-可变引用：该关键字声明的变量的值可以改变． 对应JAVA中的普通变量 var变量的类型是不可变的,编译器只会根据初始化器来推断变量的类型，如果需要则必须手动转换或者强制转换 字符串模板声明一个变量后，在变量名称前添加字符$,就可以在字符串字面值中引用该变量． 打印字符串变量 fun main(args:Array&lt;String&gt;)&#123; val name = "Kotlin" printlin("Hello,$name!") &#125; 复杂表达式 fun main(args:Array&lt;String&gt;)&#123; if(args.size &gt; 0)&#123; println("Hello,$&#123;args[0]!&#125;") &#125; &#125; 双引号嵌套 fun main(args:Array&lt;String&gt;)&#123; println("Hello,$&#123;if(args.size &gt; 0 args[0] else "Kotln")&#125;") &#125; 类和属性//Java中的类 public class Person&#123; private String mName; private void setName(String name)&#123; mName = name; &#125; private String getName()&#123; return mName; &#125; &#125; 字段和其访问器的组合为属性 //Kotlin中的类 //Kotlin中属性默认为public Class Person(val name:String) Kotlin中属性默认为public 声明属性时默认生成访问器，只读属性只生成getter,可写属性生成getter和setter//自定义访问器 class Rectangle(val height:Int,val width:Int)&#123; val isSquare:Boolean get()&#123; return height == width &#125; &#125; 枚举类//声明枚举类 enum class Color&#123; RED,ORANGE,YELLOW,GREEN,BLUE,INDIGO,VIOLET &#125; Kotlin中，enum是软关键字,在class前面才有特殊意义，其他地方只是普通名称 和Java一样，枚举不是值的列表，可以给枚举类声明属性和方法 enum class Color ( val r : Int, val g : Int, val b : Int //声明常量属性 ) &#123; RED(255, 0, 0), ORANGE(255, 165, 0); //必须添加分号结束 fun rgb() = (r * 256 + g) * 256 + b //定义方法 &#125; 如果要在枚举类中定义任何方法，就要使用分号把枚举常量列表和方法定义分开。 When表达式fun getWarmth(color:Color) = when(color)&#123; Color.RED,Color.ORANGE,Color.YELLOW -&gt; "warm" Color.GREEN -&gt; "neutral" Color.BLUE,Color.INDIGO,Color.VIOLET -&gt; "cold" &#125; when表达式的实参可以是任何对象 fun mix(c1:Color,c2:Color) = when(setOf(c1,c2))&#123; setOf(Color.RED,Color.YELLOW) -&gt; Color.ORANGE setOf(Color.YELLOW,Color.BLUE) -&gt; Color.GREEN setOf(Color.BLUE,Color.VIOLET) -&gt; Color.INDIGO else -&gt; throw Exception("Dirty Color") &#125; 计算(1+2)+4 //类结构 interface Expr class Num(val value:Int) : Expr class Sum(val left:Expr,val right:Expr) : Expr graph TB; A[Sum] --> B[Sum] A[Sum] --> C["Num(4)"] B[Sum] --> D["Num(1)"] B[Sum] --> E["Num(2)"] fun eval(e:Expr) : Int = when(e)&#123; is Num -&gt; e.value is Sum -&gt; eval(e.right)+eval(e.left) else -&gt; throw IllegalArgumentException("Unknown expression") &#125; While循环 while循环 //当codition为true时执行循环 while(codition)&#123; //循环体 &#125; do-while循环 //循环体第一次无条件执行，此后，当codition为true时才执行 do&#123; //循环体 &#125; while(codition) for循环 kotlin使用区间的概念：［起始值．．结束值］ for(i in 1 until 100 step 2)&#123; &#125; for(i in 100 downTo 1 step 2)&#123; &#125; 迭代map val binaryReps = TreeMap&lt;Char,String&gt;() for(c in 'A'..'F')&#123; val binary = Integer.toBinaryString(c.toInt()) binaryReps[c] = binary &#125; for((letter,binary) in binaryReps)&#123; println("$letter = $binary") &#125; Ktolin中的异常 捕获异常 fun readNumber(reader:BufferedReader) : Int?&#123; try&#123; val line = reader.readLine() return Interger.parseInt(line) &#125;catch(e:NumberFormatException)&#123; return null &#125;finally&#123; reader.close() &#125; &#125; fun readNumber(reader:BufferedReader)&#123; val number = try&#123; Integer.parseInt(reader.readLine()) &#125;catch(e:NumberFormatException)&#123; null &#125; println(number) &#125; try结构也可以作为表达式 抛出异常 val percentage = if(number in 0..100)&#123; number &#125;else&#123; throw IllegalArgumentException("....") &#125; 与Java中不同的是，kotlin中throw结构是一个表达式．]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法-二叉树]]></title>
    <url>%2F2020%2F08%2F09%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[二叉树 一. 定义每个节点最多只有两个分支（即不存在分支度大于 2 的节点）的树结构。左子树和右子树是有顺序的，不能任意颠倒。 二. 性质 非空的二叉树，若树叶总数为n0,分支度为n2,则$n0 = n2 + 1$ 三. 类型graph LR D[二叉树] --> G[完全二叉树] D --> H[平衡二叉树] D --> I[排序二叉树] G --> J[满二叉树] 满二叉树(Full Binary Tree)：一棵深度为k，且有2^k^ - 1个节点的二叉树。 完全二叉树(Complete Tree)：除最后一层外，如其余层都是满的，并且最后一层是满的或者是在右边缺少连续若干节点的二叉树 具有n个节点的完全二叉树的深度为$\log_2{n} + 1$ 深度为k的完全二叉树，至少有2^k-1^个节点，至多有2^k^ -1个节点 平衡二叉树 排序二叉树 四. 存储结构 顺序存储表示 二叉树可以用数组或链接串列来存储，若是满二叉树就能紧凑排列而不浪费空间。如果某个节点的索引为i，（假设根节点的索引为0）则在它左子节点的索引会是$2i + 1$，以及右子节点会是$2i + 2$；而它的父节点（如果有）索引则为$ \lfloor \frac{i-1}{2} \rfloor$这种方法更有利于紧凑存储和更好的访问的局部性，特别是在前序遍历中。然而，它需要连续的存储空间，这样在存储高度为h的n个节点所组成的一般树时，将浪费很多空间。在最糟糕的情况下，如果深度为h的二叉树其每个节点都只有右孩子，则该存储结构需要占用2^h^ - 1的空间，实际上却有h个节点，浪费了不少空间，是顺序存储结构的一大缺点。 链表存储表示 二叉树通常用树结点结构来存储。有时也包含指向唯一的父节点的指针。如果一个结点的子结点个数小于2，一些子结点指针可能为空值，或者为特殊的哨兵结点。 使用链表能避免顺序存储浪费空间的问题，算法和结构相对简单，但使用二叉链表，由于缺乏父链的指引，在找回父节点时需要重新扫描树得知父节点的节点地址。 public class TreeNode &#123; public int val; public TreeNode left; public TreeNode right; public TreeNode(int x) &#123; val = x; &#125; &#125; 五. 遍历方法 前序遍历：先访问根节点，再访问根的左节点和右节点 //递归方式 public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); treeNodeTraversal(list, root); return list; &#125; private void treeNodeTraversal(List&lt;Integer&gt; list, TreeNode root)&#123; if (root == null) &#123; return; &#125;; //访问根节点 list.add(root.val); //遍历左子树 treeNodeTraversal(list, root.left, 0); //遍历右子树 treeNodeTraversal(list, root.right, 0); &#125; //迭代方式 public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if (root == null) &#123; return list; &#125; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); //将根节点压入栈中 stack.push(root); while (!stack.isEmpty()) &#123; TreeNode node = stack.pop(); //访问根节点 list.add(node.val); //由于栈是先入后出，所以右子节点先入栈，左子节点后入栈 if (node.right != null) &#123; stack.push(node.right); &#125; if (node.left != null) &#123; stack.push(node.left); &#125; &#125; return list; &#125; 中序遍历：先遍历左子节点，再遍历根节点，最后遍历右子节点 //递归方式 public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); treeNodeTraversal(list, root); return list; &#125; private void treeNodeTraversal(List&lt;Integer&gt; list, TreeNode root)&#123; if (root == null) &#123; return; &#125;; //先遍历左子节点 treeNodeTraversal(list, root.left, 0); //访问 list.add(root.val); treeNodeTraversal(list, root.right, 0); &#125; //非递归方式 //先将左节点全部入栈，遍历到叶子节点后一层层向上遍历根节点和右节点 public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if (root == null) &#123; return list; &#125; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode node = root; //判断条件 1. 栈为空，即遍历完毕或开始遍历； // 2. node不为空则开始遍历 while (!stack.isEmpty() || node != null) &#123; if (node != null) &#123; //将左节点入栈 stack.push(node); node = node.left; &#125; else &#123; //左节点不存在，则访问该节点，再遍历右节点 node = stack.pop(); list.add(node.val); node = node.right; &#125; &#125; return list; &#125; 后序遍历：先遍历左子节点，再遍历右子节点，最后遍历根节点 //递归方式 public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); treeNodeTraversal(list, root); return list; &#125; private void treeNodeTraversal(List&lt;Integer&gt; list, TreeNode root)&#123; if (root == null) &#123; return; &#125;; //遍历左子树 treeNodeTraversal(list, root.left, 0); //遍历右子树 treeNodeTraversal(list, root.right, 0); //访问根节点 list.add(root.val); &#125; //非递归方式 //前序遍历结果为“根左右”，如果修改遍历次序则为“根右左”，在进行倒序则为后序遍历“左右根” public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if (root == null) &#123; return list; &#125; //遍历栈,遍历树节点 Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); //记录“根右左”遍历的值 Stack&lt;Integer&gt; temp = new Stack&lt;&gt;(); stack.push(root); //根据前序遍历修改遍历次序，使结果输出"根右左" while (!stack.isEmpty()) &#123; TreeNode node = stack.pop(); temp.push(node.val); if (node.left != null) &#123; stack.push(node.left); &#125; if (node.right != null) &#123; stack.push(node.right); &#125; &#125; //将“根右左”的结果倒序输出为"左右根" while (!temp.isEmpty()) &#123; list.add(temp.pop()); &#125; return list; &#125; 层次遍历：每一层按照从左到右的顺序打印节点 //非递归方式 //使用一个队列，依次将节点子节点入队列，再依次出队列即可 public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); if (root == null) &#123; return result; &#125; //遍历队列 Queue&lt;TreeNode&gt; queue = new ArrayDeque&lt;&gt;(); //先将根节点入队列 queue.add(root); while ( !queue.isEmpty()) &#123; //每层的数据放在一个数组中 List&lt;Integer&gt; temp = new ArrayList&lt;&gt;(); //当前队列里元素的数量就是当前层数的总节点数量 int size = queue.size(); //使用一个循环遍历当前层数所有的节点 for (int i = 0 ; i &lt; size ; i ++) &#123; TreeNode node = queue.poll(); if (node !=null) &#123; //访问当前节点，并将其子节点入队列 temp.add(node.val); if (node.left != null) &#123; queue.add(node.left); &#125; if (node.right != null) &#123; queue.add(node.right); &#125; &#125; &#125; //一层遍历完成，将数据添加到结果中 result.add(temp); &#125; return result; &#125; //递归方式 //增加level表示层级，根据节点的层级，将节点的数据添加到想要数组中 public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); if (root == null) &#123; return result; &#125; //加入根节点，开始递归遍历 levelOrderDfs(1, root, result); return result; &#125; private void levelOrderDfs(int level, TreeNode node, List&lt;List&lt;Integer&gt;&gt; lists) &#123; //当前层级无相应数组时，添加一个空数组 if (lists.size() &lt; level) &#123; lists.add(new ArrayList&lt;&gt;()); &#125; //访问节点值，并将其添加到对应层级的数组里 lists.get(level - 1).add(node.val); //层级递增，遍历下一层，递归遍历左子节点和右子节点 if (node.left != null) &#123; levelOrderDfs(level + 1, node.left, lists); &#125; if (node.right != null) &#123; levelOrderDfs(level + 1, node.right, lists); &#125; &#125;]]></content>
      <categories>
        <category>树</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法-树]]></title>
    <url>%2F2020%2F08%2F09%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%A0%91%2F</url>
    <content type="text"><![CDATA[树 一. 定义树是一种 抽象数据类型(ADT) 或是实现这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由 n 个有限节点组成的一个具有层次关系的集合。 抽象数据类型(Abstract Data Type，ADT),是计算机科学中具有类似行为的特定类别的数据结构的数学模型 二. 特点 每个节点只有有限个子节点或无子节点 没有父节点的节点称为根节点 每一个非根节点有且只有一个父节点 树里面没有环路 三. 术语 节点的度：一个节点含有的子树的个数称为该节点的度 树的度：一棵树中，最大的节点度称为树的度 叶节点或终端节点：度为零的节点 非终端节点或分支节点：度不为零的节点 父亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点 孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点 兄弟节点：具有相同父节点的节点互称为兄弟节点 节点的层次：从根开始定义起，根为第 1 层，根的子节点为第 2 层，以此类推 深度：对于任意节点 n,n 的深度为从根到 n 的唯一路径长，根的深度为 0 高度：对于任意节点 n,n 的高度为从 n 到一片树叶的最长路径长，所有树叶的高度为 0 堂兄弟节点：父节点在同一层的节点互为堂兄弟 节点的祖先：从根到该节点所经分支上的所有节点 子孙：以某节点为根的子树中任一节点都称为该节点的子孙 森林：由 m（m&gt;=0）棵互不相交的树的集合称为森林 四. 树的分类graph LR A[树] --> B[无序树] A --> C[有序树] C --> D[二叉树] C --> E[霍夫曼树] C --> F[B树] D --> G[完全二叉树] D --> H[平衡二叉树] D --> I[排序二叉树] G --> J[满二叉树] 无序树：树中任意节点的子节点之间没有顺序关系 有序树：树中任意节点的子节点之间有顺序关系 二叉树：每个节点最多含有两个子树的树 霍夫曼树：带权路径最短的二叉树称为哈夫曼树或最优二叉树 B 树：一种对读写操作进行优化的自平衡的二叉查找树，能够保持数据有序，拥有多于两个子树 五. 树的遍历graph LR a[树的遍历] --> b b[深度优先遍历] --> c[前序遍历] b --> e[中序遍历] b --> f[后序遍历] a --> d[广度优先遍历] 深度优先遍历：先访问子节点，再访问父节点，最后是第二个子节点 前序遍历：先访问根，然后访问子树的遍历方式 前序遍历：F, B, A, D, C, E, G, I, H. 中序遍历：先访问左（右）子树，然后访问根，最后访问右（左）子树的遍历方式 中序遍历：A, B, C, D, E, F, G, H, I. 后序遍历:先访问子树，然后访问根的遍历方式 后序遍历：A, C, E, D, B, H, I, G, F. 广度优先遍历层次遍历：F, B, G, A, D, I, C, E, H.]]></content>
      <categories>
        <category>树</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发艺术探索-Android中的线程和线程池]]></title>
    <url>%2F2020%2F08%2F04%2FAndroid%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-Android%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[Android中的线程和线程池 在操作系统中，线程是调度的最小单元，同时线程不能无限制的产生，线程的创建和销毁都需要开销，通过线程池可以避免因为频繁创建和销毁线程而导致的开销。 一. 主线程和子线程 主线程:指进程所拥有的线程,主要处理和界面相关的事情,也称UI线程. 为了避免界面卡顿,主线程中不能执行耗时的任务,会引起ANR 子线程:也称工作线程,除主线程以外的线程都是子线程.主要执行耗时任务，如网络请求，I/O操作等 二. Android中的线程形态 AsyncTask 内部封装了Thread和Handler,在线程池中执行后台任务,把执行进度和结果返回给主线程. AsyncTask不适合执行特别耗时的后台任务 public abstract class AsyncTask&lt;Params,Progress,Result&gt;&#123; //AsyncTask参数 //Params:表示参数的类型 //Progress:后台任务的执行进度的类型 //Result:任务的返回结果的类型 /** * 在主线程中执行,异步任务执行&#123;#doInBackground&#125;之前会被调用 **/ @MainThread protected void onPreExecute() &#123; &#125; /** * 用于执行异步任务,在此方法中可以通过publishProgress方法更新进度 **/ @WorkerThread protected abstract Result doInBackground(Params... params); /** * 在主线程中执行,用于更新任务进度 **/ @MainThread protected void onProgressUpdate(Progress... values) &#123; &#125; /** * 在主线程中执行,在异步任务执行之后调用,用于返回结果 **/ @MainThread protected void onPostExecute(Result result) &#123; &#125; /** * 执行在主线程,异步任务取消时调用,默认实现中直接调用了onCancelled()方法,所以 * 忽略了结果值,注意在覆写时不要使用super.onCancelled(result) **/ @MainThread protected void onCancelled(Result result) &#123; onCancelled(); &#125; &#125; AsyncTask使用限制： AsyncTask的类必须在主线程加载 AsyncTask的对象必须在主线程创建 execute方法必须在UI线程调用 不要在程序中直接调用onPreExecute, onPostExecute, doInBackground, onProgressUpdate 一个AsyncTask对象只能执行一次，即只能调用一次execute方法 工作原理: graph TB A["excute(Params... params)"] --> B["executeOnExecutor(sDefaultExecutor,param)"] B --> C["SERIAL_EXECUTOR#execute(Runnable r)"] C --> D["SERIAL_EXECUTOR#scheduleNext()"] D --> E["THREAD_POOL_EXECUTOR#execute(Runnable r)"] AsyncTask中有两个线程池(SERIAL_EXECUTOR,THREAD_POOL_EXECUTOR)和一个线程Handler(InternalHandler) SERIAL_EXECUTOR:内部实现的SerialExecutor,用于任务的排队,接收到传递过来的FutureTask对象后将其插入到任务队列中,如果此时没有任务在执行则调用scheduleNext方法执行下一个任务.可以看出AsyncTask是串行执行的 THREAD_POOL_EXECUTOR:用于执行任务 InternalHandler:用于子线程切换到主线程 HandlerThread HandlerThread继承自Thread,其内部构建了一个消息处理循环 用法 //创建HandlerThread实例 HandlerThread mMsgThread = new HandlerThread("msg-handler"); //启动 mMsgThread.start(); //关联Handler处理消息 Handler mMsgHandler = new Handler(mMsgThread.getLooper())&#123; @Override public void handleMessage(Message msg)&#123; //消息处理 &#125; &#125; IntentService IntentService是继承了Service的一个抽象类.可用于执行后台耗时的任务,当任务执行完成后自动停止. 工作原理: //onCreate //创建一个HandlerThread,并通过其再创建mServiceHandler @Override public void onCreate() &#123; super.onCreate(); HandlerThread thread = new HandlerThread("IntentService[" + mName + "]"); thread.start(); mServiceLooper = thread.getLooper(); mServiceHandler = new ServiceHandler(mServiceLooper); &#125; //onStart中通过mServiceHandler发送消息,然后在ServiceHandler中调用onHandleIntent //方法处理消息,并随后调用Service#stopSelt(startId)停止服务 private final class ServiceHandler extends Handler &#123; public ServiceHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message msg) &#123; onHandleIntent((Intent)msg.obj); stopSelf(msg.arg1); &#125; &#125; Service中的stopSelf()和stopSelf(int startId)都能停止服务,但stopSelf()会立刻停止服务,而stopSelf(int startId)会等待所有消息都处理完成后停止服务. onHandleIntent方法需要在子类中实现,根据Intent参数区分不同的任务并执行. onHandleIntent中的任务是排队执行的,执行顺序为发起请求的顺序. 三. Android中的线程池 线程池的优点 线程复用,避免线程重复创建和销毁带来的开销 有效控制线程池的最大并发数,避免大量的线程之间因资源抢占而阻塞 统一管理线程 ThreadPoolExecutor //构造方法 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) 构造参数 corePoolSize:线程池的核心线程数,默认会一直存活. maximumPoolSize:线程池能容纳的最大线程数,达到这个数值后,后续任务会被阻塞 keepAliveTime:非核心线程闲置时的超时时长,超过这个时间后会被回收. 如果设置allowCoreThreadTimeOut为True,可作用于核心线程 unit:keepAliveTime参数时间单位 workQueue:线程池中的任务队列,通过线程池的execute方法提交的Runnable对象会存储在该参数中 threadFactory:线程工厂,为线程池提供创建新线程的功能 handler:当线程池无法执行新任务时,ThreadPoolExecutor会调用该handler的rejectedExecution方法,默认直接抛出RejectedExecutionException 执行规则 如果线程池中的线程数未达到核心线程数,则直接启动核心线程执行任务 如果线程数量大于或等于核心线程数,任务会被插入到任务队列中排队等待 如果线程数量大于或等于核心线程数且任务队列也已满,此时如果线程数量未达到线程能容纳的最大值,则立刻启动一个非核心线程执行任务;如果达到了最大值则拒绝执行任务调用rejectedExecution方法 线程池的分类 FixedThreadPool public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt; ()); &#125; 通过Executors的newFixedThreadPool方法创建.一种线程数量固定的线程池,只有核心线程,没有超时机制和任务队列大小限制. CachedThreadPool public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;()); &#125; 通过Executors的newCachedThreadPool方法来创建.一种线程数量不定的线程池,只有非核心线程,且最大线程数为Interger.MAX_VALUE.线程池中的空闲线程都有超时机制,超时时间为60s ScheduledThreadPool public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123; return new ScheduledThreadPoolExecutor(corePoolSize); &#125; public ScheduledThreadPoolExecutor(int corePoolSize) &#123; super(corePoolSize, Integer.MAX_VALUE, DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS, new DelayedWorkQueue()); &#125; 通过Executors的newSingleThreadScheduledExecutor创建.核心线程数固定,非核心线程数最大为Interger.MAX_VALUE,非核心线程闲置时会被回收.用于执行定时任务和具有固定周期的重复任务. SingleThreadExecutor public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;())); &#125; 通过Executors的newSingleThreadExecutor方法创建.线程池中只有一个核心线程,确保所有的任务都在同一个线程中按顺序执行.]]></content>
      <categories>
        <category>Android开发艺术探索</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发艺术探索-Android的消息机制]]></title>
    <url>%2F2020%2F08%2F03%2FAndroid%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-Android%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Android的消息机制 Android的消息机制概述Android的消息机制主要指Handler的运行机制以及Handler所附带的MessageQueue和Looper的工作过程，Handler的主要作用是将一个任务切换到某个指定的线程中去执行。Handler创建时会采用当前线程的Looper来构建内部的消息循环系统，如果没有Looper会报错。线程中默认是没有Looper的，主线程（UI线程，即ActivityThread）被创建时会初始化Looper，所以主线程默认可以使用Handler Android的消息机制分析 ThreadLocal的工作原理 ThreadLocal:是一个线程内部的数据存储类，可以通过它在指定的线程存储和获取数据（其他线程无法获取） //定义 public class ThreadLocal&lt;T&gt; //set方法 public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); &#125; //get方法 public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings("unchecked") T result = (T)e.value; return result; &#125; &#125; return setInitialValue(); &#125; 消息队列的工作原理 MessageQueue主要包含两个操作：插入和读取，对应enqueueMessage和next，MessageQueue是通过一个单链表的数据结构来维护消息列表的，不是队列。 enqueueMessage方法的主要操作是单链表的插入操作 next方法的主要操作是构建一个无限循环，有消息时返回这条消息并移除；无消息时则进行阻塞。 Looper的工作原理 Looper是消息循环，会不停的查看MessageQueue中是否有新消息，有则立即处理；无则进行阻塞。 重要方法： prepare : 为当前线程创建一个Looper prepareMainLooper : ActivityThread创建Looper使用 getMainLooper : 获取主线程的Looper quit : 直接退出Looper quitSafely : 设定退出标记，在把消息队列中已有消息处理完后安全退出 loop : 调用MessageQueue的next方法来获取新消息 Handler的工作原理 Handler的工作主要包含消息的发送和接收过程。 发送消息的过程为向消息队列中插入一条消息，随后MessageQueue返回消息给Looper，Looper在交由Handler处理，即调用Handler的dispatchMessage方法 主线程的消息循环主线程即ActivityThread,其入口方法为main，在main方法中通过Looper.prepareMainLooper来创建主线程的Looper以及MessageQueue，并通过Looper.loop方法来开启主线程的消息循环 public static void main(String[] args) &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "ActivityThreadMain"); // Install selective syscall interception AndroidOs.install(); // CloseGuard defaults to true and can be quite spammy. We // disable it here, but selectively enable it later (via // StrictMode) on debug builds, but using DropBox, not logs. CloseGuard.setEnabled(false); Environment.initForCurrentUser(); // Make sure TrustedCertificateStore looks in the right place for CA certificates final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId()); TrustedCertificateStore.setDefaultUserDirectory(configDir); Process.setArgV0("&lt;pre-initialized&gt;"); Looper.prepareMainLooper(); // Find the value for &#123;@link #PROC_START_SEQ_IDENT&#125; if provided on the command line. // It will be in the format "seq=114" long startSeq = 0; if (args != null) &#123; for (int i = args.length - 1; i &gt;= 0; --i) &#123; if (args[i] != null &amp;&amp; args[i].startsWith(PROC_START_SEQ_IDENT)) &#123; startSeq = Long.parseLong( args[i].substring(PROC_START_SEQ_IDENT.length())); &#125; &#125; &#125; ActivityThread thread = new ActivityThread(); thread.attach(false, startSeq); if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; if (false) &#123; Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, "ActivityThread")); &#125; // End of event ActivityThreadMain. Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); Looper.loop(); throw new RuntimeException("Main thread loop unexpectedly exited"); &#125; ActivityThread通过ActivityThread.H来和消息队列进行交互。具体流程为：ActivityThread通过ApplicationThread和ActivityManagerService进行进程间通信，AMS以进程间通信的方式完成ActivityTread的请求后会回调ApplicationThread中的Binder方法，然后ApplicationThread会向H发送消息，H收到消息后将ApplicationThread中的逻辑切换到ActivityThread中去执行，即切换到主线程执行。]]></content>
      <categories>
        <category>Android开发艺术探索</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发艺术探索-四大组件的工作过程]]></title>
    <url>%2F2020%2F08%2F02%2FAndroid%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[第九章 四大组件的工作过程 四大组件的运行状态 Activity 展示一个界面并和用户进行交互．由Intent触发启动 ，分为显示Intent和隐式Intent，显示Intent可以明确指向一个Activity组件，隐式Intent可以指向一个或多个Activity组件 Service 一种计算型组件，用于在后台执行一系列计算．与Activity只有一种启动状态不同，Service有两种状态：启动状态（startService）和绑定状态（bindService）．Service是运行在主线程中的． BroadcastReceiver 一种消息型组件，用于在不同的组件，不同的应用之间传递消息． 广播有两种注册方式： 静态注册：在AndroidManifest中注册广播，在应用安装时被系统解析，无须应用启动就可以收到相应的广播． 动态注册：通过Context.registerReceiver()和Context.unRegisterReceiver()来注册和注销广播，需要应用启动才能注册并接收广播． ContentProvider 一种数据共享型组件，用于向其它组件和应用共享数据． Activity的工作过程 显示调用，启动Activity Intent intent = new Intent(this, TestActivity.Class); startActivity(intent); 启动流程 sequenceDiagram Activity ->> Activity : startActvity Activity ->> Activity : startActivityForResult Activity ->> Instrumentation : execStartActivity Instrumentation ->> ActivityManagerService : ActivityManagerNative.getDefault().startActivity ActivityManagerService ->> ActivityManagerService : startActivity ActivityManagerService ->> ActivityStackSupervisor : startActivityLocked ActivityStackSupervisor ->> ActivityStack : resumeTopActivitiesLocked ActivityStack ->> ActivityStackSupervisor : startSpecificActivityLocked ActivityStackSupervisor ->> ActivityStackSupervisor : realStartActivityLocked ActivityStackSupervisor ->> ApplicationThread : sceduleLaunchActivity ApplicationThread ->> ActivityThread : handleLaunchActivity ActivityThread ->> ActivityThread : performLaunchActivity performLaunchActivity方法具体内容： 从ActivityClientRecord中获取待启动的Activity的组件信息 通过Instrumentation的newActivity方法使用类加载器创建Activity对象 通过LoadedApk的makeApplication方法来尝试创建Application对象 创建ContextImpl对象并通过Activity的attach方法完成h重要数据初始化 调用Activity的onCreate方法 Service的工作过程 启动状态：主要用于执行后台计算 //启动Service Intent intentService = new Intent(this,TmpService.class); startService(intentService); 绑定状态：用于其他组件和Service的交互 //绑定Service Intent intentService = new Intent(this,TmpService.class); bindService(intentService,mServiceConn,BIND_AUTO_CREATE); 两种状态可以共存，一个Service既可以处于启动状态，也可以同时处于绑定状态 Service的启动过程 sequenceDiagram Activity ->> ContextWrapper : startService ContextWrapper ->> ContextImpl : startService ContextImpl ->> ContextImpl : startServiceCommon ContextImpl ->> ActivityManagerService : startService ActivityManagerService ->> ActiveServices : startServiceLocked ActiveServices ->> ActiveServices : startServiceInnerLocked ActiveServices ->> ActiveServices : bringUpServiceLocked ActiveServices ->> ApplicationThread : realStartServiceLocked ApplicationThread ->> ApplicationThread : scheduleCreateService ApplicationThread ->> ActivityThread : handleCreateService handleCreateService方法具体内容： 通过类加载器创建Service的实例 创建Application对象并调用其onCreate 创建ContextImpl对象并通过Service的attach方法建立联系 调用Service的onCreate方法并将Service对象存到ActivityThread的列表中 Service的绑定过程 sequenceDiagram ContextWrapper ->> ContextImpl : bindService ContextImpl ->> ContextImpl : bindServiceCommon ContextImpl ->> LoadedApk : getServiceDispatcher LoadedApk -->> ContextImpl : ServiceDispatcher.InnerConnection ContextImpl ->> ActivityManagerService : bindService ActivityManagerService ->> ActiveServices : bindServiceLocked ActiveServices ->> ActiveServices : bringUpServiceLocked ActiveServices ->> ApplicationThread : realStartServiceLocked ApplicationThread ->> ActivityManagerService : handleBindService ActivityManagerService ->> ActivityManagerService : publishService ActivityManagerService ->> ActiveServices : publishServiceLocked BroadcastReceiver的工作过程 广播的注册过程 静态注册 静态注册的广播在应用安装时由PackageManagerService来完成整个注册过程(其它三大组件亦是如此) 动态注册 sequenceDiagram ContextWrapper ->> ContextImpl : registerReceiver ContextImpl ->> ContextImpl : registerReceiverInternal ContextImpl ->> LoadedApk : getReceiverDispatcher LoadedApk -->> ContextImpl : IIntentReceiver ContextImpl ->> ActivityManagerService : registerReceiver 广播的发送和接收过程 广播的发送过程 sequenceDiagram ContextWrapper ->> ContextImpl : sendBroadcast ContextImpl ->> ActivityManagerService : broadcastIntent ActivityManagerService ->> ActivityManagerService : broadcastIntentLocked ActivityManagerService ->> ActivityManagerService : scheduleBroadcastsLocked ActivityManagerService ->> ActivityManagerService : processNextBroadcast ActivityManagerService ->> ActivityManagerService : performReceiveLocked ActivityManagerService ->> ApplicationThread : scheduleRegisteredReceiver ApplicationThread ->> InnerReceiver : performReceiver InnerReceiver ->> LoadedApk.ReceiverDispatcher : performReceive 应用处于停止状态的两种情形： 应用安装后未运行 应用被手动或其他应用强制停止 ContentProvider的工作过程ContentProvider是一种内容共享型组件，它通过Binder向其他组件乃至其他应用提供数据。当ContentProvider所在的进程启动时，ContentProvider会同时启动并被发布到AMS中。这时候ContentProvider的onCreate要先于Application的onCreate而执行 ContentProvider启动后，外界可以提供它所提供的增删改查四个接口来操作数据源，这四个方法都是通过Binder来调用的，外界无法直接访问ContentProvider，只能通过ActivityManagerService根据Uri来获取对应的ContentProvider的Binder接口IContentProvider，再通过IContentProvider访问ContentProvider中的数据源 ContentProvider的启动过程(以query为例) sequenceDiagram ActivityThread ->> ActivityManagerService : startProcessLocked ActivityManagerService ->> ActivityThread : main ActivityThread ->> ActivityThread : attach ActivityThread ->> ActivityManagerService : attachApplication ActivityManagerService ->> ActivityManagerService : attachApplicationLocked ActivityManagerService ->> ApplicationThread : bindApplication ApplicationThread ->> ActivityThread : handleBindApplication handleBindApplication具体内容： 创建ContextImpl和Instrumentation 创建Application对象 启动当前进程的ContentProvider并调用其onCreatef方法 调用Application的onCreate方法]]></content>
      <categories>
        <category>Android开发艺术探索</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发艺术探索-理解Window和WindowManager]]></title>
    <url>%2F2020%2F07%2F26%2FAndroid%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%90%86%E8%A7%A3Window%E5%92%8CWindowManager%2F</url>
    <content type="text"><![CDATA[理解Window和WindowManager Window表示一个窗口的概念，是一个抽象类，它的具体实现是PhoneWindow。创建一个Window需要通过WindowManage来完成，WindowManager是外界访问Window的入口，Window的具体实现在WindowManagerService中，WindowManager和WindwManagerService的交互是一个IPC过程。Android中所有的视图都是通过Window来呈现的，Window是View的直接管理者。 1. Window和WindowManager​ WindowManager常用的有三个方法：添加View, 更新View, 删除View //添加View mButton = new Button(this); mLayoutParams = new WindowManager.LayoutParams(....); mLayoutParams.flags = LayoutParams.FLAG_NOT_TOUCH_MODAL...; mLayoutParams.gravity = Gravity.LEFT; mLayoutParams.x = 100; mLayoutParams.y = 300; mWindowManager.addView(mButton, mLayoutParams); flags参数表示Window的属性： FLAG_NOT_FOCUSABLE:Window不需要获取焦点，也不需要接收各种输入事件 FLAG_NOT_TOUCH_MODAL: 系统会将当前Window区域以外的单击事件传递给底层的Window,区域内View处理FLAG_SHOW_WHEN_LOCKED: 可以让Window显示在锁屏的界面上 Window是分层的，每个Window都有对应的z-ordered，层级大的会覆盖在层级小的上面。 type参数表示Window的类型，Window有三种类型，分别为 应用Window : 对应着一个Activity.层级范围是==1~99== 子Window : 不能单独存在，需要附属在特定的父Window中，比如dialog等，层级范围是==1000~1999== 系统Window ：需要声明权限才能创建的Window，比如Toast和系统状态栏，层级范围是==2000~2999== 2. Window的内部机制​ 每个Window都对应着一个View和一个ViewRootImpl,Window和View通过ViewRootImpl来建立联系。 Window的添加过程 sequenceDiagram Actor ->>+ Window : addView Window ->>+ WindowManager : addView WindowManager ->>+ WindowManagerImpl : addView WindowManagerImpl ->>+ WindowManagerGlobal : addView WindowManagerGlobal ->> WindowManagerGlobal : 检查参数是否合法 WindowManagerGlobal ->> WindowManagerGlobal : 创建ViewRootImpl,添加View列表 WindowManagerGlobal ->> ViewRootImpl : 更新界面 ViewRootImpl ->> WindowSession : 添加Window WindowSession ->> WindowManagerService : 添加Window Window的删除过程 sequenceDiagram Window... ->> WindowManagerImpl :removeView WindowManagerImpl ->> WindowManagerImpl : 查找待删除的View索引 WindowManagerImpl ->> WindowManagerImpl : 调用removeViewLocked完成删除 真正删除的逻辑在dispatchDetachedFromWindow方法中实现 垃圾回收 通过Session的remove方法删除Window 调用View的dispatchDetachedFromWindow方法 调用WindowManagerGlobal的doRemoveView方法刷新数据 Window的更新过程 更新逻辑在WindowManagerGlobal的updateViewLayout中 更新View的LayoutParams并替换掉原有的 更新ViewRootImpl中的LayoutParams 3. Window的创建过程 Activity的Window创建过程 sequenceDiagram Actor ->> ActivityThread : startActivity ActivityThread ->> ActivityThread : performLaunchActivity ActivityThread ->> PolicyManager : attach PolicyManager ->> PolicyManager : makeNewWindow PolicyManager ->> Policy : makeNewWindow Activity将具体实现交给了Window，所以其逻辑在PhoneWindow中,大致步骤如下： 如果没有DecorView，就创建它 将View添加到DecorView的mContentParent中 回调Activity的onContentChanged方法通知视图改变 调用Activity的makeVisible方法，完成DecorView的添加和显示 Dialog的Window创建过程 创建Window 初始化DecorView并将Dialog的视图添加到DecorView中 将DecorView添加到Window中并显示 普通的Dialog必须采用Activity的Context，否则会报缺失token的错误，应用token一般只有Activity拥有，但系统Window可以不需要token Toast的Window创建过程 在Toast内部有两类IPC过程，第一类是Toast访问NotificationManagerService,第二类是NotificationManagerService回调Toast中的TN接口。Toast属于系统Window。 sequenceDiagram Toast ->> NotificationManagerService : show NotificationManagerService ->> NotificationManagerService : enqueueToast NotificationManagerService ->> NotificationManagerService : showNextToastoLocked NotificationManagerService ->>NotificationManagerService : scheduleTimeoutLocked]]></content>
      <categories>
        <category>Android开发艺术探索</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发艺术探索-Android动画深入分析]]></title>
    <url>%2F2020%2F07%2F22%2FAndroid%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-Android%E5%8A%A8%E7%94%BB%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Android动画深入分析 1. View动画​ View动画的作用对象是View,支持平移动画,缩放动画,旋转动画,透明度动画四种动画效果 名称 标签 子类 效果 平移动画 &lt;translate&#62; TransateAnimation 移动View 缩放动画 &lt;scale&#62; ScaleAnimation 放大或缩小View 旋转动画 &lt;rotate&#62; RotateAnimation 旋转View 透明度动画 &lt;alpha&#62; AlphaAnimation 改变View透明度 1.使用步骤 在res/anim/路径下创建动画的xml文件 &lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;set xmlns:android="http://scemas.android.com/apk/res/android" android:fillAfter="true" android:zAdjustment="normal" &gt; &lt;rotate android:duration="400" android:fromDegress="0" android:toDegress="90" /&gt; &lt;/set&gt; 在代码中调用 Animation animation = AnimationUtils.loadAnimation(this, R.anim.animation_file); mButton.startAnimation(animation) 也可直接在代码中进行设置和调用 AlphaAnimation alphaAnim = new AlphaAnimation(0, 1); alphaAnim.setDuration(300); mButton.startAnimation(animation) 2.自定义View动画 继承Animation 重写initialize和applyTransformation方法 initialize : 初始化 applyTransformation : 进行相应的矩阵变换 2. 帧动画​ 帧动画是顺序播放一组预先定义好的图片。 1. 使用步骤 通过XML定义AnimationDrawable &lt;!-- res/drawable/frame_anim.xml --&gt; &lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;animation-list xmlns:android="http://scemas.android.com/apk/res/android" android:oneshot="false"&gt; &lt;item andrid:drawable="@drawable/image1" android:duration="500" /&gt; &lt;item andrid:drawable="@drawable/image2" android:duration="500" /&gt; &lt;item andrid:drawable="@drawable/image3" android:duration="500" /&gt; &lt;/animation-list&gt; 代码中调用 mButton.setBackroundResource(R.drawable.frame_anim); AnimationDrawable drawable = (AnimationDrawable) mButton.getBackground(); drawable.start(); 3. View动画的特殊使用场景 LayoutAnimation LayoutAnimation作用于ViewGroup,为ViewGroup指定一个动画，子元素都会具有该动画效果 Activity的切换效果 主要用到overridePendingTransition(int enterAnim, int exitAnim)方法，这个方法必须在startActivity或者finish方法之后调用才能生效 enterAnim ： Activity被打开时的动画资源 exitAnim ： Activity被暂停时的动画资源 4. 属性动画​ 属性动画可以对任意对象的属性进行动画而不仅仅是View,动画的默认时间间隔是300ms,默认帧率是10ms/帧，其可以达到的效果是：在一个时间间隔内完成对象从一个属性值到另一个属性值的改变。 插值器(TimeInterpolator)：根据时间流逝的百分比来计算当前属性值改变的百分比 估值器(TypeEvaluator)：根据当前属性改变的百分比来计算改变后的属性值 属性动画的监听器： public static interface AnimatorListener&#123; void onAnimationStart(Animator animation); void onAnimationEnd(Animator animation); void onAnimationCancel(Animator animation); void onAnimationRepeat(Animator animation); &#125; 属性动画的工作原理：]]></content>
      <categories>
        <category>Android开发艺术探索</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发艺术探索-理解RemoteViews]]></title>
    <url>%2F2020%2F07%2F19%2FAndroid%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%90%86%E8%A7%A3RemoteViews%2F</url>
    <content type="text"><![CDATA[理解RemoteViews1. RemoteViews的应用RemoteViews在实际开发中主要用在通知栏和桌面小部件的开发中。通知栏主要通过NotificationManager的notify方法实现，桌面小部件则通过AppWidgetProvider实现。这两个的界面都运行在系统的SystemServer进程中，无法直接更新View. 1.RemoteViews在通知栏上的应用 使用系统默认样式 // Build the notification and add the action. Notification newMessageNotification = new Notification.Builder(context, CHANNEL_ID) .setSmallIcon(R.drawable.ic_message) .setContentTitle(getString(R.string.title)) .setContentText(getString(R.string.content)) .addAction(action) .build(); // Issue the notification. NotificationManagerCompat notificationManager = NotificationManagerCompat.from(this); notificationManager.notify(notificationId, newMessageNotification); 自定义通知 // Get the layouts to use in the custom notification RemoteViews notificationLayout = new RemoteViews(getPackageName(), R.layout.notification_small); RemoteViews notificationLayoutExpanded = new RemoteViews(getPackageName(), R.layout.notification_large); // Apply the layouts to the notification Notification customNotification = new NotificationCompat.Builder(context, CHANNEL_ID) .setSmallIcon(R.drawable.notification_icon) .setStyle(new NotificationCompat.DecoratedCustomViewStyle()) .setCustomContentView(notificationLayout) .setCustomBigContentView(notificationLayoutExpanded) .build(); 2.RemoteViews在桌面小部件上的应用AppWidgetProvider是Android中提供的用于实现桌面小部件的类，本质是一个广播 定义小部件界面 在res/layout/下建立小部件布局界面 定义小部件配置信息 在res/xml/下建立小部件配置信息 重要参数说明： initLayout:初始化界面 updatePeriodMillis:自动更新周期 定义小部件的实现类 继承AppWidgetProvider实现具体逻辑 重要方法说明： onEnable:小部件第一次添加到桌面时调用该方法 onUpdate:小部件被添加时或者每次小部件更新时都会调用该方法 onDeleted:每删除一次桌面小部件就调用一次 onDisabled:最后一个该类型的桌面小部件被删除时调用该方法 onReceive:分发具体的事件给其他方法 在AndroidManifest.xml中声明小部件 3.PendingIntent概述 ​ PendingIntent表示一种处于待定，等待，即将发生状态的意图，支持三种待定意图：启动Activity,启动Service,发送 广播 getActivity(Context context, int requestCode, Intent intent, int flags); getService(Context context, int requestCode, Intent intent, int flags); getBroadcast(Context context, int requestCode, Intent intent, int flags); 匹配规则：如果两个PendingIntent它们内部的Intent相同并且requestCode也相同，则这两个PendingIntent相同 Intent匹配规则：如果两个Intent的ComponentName和intent-filter都相同，则这两个Intent相同 Flag参数 FLAG_ONE_SHOT 当前PendingIntent只能使用一次 FLAG_NO_CREATE 当前PendingIntent不会主动创建，如果不存在，则get方法会直接返回null FLAG_CANCEL_CURRENT 当前描述的PendingIntent如果已存在，那么它们都会被cancel FLAG_UPDATE_CURRENT 当前描述的PendingIntent如果已存在，那么它们都会被更新 2.RemoteViews的内部机制 构造方法 /** * @param packageName 当前应用的包名 * @param layoutId 待加载的布局文件 **/ public RemoteViews(String packageName, int layoutId) RemoteViews目前并不支持所有的View类型，支持的所有类型如下 Layout : FrameLayout, LinearLayout, RelativeLayout, GridLayout View : AnalogClock, Button, Chronometer, ImageButton, ImageView, ProgressBar, TextView, ViewFlipper, ListView, GridView, StackView, AdapterViewFlipper, ViewStub 使用 RemoteViews没有提供findViewById方法，无法直接访问View元素，必须通过RemoteViews所提供的一系列set方法来完成 内部机制 RemoteViews会通过Binder传递到SystemServer进程 系统根据RemoteViews中的包名等信息得到该应用的资源，加载RemoteViews中的文件 系统对生成的View进行一系列界面更新任务 单击事件，RemoteViews中只支持发起PendingIntent,不支持onClickListener. setOnClickPendingIntent用于给普通View设置单击事件，但不能给集合(ListView,StackView)中的View设置单击事件 要给ListView或StackView中的item添加单击事件，必须将setPendingIntentTemplate和setOnClickFillInIntent组合使用]]></content>
      <categories>
        <category>Android开发艺术探索</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发艺术探索-View的工作原理]]></title>
    <url>%2F2020%2F07%2F12%2FAndroid%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-View%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[Android开发艺术探索 第四章笔记第四章 View的工作原理 初识ViewRoot和DecorView ViewRoot:对应于ViewRootImpl类，是连接WindowManager和DecorView的纽带，View的三大流程(measure,layout,draw)来完成的。 //在ActivityThread中，当Activity对象被创建完后，会将DecorView添加到Window中，同时创建 //ViewRootImpl对象，并将这两者关联起来 root = new ViewRootImpl(view.getContext(),display); root.setView(view,wparams,panelParentView); View的绘制流程从ViewRoot的performTraversals方法开始，经过三大流程完成绘制。 ​ 图 4-1 performTraversals的工作流程图 measure:测量View的宽和高 layout:确定View在父容器中的放置位置 draw:将View绘制在屏幕上 理解MeasureSpec 在很大程度上决定了一个View的尺寸规格(会受到父容器的影响)。 MeasureSpec:代表一个32位int值，高2位代表SpecMode，低30位代表SpecSize。 SpecMode：测量模式 SpecSize：在某种测量模式下的规格大小 private static final int MODE_SHIFT = 30; private static final int MODE_MASK = 0x3 &lt;&lt; MODE_SHIFT; private static final int UNSPECIFIED = 0 &lt;&lt; MODE_SHIFT; private static final int EXACTLY = 1 &lt;&lt; MODE_SHIFT; private static final int AT_MOST = 2 &lt;&lt; MODE_SHIFT; public static int makeMeasureSpec(int size,int mode)&#123; if(sUseBrokenMakeMeasureSpec)&#123; return size + mode; &#125;else&#123; return (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK) &#125; &#125; public static int getMode(int measureSpec)&#123; return (measureSpec &amp; MODE_MASK); &#125; public static int getSize(int measureSpec)&#123; return (measureSpec &amp; ~MODE_MASK); &#125; UNSPECIFIED:父容器不对View有任何限制 EXACTLY：父容器已检测出View所需要的精确大小，对应于LayoutParams中的match_parent和具体的尺寸数值。 AT_MOST：父容器给View指定了可用大小，View的大小不能大于这个值，对应于LayoutParams中的wrap_content。 MeasureSpec和LayoutParams的对应关系 顶级View（Decoriew）：Measurespec由窗口的尺寸和其自身的LayoutParams来共同确定； MATVH_PARENT：精确模式，大小就是窗口的大小； WRAP_CONTENT:最大模式，大小不定，不能超过窗口的大小； 固定大小：精确模式，大小为LayoutParams中指定到大小。 普通View:Measurespec由父容器的MeasureSpec和自身到LayoutParams共同决定。 TODO View的工作流程 measure过程 View的measure过程 //在View的measur方法中会去调用View的onMeasure方法 protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(),widthMeasureSpec),getDefaultSize(getSuggestedMinimumHeight(),heightMeasureSpec)); &#125; getSuggestedMinimumXXX:如果View没有设置背景，那么返回android:minXXX这个属性的值；如果View设置了背景，则返回android:minXXX和背景的最小尺寸这两个的最大值。 直接继承View的自定义控件需要重写onMeasure方法并设置wrap_content时的大小，否则在布局中使用wrap_content就相当于使用match_parent ViewGroup的measure过程 除了完成自己的measure过程外，还需要遍历所有子元素的measure方法。 //ViewGroup是抽象类，没有重写onMeasure方法，提供了measureChildren方法 protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) &#123; final int size = mChildrenCount; final View[] children = mChildren; for(int i = 0; i &lt; size; ++i) &#123; final View child = children[i]; if ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123; measureChild(child, widthMeasureSpec, heightMeasureSpec); &#125; &#125; &#125; measure完成后，通过getMeasuredWidth/Height方法就可以正确获取到View的宽高，但由于存在多次measure的情况，所以在onMeasure中得到的测量宽高不一定准确，在onLayout方法中获取宽高比较好一点。View的measue过程和Activity的生命周期方法不是同步执行的。可以通过以下方法解决： Activity/View#onWindowFocusChanged view.post(runnable) ViewTreeObserver view.measure(int widthMeasureSpec, int heightMeasureSpec) layout过程 Layout的作用是ViewGroup用来确定子元素的位置，当ViewGroup的位置被确定后，它在onLayout中会遍历所有的子元素并调用其layout方法，在layout方法中onLayout又会被调用。 View的layout方法流程 首先通过setFrame方法来设定View的四个顶点的位置，接着调用onLayout方法。 在View的默认实现中，View的测量宽高和最终宽高是相等的，不同点是测量宽高形成于View的measure过程，最终宽高形成于View的layout过程。 draw过程 将View绘制到屏幕上，绘制过程如下： 绘制背景：backgroud.draw(canvas) 绘制自身：onDraw 绘制子元素：dispatchDraw 绘制装饰：onDrawScrollBars View绘制过程的传递通过dispatchDraw实现，该方法会遍历调用所有子元素的draw方法 自定义View 自定义View的分类 graph LR A[自定义View] --> B[继承View重写onDraw方法] A --> C[继承ViewGroup派生特殊的Layout] A --> D[继承特定的View 如TextView等] A --> E[继承特定的ViewGroup 如LinearLayout等] 自定义View须知 让View支持wrap_content 支持Padding 尽量不要在View中使用Handler View中如果有线程或者动画，需要及时停止(View#onDetachedFromWindow) 处理好滑动冲突]]></content>
      <categories>
        <category>Android开发艺术探索</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发艺术探索-View的事件体系]]></title>
    <url>%2F2020%2F07%2F08%2FAndroid%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-View%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[Android开发艺术探索 第三章笔记第三章 View的事件体系3.1 View基础知识 什么是View View是Android中所有控件的基类，是一种界面层的控件的一种抽象。ViewGroup内部包含了许多控件，是一组View，它们之间的关系如下图。 View的位置参数 View的位置由它的四个顶点决定，分别对应于View的四个属性：top, left, right, bottom 即它的四个坐标，并且这四个坐标都是相对与View的父容器来说的，是相对坐标。 width = right - left height = bottom - top MotionEvent和TouchSlop MotionEvent:在手指接触屏幕后所产生的一系列事件 ACTION_DOWN——手指刚接触屏幕 ACTION_MOVE——手指在屏幕上移动 ACTION_UP——手指从屏幕上松开的一瞬间 典型事件序列 点击屏幕后离开松开，事件序列为——DOWN -&gt; UP; 点击屏幕滑动一会儿在松开，事件序列为——DOWN-&gt;MOVE-&gt;…-&gt;MOVE-&gt;UP 通过MotionEvent对象可以得到点击事件发生的x和y坐标。 getX/getY——返回的是相对于当前View左上角的x和y坐标； getRawX/getRawY——返回的是相对于手机屏幕左上角的x和y坐标。 TouchSlop：系统所能识别的滑动的最小距离，当两次滑动之间的距离小于这个常量时，系统不能识别为是滑动事件，值和设备有关，通过如下方法可以获取这个常量。 ViewConfiguration.get(getContext()).getScaledTouchSlop(); VelocityTracker,GestureDetector和Scroller VelocityTracker：速度追踪，用于追踪手指在滑动过程中的速度，包括水平和竖直方向。 //1.首先在View的onTouchEvent方法中追踪当前点击事件的速度 VelocityTracker velocityTracker = VelocityTracker.obtain(); velocityTracker.addMovement(event); //2.获取当前速度 velocityTracker.computeCurrentVelocity(1000);//计算一个时间段内的速度 int xVelocity = (int) velocityTracker.getXVelocity(); int yVelocity = (int) velocityTracker.getYVelocity(); //3.重置并回收内存 velocityTracker.clear(); velocityTracker.recycle(); GestureDetector：手势检测，用于辅助检测用户的单击，滑动，长按，双击等行为。 //1.创建一个GestureDetector对象，实现onGestureListener接口 GestureDetector mGestureDetector = new GestureDetector(this); mGestureDetector.setIsLongpressEnabled(false);//解决长按屏幕后无法拖动的现象 //2.接管目标View的onTouchEvent方法,在其中使用 boolean consume = mGestureDetector.onTouchEvent(event); return consume; //3.选择实现onGestureListener和OnDoubleTapListener中的方法 //比如onSingleTapup():单击 ，onFling():滑动，onScroll():拖动，onLongPress():长按， //onDoubleTap():双击 Scroller：弹性滑动对象，用于实现View的弹性滑动。 Scroller mScroller = new Scroller(mContext); //缓慢滚动到指定位置 private void smoothScrollTo(int destX,int destY)&#123; int scrollX = getScrollX(); int delta = destX-scrollX; mScroller.startScroll(ScrollX,0,delta,0,1000); &#125; @Override public void computeScroll()&#123; if(mScroller.computeScrollOffset())&#123; smoothScrollTo(mScroller.getCurrX(),mScroller.getCurrY()); postInvalidate(); &#125; &#125; 3.2 View的滑动 使用ScrollTo/scrollBy public void scrollTo（ int x,int y）&#123; if(mScrollX != x||mScrollY !=y)&#123; int oldX = mScrollX; int oldY = mScrollY; mScrollX = x; mScrollY = y; invalidateParentCaches(); onScrollChanged(mScrollX,mScrollY,oldX,oldY); if(!awakenScrollBars())&#123; postInvalidateOnAnimation(); &#125; &#125; public void scrollBy(int x,int y)&#123; scrollTo(mScrollX + x,mScrollY + y); &#125; &#125; 在滑动过程中，mScrollX的值总是等于View左边缘和View内容左边缘在水平方向的距离；mScrollY的值等于View上边缘和View内容上边缘在竖直方向上的距离 scrollTo和scrollBy只能改变View内容的位置而不能改变View在布局中的位置。 如果从左向右滑动，那么mScrollX为负值，反之为正值；如果从上往下滑动，那么mScrollY为负值，反之为正值。 b 使用动画 &lt;!--View动画实现移动--&gt; &lt;translate android:duration="100" android:fromXDelta="0" android:fromYDelta="0" android:interpolator="@android:anim/linear_interpolator" android:toXDelta="100" android:toYDelta="100"/&gt; //属性动画实现移动 ObjectAnimator.ofFloat(targetView,"translationX",0,100) .setDuration(100) .start(); 改变布局参数：即改变LayoutParams MarginLayoutParams params = (MarginLayoutParams)mButton.getLayoutParams(); params.width +=100; params.leftMargin +=100; mButton.requestLayout(); //或者 mButton.setLayoutParams(params); 各种滑动方式的对比 scrollTo/scrollBy : 操作简单，适合对View内容的滑动 动画 ：操作简单，主要适用于没有交互的View和实现复杂的动画效果 改变布局参数 ：操作稍复杂，适用于有交互的View 3.3 弹性滑动 使用Scroller 当View重绘后会在在draw方法中调用computeScroll，而computeScroll又会去向当前Scroller获取当前的scrollX和scrollY；然后通过scrollTo方法实现滑动，然后继续重绘，循环反复。 通过动画 使用延时策略 通过发送一系列延时消息达到渐进式的效果，可以使用Handler或View的postDelayed方法。 3.4 View的事件分发机制 点击事件的传递规则 //点击事件分发过程中的三个重要方法 public boolean dispatchTouchEvent(MotionEvent e) //用来进行事件的分发 public boolean onInterceptTouchEvent(MotionEvent e) //用来判断是否拦截某个事件 public boolean onTouchEvent(MotionEvent e) //在dispatchTouchEvent中调用，用来处理点击事件 //三个方法的关系（伪代码） public boolean dispatchTouchEvent(MotionEvent e)&#123; boolean consume =false; if(onInterceptTouchEvent(e))&#123; consume =onTOuchEvent(e); &#125;else&#123; consume = child.dispatchTouchEvent(e); &#125; return consume; &#125; 当一个点击事件产生时，它的传递过程为：Activity -&gt; Window -&gt;View,即事件先传递给Activity，Activity再传递给Window，最后Window再传递给顶级View，顶级View接收到事件后，就会按照事件分发机制去分发事件。 PS： 同一个事件序列是指从手指接触屏幕那一刻起到手指离开屏幕的那一刻结束，在这一过程中产生的一系列事件； 正常情况下，一个事件序列只能被一个View拦截且消耗； 某个View一旦决定拦截，那么这个事件序列都只能由它处理，并且它的onInterceptTouchEvent不会被调用； 某个View一旦开始处理事件，如果它不消耗ACTION_DOWN(onTouchEvent返回false)，那么同一事件序列的其它事件都不会交由它处理，事件会重新交由它的父元素处理(调用父元素的onTouchEvent); ViewGroup默认不拦截任何事件； View没有onInterceptTouchEvent方法，一旦有点击 事件传递给它，它的onTouchEvent方法就会调用； View的onTouchEvent默认都会消耗事件(返回true)。除非它是不可点击的(clickable和longClickable都为false)； View的enable属性不影响onTouchEvent的默认返回值。、 onClick会发生的前提是当前View是可点击的，并且它收到了down和up事件； 事件传递过程是由外向内的，即事件总是先传递给父元素，再由父元素分发给子View，通过requestDisallowInterceptTouchEvent方法可以在子元素中干预父元素的事件分发过程，但是ACTION_DOWN事件除外。 事件分发的源码解析 Activity对点击事件的分发过程 当一个点击操作发生时，事件最先传递给当前Activity，由Activity的dispatchTouchEvent来进行事件分发，具体是由Activity的Window来完成的。Window会将事件传递给decor view，decor view 一般是当前界面的底层容器(即setContentView所设置的View的父容器)。 //Activity # dispatchTouchEvent public boolean dispatchTouchEvent(MotionEvent ev)&#123; if(ev.getAction() == MotionEvent.ACTION_DOWN)&#123; onUserInteraction(); &#125; //交由所附属的Window进行分发 if(getWindow().superDispatchTouchEvent(ev))&#123; return true; &#125; return onTouchEvent(ev);//所有View都没有处理，调用Activity的onTouchEvent() &#125; //Window的分发 //Window # superDispatchTouchEvent public abstract boolean superDispatchTouchEvent(MotionEvent event) //Window的唯一实现是PhoneWindow //PhoneWindow # superDispatchTouchEvent public boolean superDispatchTouchEvent(MotionEvent event)&#123; return mDecor.superDispatchTouchEvent(event); &#125; //DecorView private final class DecorView extends FrameLayout implements RootViewSurfaceTaker&#123; private DecorView mDecor; @Override public final View getDecorView()&#123; if(mDecor == null)&#123; installDecor(); &#125; return mDecor; &#125; &#125; 顶级View对点击事件的分发过程 点击事件到达顶级View(一般是ViewGroup)以后，会调用ViewGroup的dispatchTouchEvent方法，然后如果ViewGroup拦截事件(onInterceptTouchEvent返回true)，则事件由ViewGroup处理，此时如果ViewGroup设置了onTouchListener，则onTouch会被调用，否则调用onTouchEvent，且如果设置了onClickListener，则会调用onClick。如果顶级View不拦截，则事件会传递给它所在的点击事件链上的子View，调用子View的dispatchTouchEvent，如此循环，完成整个事件的分发。 //check for interception # dispatchTouchEvent # ViewGroup final boolean intercepted; if(actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null)&#123; final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if(!disallowIntercept)&#123; intercepted = onInterceptTouchEvent(ev); ev.setAction(action);//restore action in case it was changed &#125;else&#123; intercepted = true; &#125; &#125;else&#123; intercepated = true; &#125; onInterceptTouchEvent不是每次事件都会被调用，当事件能够传递到当前的ViewGroup时，dispatchTouchEvent会每次都调用 FLAG_DISALLOW_INTERCEPT标记可以让ViewGroup不再拦截事件 View对点击事件的处理过程 3.5 View的滑动冲突 常见的滑动冲突场景 外部滑动方向和内部滑动方向不一致 外部滑动方向和内部滑动方向一致 上面两种情况的嵌套 滑动冲突的处理规则 第一种滑动冲突：根据滑动时水平滑动还是竖直滑动来判断由谁拦截事件。 第二种滑动冲突：根据实际业务需求来进行处理 第三种滑动冲突：与第二种一致 滑动冲突的解决方式 外部拦截法 点击事件都先经过父容器的拦截处理，根据父容器的需求即可解决滑动冲突 内部拦截法 父容器不拦截任何事件，所有的事件都传递给子元素，子元素可以直接消耗掉或者交由父容器进行处理。需要配合requestDisallowInterceptTouchEvent方法才能正常工作。]]></content>
      <categories>
        <category>Android开发艺术探索</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发艺术探索-IPC机制]]></title>
    <url>%2F2020%2F07%2F05%2FAndroid%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-IPC%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Android开发艺术探索 第二章笔记第二章 IPC机制 Android IPC 简介IPC：Inter-Process Communication的缩写，意思为进程间通信或者跨进程通信，指两个进程之间进行数据交换的过程。 线程：CPU调度的最小单元，是一种有限的系统资源。 进程：一般指一个执行单元，在PC和移动设备上指一个程序或者应用。一个进程可以包含多个线程。 Android中的多进程模式 开启多进程模式 在Android中使用多进程只有一个方法，那就是给四大组件在AndroidManifest中指定android:process属性。 进程名以“：”开头的进程属于当前应用的私有进程，其他应用的组件不可以和它在同一进程中，而进程名不以“：”开头的进程属于全局进程，其他应用可以通过ShareUID方式和它在同一进程中。Android系统会为每个应用分配一个唯一的UID，具有相同UID的应用才能共享数据。(两个应用通过ShareUID在同一个进程张，不但ShareUID要相同，签名也必须相同才可以互相访问数据) 多进程模式运行机制 多进程造成的问题： 静态成员和单例模式完全失效。 线程同步机制完全失效。 SharedPreferences的可靠性下降。 Application会多次创建。 在多进程模式中，不同进程的组件会拥有独立的虚拟机，Application以及内存空间。 IPC基础概念介绍 Serializable接口：Java所提供的一个序列化接口，是一个空接口，为对象提供序列化和反序列化操作。 实现只要实现该接口，并且在类的声明中指定下面的标识即可自动实现默认的序列化操作。 public class User implements Serializable&#123; private static final long serialVersionUID = 871136882100083044L private String userName; private boolean isMale; ... 』 //序列化操作 User user = new User("Stephanie",false); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream("cache.txt")); out.writeObject(user); out.close //反序列化操作 ObjectInputStream in = new ObjectInputStream(new FileInputStream("cache.txt")); User user = (User)in.readObject(); in.close(); serialVersionUID工作机制：序列化时系统会将当前类的serialVersionUID写入序列化的文件中，当反序列化时系统会去检测文件中的serialVersionUID，看它是否和当前类的serialVersionUID一致，一致则说明版本相同可以成功反序列化；否则无法正常反序列化 Notice: 静态成员变量属于类不属于对象，所以不会参与序列化过程； 用transient关键字标记的成员变量不参与序列化过程。 通过重写readObject()和writeObject()方法可以改变系统的默认序列化过程。 Parcelable接口：Android提供的新的序列化方式。 //实现Parcelable典型用法 public class User implements Parcelable&#123; public int userId; public String userName; public boolean isMale; public Book book; //构造方法 public User(int UserId,String userName,boolean isMale)&#123; this.userId = userId; this.userName = userName; this.isMale = isMale; &#125; //返回当前对象的内容描述，含文件描述符返回1，否则返回0 public int describeContents()&#123; reaturn 0; &#125; //将当前对象写入序列化结构中，flags标识有两种值(0,1),为1时标识当前对象需要作为返回值返回，不能 //立即释放资源 public void writeToParcel(Parcel out,int flags)&#123; out.writeInt(userId); out.writeString(userName); out.writeInt(isMale ? 1 : 0); out.writeParcelable(book,0); &#125; //实现反序列化功能 public static final Parcelable.Creator&lt;User&gt; CREATER = new Parcelable.Creator&lt;User&gt;()&#123; //从序列化后的对象中创建原始对象 public User createrFromParcel(Parcel in)&#123; return new User(in); &#125; //创建指定长度的原始对象数组 public User[] newArray(int size)&#123; return new User[size]; &#125; &#125;; // private User(Parcel in)&#123; userId = in.readInt(); userName = in.readString(); isMale = in.readInt() == 1; book = in.readParcelable(Thread.currentThread().getContextClassLoader()); &#125; &#125; Parcelable 和Serializable选取： Serializable是Java中的序列化接口，使用简单但需要大量I/O操作，开销很大；Parcelable使用较麻烦但在Android平台上效率很高，所以首选Parcelable接口。 Binder:Binder是Android中的一种跨进程通信方式。在Android开发中，Binder主要用于Service中，包括AIDL和Messenger。 当客户端发起远程请求时，由于当前线程会被挂起直至服务端进程返回数据，所以不能在UI线程中发起耗时的远程请求； 由于服务打的Binder方法运行在Binder的线程池中，所以Binder方法不管是否耗时都应该采用同步的方法去实现。 Binder实现步骤 声明一个AIDL性质的接口，只需继承IInterface接口 实现Stub类和Stub类的Proxy代理类 给Binder设置死亡代理： 声明一个Deathecipient对象。Deathecipient是一个接口，我们需要实现其内部的回调方法binderDied private IBinder.DeathRecipient mDeathRecipient = new IBinder.DeathRecipient()&#123; @Override public void binderDied()&#123; if(mBookManager == null) return; mBookManager.asBinder().unlinkToDeath(mDeathRecipient,0); mBookManager = null; &#125; &#125; 在客户端绑定远程服务成功后，给binder设置死亡代理 mService = IMessageBoxManager.Stub.asInterface(binder); binder.linkToDeath(mDeathRecipient,0); 通过Binderd方法isBinderAlive可以判断Binder是否死亡 Android中IPC方式 使用Bundle 四大组件中的三大组件(Activity，Service，Receiver)都是支持Intent中传递Bundle数据的，由于Bundle实现了Parcelable接口，所以它可以在不同的进程之间传输。但是，传输的数据必须能够被序列化，比如基本类型和实现了Parcelable接口的对象。 使用文件共享 即两个进程通过读/写同一个文件来交换数据。除了可以交换一些文本信息外，还可以序列化一个对象到文件系统的同时另一个进程中恢复这个对象。 //MainActivity private void persistToFile()&#123; new Thread(new Runnable()&#123; @Override public void run()&#123; User user = new User(1,"hello world",false); File dir = new File(MyConstants.CHAPTER_2_PATH); if(!dir.exists())&#123; dir.mkdirs(); &#125; File cachedFile = new File(MyConstants.CACHE_FILE_PATH); ObjectOutputStream objectOutputStream = null; try&#123; objectOutputStream = new ObjectOutputStream(new FileOutputStream(cacheFile)); objectOutputStream.writeObject(user); Log.d(TAG,"persist user : " + user); &#125;catch(IOException e)&#123; e.printStackTrace(); &#125;finally&#123; MyUtils.close(objectOutputStream); &#125; &#125; &#125;).start(); &#125; //SecondActivity private void recoverFromFile()&#123; new Thread(new Runnable()&#123; @Override public void run()&#123; User user = null; File cachedFile = new File(MyConstants.CACHE_FILE_PATH); if(cachedFile.exists())&#123; ObjectInputStream objectInputStream = null; try&#123; objectInputStream = new ObjectInputStream(new FileInputStream( cachedFile)); user = (User) objectInputStream.readObject(); Log.d(TAG,"recover user :"+user); &#125;catch(IOException)&#123; e.printStackTrace(); &#125;catch(ClassNotFoundException e)&#123; e.printStackTrace(); &#125;finally&#123; MyUtils.close(objectInputStream); &#125; &#125; &#125; &#125;).start(); &#125; 文件共享方式适合在对数据同步要求不高的进程之间进行通信，并且要妥善处理并发读/写的问题。 使用Messenger 译为“信使”，可以在Message中放入需要传递的数据，通过它在不同进程中传递Message对象。它的底层实现是AIDL //Messenger的构造方法 public Messenger(Handler target)&#123; mTarget = target.getIMessenger(); &#125; public Messenger(IBinder target)&#123; mTarget = IMessenger.Stub.asInterface(target); &#125; Messenger一次处理一个请求，因此在服务端不用考虑线程同步的问题 实现Messenger的步骤： 服务端进程 首先在服务端创建一个Service来处理客户端的连接请求，同时创建一个Handler并通过它来创建 Messenger对象，然后在Service的onBind中返回Messenger对象底层的Binder。 客户端进程 首先绑定服务端的Service，绑定成功后用服务端返回的IBinder对象创建一个Messenger，通过这个Messenger就可以向服务端发送Message对象。 //服务端 public class MessengerService extends Service&#123; private static final String TAG = "MessengerService"; private static class MessengerHandler extend Handler&#123; @Override public void handleMessage(Message msg)&#123; switch(msg.what)&#123; case MyConstants.MSG_FROM_CLIENT: Log.i(TAG,"receive msg from client : "+msg.getData().getString("msg")); break; default: super.handleMessage(msg); &#125; &#125; &#125; &#125; //注册Service &lt;service android:name = "com.ryg.chapter_2.messenger.MessengerService" android:process = ":remote"&gt; //客户端 public class MessengerActivity extends Activity&#123; private static final String TAG = "MessengerActivity"; private Messenger mService; private ServicerConnection mConnection = new ServiceConnection()&#123; public void onServiceConnected(ComponentName className,IBinder service)&#123; mService = new Messenger(service); Message msg = Message.obtain(null,"MyConstants.MSG_FROM_CLIENT"); Bundle data = new Bundle(); data.putString("msg","hello ,this is client."); msg.setData(data); try&#123; mService.send(msg); &#125;catch(RemoteException e)&#123; e.printStackTrace(); &#125; &#125; public void onServiceDisconnected(ComponentName className)&#123;&#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState)&#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_messenger); Intent intent = new Intent(this,MessengerService.class); bindService(intent,mConnection,Conatext.BIND_AUTO_CREATE); &#125; @Override protected void onDestroy()&#123; unbindService(mConnection); super.onDestroy(); &#125; &#125; 使用AIDL AIDL的使用流程: 服务端 创建一个Service用来监听客户端的连接 创建一个AIDL文件声明给客户端的接口 在Service中实现这个AIDL接口 客户端 需要绑定服务端的Service 绑定成功后将服务端返回的Binder对象转换成AIDL接口所属的类型 AIDL接口的创建 //IBookManager.aidl package com.ryg.chapter_2.aidl import com.ryg.chapter_2.aidl.Book; interface IBookManager&#123; List&lt;Book&gt; getBookList(); void addBook(in Book book); &#125; AIDL文件支持的数据类型 基本数据类型(int , long , char , boolean , double等); String和CharSequence; List:只支持ArrayList,并且里面的每个元素都必须能够被AIDL支持； Map:只支持Hashap，并且里面的每个元素都必须能够被AIDL支持； Parcelabel：所有实现了Parcelable接口的对象； AIDL：所有的AIDL接口本身也可以在AIDL文件中使用。 自定义的Parcelable对象和AIDL对象必须要显式import进来，无论它是否与当前AIDL文件位于同一个包内。 如果AIDL文件中用到了自定义的Parcelable对象，必须新建一个和它同名的AIDL文件，并在其中声明它为Parcelabel类型。 AIDL中除了基本数据类型，其他类型的参数必须标上方向：in，out，inout AIDL中的定向 tag 表示了在跨进程通信中数据的流向,数据流向是针对在客户端中的那个传入方法的对象而言的。 ​ in： 表示数据只能由客户端流向服务端 ​ out：表示数据只能由服务端流向客户端 ​ inout：表示数据可在服务端与客户端之间双向流通 远程服务端Service的实现 //服务端Service public class BookManagerService extends Service&#123; private static final String TAG = "BMS"; //CopyOnWriteArrayList:支持并发读/写。 private CopyOnWriteArrayList&lt;Book&gt; mBookList = new CopyOnWriteArrayList&lt;Book&gt;(); private Binder mBinder = new IBookManager.Stub()&#123; @Override public List&lt;Book&gt; getBookList() throws RemoteException&#123; return mBookList; &#125; @Override public void addBook(Book book)throws RemoteException&#123; mBookList.add(Book); &#125; &#125;; @Override public void onCreate()&#123; super.onCreate(); mBookList.add(new Book(1,"Android")); mBookList.add(new Book(2,"IOS")); &#125; @Override public IBinder onBind(Intent intent)&#123; return mBinder; &#125; &#125; &lt;service android:name=".aidl.BookManagerService" android:process=":remote"/&gt; 客户端的实现 public class BookManagerActivity extends Activity&#123; private static final String TAG = "BookManagerActivity"; private ServiceConnection mConnection = new ServiceConnection()&#123; public void onServiceConnected(ComponentName className,IBinder service)&#123; IBookManager bookManager = IBookManager.Stub.asInterface(service); try&#123; List&lt;Book&gt; list = bookManager.getBookList(); Log.i(TAG,"query book list ,list"+ "type:"+list.getClass().getCanonicalName()); Log.i(TAG,"query book list :"+list.toString()); &#125;catch(RemoteException e)&#123; e.printStackTrace(); &#125; &#125; public void onServiceDisconnected(ComponentName className)&#123;&#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState)&#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_book_manager); Intent intent = new Intent(this,BookManagerService.class); bindService(intent,mConnection,Context.BIND_AUTOCREATE); &#125; @Override protected void onDestroy()&#123; unbindService(mConnection); super.onDestroy(); &#125; &#125; 6. 解除监听 `RemoteCallbackList`是系统提供的用于删除跨进程Listener的接口 //声明RemoteCalbackList private RemoteCallbackList&lt;IOnNewBookListener&gt; mListenerList = new RemoteCallbackList&lt;&gt;(); //修改注册和注销方法 public void registerListener(IOnNewBookListener listener) throws RemoteException&#123; mListener.register(listener); &#125; public void unregisterListener(IOnNewBookListener listener) throws RemoteException&#123; mListener.unregister(listener); &#125; //通知Listener int N = mListenerList.beginBroadcast(); for(int i = 0; i &lt; N; i++) &#123; IOnNewBookListener l = mListenerList.getBroadcastItem(i); if(l != null)&#123; ...... &#125; &#125; mListenerList.finishBroadcast(); &gt; RemoteCallbackList并不是一个List,遍历时必须按照上述流程进行，`beginBroadcast`和`finishBroadcast`必须要配对使用。 &gt; &gt; 客户端的`onServiceConnected`和`onServiceDisconnected`方法都运行在主线程，不能在其中直接调用服务端的耗时方法。 &gt; &gt; `onServiceDiscnnected`在客户端的UI线程中被回调，而`binderDied`在客户端的Binder线程池中被回调 7. 在AIDL中进行权限验证 - 在onBind中进行验证 - 在服务端的onTransact方法中进行验证 使用ContentProvider ContentProvider是Android中提供的用于不同应用间进行数据共享的方式,其底层实现是Binder。 自定义ContentProvider步骤： 继承自ContentProvider类 实现其中的抽象方法：onCreate,query,update,insert,delete和getType。 注册这个类 与query方法不同的是，update,insert和delete方法会引起数据源的改变，需要通过ContentResolver的notifyhange方法进行更新。 要观察一个ContentProvider中的数据变化，可以通过ContentResolver的registerContentObserver方法注册观察者，用unregisterContentObserver来进行解除。 使用Socket Socket，也称为“套接字”，它分为流式套接字和用户数据报套接字，分别对应与网络传输控制层中的TCP和UDP协议。两个进程可以通过Socket来实现信息的传输，Socket本身可以支持传输任意字节流。 Socket连接过程 Binder连接池将每个业务模块的Binder请求统一转发到远程Service中去执行，从而避免了重复创建Service。 选用合适的IPC方式| 名称 | 优点 | 缺点 | 适用场景 || ————— | ——————————— | —————————————- | ———————————- || Bundle | 简单易用 | 只能传输Bundle支持的数据类型 | 四大组件间的进程间通信 || 文件共享 | 简单易用 | 不适合高并发场景，并且无法做到进程间的即时通信 | 无并发访问情形，交换简单的数据实时性不高的场景 || AIDL | 功能强大 | 使用稍复杂，需要处理好线程同步 | 一对多通信且有RPC需求 || Messenger | 功能一般，支持一对多串行通信，支持实时通信 | 不能很好处理高并发，不支持RPC，数据只能通过Message传输Bundle支持的数据类型 | 低并发的一对多即时通信，无RPC需求，或者无须要返回结果的RPC需求 || ContentProvicer | 数据源访问功能强大，支持一对多并发数据共享，可通过Call方法扩展 | 可以理解为受约束的AIDL，主要提供数据源的CRUD操作 | 一对多的进程间的数据共享 || Socket | 功能强大，可以通过网络传输字节流，支持一对多并发实时通信 | 实现细节稍繁琐，不支持直接的RPC | 网络数据交换 |]]></content>
      <categories>
        <category>Android开发艺术探索</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发艺术探索-Activity 的生命周期和启动模式]]></title>
    <url>%2F2020%2F06%2F27%2FAndroid%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-Activity%20%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Android 开发艺术探索 第一章笔记第一章 Activity 的生命周期和启动模式Activity 的生命周期 典型情况下的生命周期 : 在用户参与的情况下，Activity 所经过的生命周期的改变 onRestart:Activity 正在重新启动。 onCreate:Activity 正在被创建。可以在这个方法中进行初始化工作，比如加载界面布局资源，初始化数据等。 onStart:Activity 正在被启动，此时 Activity 已经可见，但是没有出现在前台，无法和用户进行交互。 onResume:Activity 已经可见，且出现在前台开始活动。 onPause:Activity 正在停止。 onStop:Activity 即将停止，可以做一些回收工作，但不能太耗时。 onDestroy:Activity 即将被销毁，生命周期最后一个回调，可以做一些回收工作和最终资源的释放。 (1) 一个 Activity 第一次启动时的回调为:onCreate-&gt;onStart-&gt;onResume (2)打开新的 Activity 或切换到桌面时的回调为:onPause-&gt;onStop(如果新 Activity 采用了透明主题，则不会调用 onStop) (3)再次回到原 Activity 时的回调为:onRestart-&gt;onStart-&gt;onResume (4)使用 back 键回退时的回调:onPause-&gt;onStop-&gt;onDestroy Remarks:onStart 和 onStop 是从 Activity 是否可见的角度进行回调的;onResume 和 onPause 是从 Activity 是否位于前台的角度。 异常情况下的生命周期 : Activity 被系统回收或者当前设备的 Configuration 发生改变而导致 Activity 被销毁重建 资源相关的系统配置发生改变导致 Activity 被杀死并重新创建 资源内存不足导致低优先级的 Activity 被杀死 Activity 优先级情况(由高到低) 前台 Activity ——正在与用户交互的 Activity，优先级最高 可见但非前台 Activity 后台 Activity ——已经被暂停的 Activity Activity 的启动模式 Activity 的 LaunchMode standard:标准模式。每次启动一个 Activity 都会重新创建一个新的实例，不管这个实例是否已经存在。在这种模式下，谁启动了这个 Activity，那么这个 Activity 就运行在启动它的那个 Activity 所在的栈中。 singleTop:栈顶复用模式。在这种模式下，如果新的 Activity 已经位于任务栈的栈顶，那么此 Activity 不会被重新创建，同时它的 onNewIntent 方法会被回调，并且这个 Activity 的 onCreate,onStart 不会被系统调用;如果新 Activity 的实例已存在但不是位于栈顶，那么新 Activity 仍然会重新创建。 singleTask:栈内复用模式。这是一种单实例模式，在这种模式下，只要 Activity 在一个栈中存在，那么多次启动此 Activity 都不会重新创建实例。 singleInstance:单实例模式。除了具有 singleTask 模式的所有特性外，在这种模式下的 Activity 只能单独地位于一个任务栈中。 TaskAffinity:任务相关性。这个参数标识了一个 Activity 所需要的任务栈的名字，默认情况下为应用的包名。TaskAffinity 属性主要和 singleTask 启动模式或者 AllowTaskReparenting 属性配对使用；任务栈分为前台任务栈和后台任务栈，后台任务栈中的 Activity 处于暂停状态。 给 Activity 指定启动模式 通过 AndroidManifest 文件给 Activity 指定启动模式 &lt;activity android:name="com.ryg.chapter_1.secondActivity" android:configChanges="screenLayout" android:launchMode="singleTask" android:label="@string/app_name"/&gt; 通过在 Intent 中设置标志位为 Activity 指定启动模式 Intent intent = new Intent(); intent.setClass(MainActivity.this,SecondActivity.class); intent.addFlags(Intetn.FLAG_ACTIVITY_NEW_TASK); startActivity(intent); 两种方式的区别： 第二种的优先级要高于第一种，当两种同时存在时，以第二种方式为准； 第一种方式无法直接为 Activity 设定 FLAG_ACTIVITY_CLEAR_TOP 标识，而第二种方式无法为 Activity 指定 singlenstance 模式 Activity的Flags FLAG_ACTIVITY_NEW_TASK:为Activity指定“singleTask”启动模式 FLAG_ACTIVITY_SINGLE_TOP:为Activity指定“singleTop”启动模式 FLAG_ACTIVITY_CLEAR_TOP:具有此标记位的Activity启动时，在同一个任务栈中所有位于它上面的Activity都要出栈 FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS:具有此标记的Activity不会出现在历史Activity的列表中。 IntentFilter 的匹配规则 action(字符串)的匹配规则：Intent 中的 action 必须能够和过滤规则中的 action 匹配，即 action 的字符串值完全一样。一个过滤规则中可以有多个 action，只要 Intent 中的 action 能够和过滤规则中的任何一个 action 相同即可匹配成功。但如果 Intent 中没有指定 action，则匹配失败，并且 action 区分大小写。 category(字符串)的匹配规则：它要求 Intent 中如果含有 category，那么所有的 category 都必须和过滤规则中的其中一个 category 相同。如果 Intent 中没有，仍然可以匹配成功。 data 的匹配规则 结构：由 mimeType 和 URI 两部分组成。其中 mimeType 指的是媒体类型，URI 是资源地址。 &lt;!-- 语法 --&gt; &lt;data android:scheme="string" android:host="string" android:port="string" android:path="string" andrid:pathPattern="string" android:pathPrefix="string" android:mimeType="string" /&gt; &lt;!-- 结构 --&gt; &lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;/[&lt;path&gt;|&lt;pathPrefix&gt;|&lt;pathPattern&gt;] 2. 匹配规则：Intent中必须含有data数据，并且data数据能够完全匹配过滤规则中的某一个data]]></content>
      <categories>
        <category>Android开发艺术探索</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown基本语法速查]]></title>
    <url>%2F2020%2F03%2F27%2FMarkdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E9%80%9F%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[MarkDown基本语法 简介 Markdown是一种轻量级标记语言，创始人为约翰·格鲁伯（英语：John Gruber）。它允许人们使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML（或者HTML）文档。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。 由于Markdown的轻量化、易读易写特性，并且对于图片，图表、数学式都有支持，当前许多网站都广泛使用Markdown来撰写帮助文档或是用于论坛上发表消息。如GitHub、Reddit、Diaspora、Stack Exchange、OpenStreetMap 、SourceForge、简书等，甚至还能被使用来撰写电子书。 ​ —WikiPedia 基本命令 标题 # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 字体 **加粗** *斜体* ~~删除线~~ &lt;u&gt;下划线&lt;/u&gt; `注释` ==高亮== 列表 ## 有序列表 1. 2. 3. ## 无序列表 - - - ## 任务列表 - [ ] 任务1 - [ ] 任务2 - [x] 任务3 引用 &gt; 这是引用部分内容 代码块 ​public static void main(String[] args) &#123; &#125; ​ 表格 | First Header | Second Header | | ------------- | ------------- | | Content Cell | Content Cell | | Content Cell | Content Cell | 目录 [TOC] 链接 超链接 [链接名称](链接地址) - 图片链接 ![图片名称](图片地址) 脚注 You can create footnotes like this[^footnote]. [^footnote]: Here is the *text* of the **footnote**. Emoji表情 :smile: :kissing_smiling_eyes::kissing_smiling_eyes: 视频 &lt;video src=&quot;xxx.mp4&quot; HTML &lt;span style=&quot;color:red&quot;&gt;红色的文本&lt;/span&gt; 绘制结构图 流程图 ## Flowchart.js ​st=&gt;start: Start op=&gt;operation: Your Operation cond=&gt;condition: Yes or No? e=&gt;end st-&gt;op-&gt;cond cond(yes)-&gt;e cond(no)-&gt;op ## Mermaid ​&lt;pre class=&quot;mermaid&quot;&gt; graph LR A[Hard edge] --&gt;B(Round edge) B --&gt; C&#123;Decision&#125; C --&gt;|One| D[Result one] C --&gt;|Two| E[Result two] ​&lt;/pre&gt; 时序图 ## js-sequence ​Alice-&gt;Bob: Hello Bob, how are you? Note right of Bob: Bob thinks Bob--&gt;Alice: I am good thanks! ​ ## Mermaid ​&lt;pre class=&quot;mermaid&quot;&gt; %% Example of sequence diagram sequenceDiagram Alice-&gt;&gt;Bob: Hello Bob, how are you? alt is sick Bob-&gt;&gt;Alice: Not so good :( else is well Bob-&gt;&gt;Alice: Feeling fresh like a daisy end opt Extra response Bob-&gt;&gt;Alice: Thanks for asking end ​&lt;/pre&gt; 甘特图 ## Mermaid ​&lt;pre class=&quot;mermaid&quot;&gt; %% Example with selection of syntaxes gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d ​&lt;/pre&gt; 类图 ## Mermaid ​&lt;pre class=&quot;mermaid&quot;&gt; classDiagram Animal &lt;|-- Duck Animal &lt;|-- Fish Animal &lt;|-- Zebra Animal : +int age Animal : +String gender Animal: +isMammal() Animal: +mate() class Duck{ +String beakColor +swim() +quack() } class Fish{ -int sizeInFeet -canEat() } class Zebra{ +bool is_wild +run() } ​&lt;/pre&gt; 状态图 ​&lt;pre class=&quot;mermaid&quot;&gt; stateDiagram [*] --&gt; Still Still --&gt; [*] Still --&gt; Moving Moving --&gt; Still Moving --&gt; Crash Crash --&gt; [*] ​&lt;/pre&gt; - 饼图 ​&lt;pre class="mermaid"&gt; pie title Pie Chart "Dogs" : 386 "Cats" : 85 "Rats" : 150 ​&lt;/pre&gt; 4. 数学公式 ```markdown ## 行内公式 $ a^2 + b^2 = c^2 $ ## 行间公式 $$ y = x ^ &#123;2&#125; x_&#123;a + b&#125; x^&#123;a + b&#125; $$ 符号 代码 具体含义 $\sum$ $\sum$ 求和公式 $\sum_{i=0}^n$ $\sum_{i=0}^n$ 求和上下标 $\times$ $\times$ 乘号 $\pm$ $\pm$ 正负号 $\div$ $\div$ 除号 $\mid$ $\mid$ 竖线 $\cdot$ $\cdot$ 点 $\circ$ $\circ$ 圈 $\ast $ $\ast $ 星号 $\bigotimes$ $\bigotimes$ 克罗内克积 $\bigoplus$ $\bigoplus$ 异或 $\leq$ $\leq$ 小于等于 $\geq$ $\geq$ 大于等于 $\neq$ $\neq$ 不等于 $\approx$ $\approx$ 约等于 $\prod$ $\prod$ N元乘积 $\coprod$ $\coprod$ N元余积 $\cdots$ $\cdots$ 省略号 $\int$ $\int$ 积分 $\iint$ $\iint$ 双重积分 $\oint$ $\oint$ 曲线积分 $\infty$ $\infty$ 无穷 $\nabla$ $\nabla$ 梯度 $\because$ $\because$ 因为 $\therefore$ $\therefore$ 所以 $\forall$ $\forall$ 任意 $\exists$ $\exists$ 存在 $\not=$ $\not=$ 不等于 $\not&gt;$ $\not&gt;$ 不大于 $\leq$ $\leq$ 小于等于 $\geq$ $\geq$ 大于等于 $\not\subset$ $\not\subset$ 不属于 $\emptyset$ $\emptyset$ 空集 $\in$ $\in$ 属于 $\notin$ $\notin$ 不属于 $\subset$ $\subset$ 子集 $\subseteq$ $\subseteq$ 真子集 $\bigcup$ $\bigcup$ 并集 $\bigcap$ $\bigcap$ 交集 $\bigvee$ $\bigvee$ 逻辑或 $\bigwedge$ $\bigwedge$ 逻辑与 $\alpha$ $\alpha$ $\beta$ $\beta$ $\gamma$ $\gamma$ $\Gamma$ $\Gamma$ $\delta$ $\delta$ $\Delta$ $\Delta$ $\epsilon$ $\epsilon$ $\varepsilon$ $\varepsilon$ $\zeta$ $\zeta$ $\eta$ $\eta$ $\theta$ $\theta$ $\Theta$ $\Theta$ ϑ $\vartheta$ ι $\iota$ π $\pi$ ϕ $\phi$ Φ $\Phi$ ψ $\psi$ Ψ $\Psi$ ω $\omega$ Ω $\Omega$ χ \chi ρ $\rho$ ο $\omicron$ σ $\sigma$ Σ $\Sigma$ ν $\nu$ ξ $\xi$ τ $\tau$ λ $\lambda$ Λ $\Lambda$ μ \mu ∂ $\partial$ {} $\lbrace \rbrace$ a $\overline{a}$ ​]]></content>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ProtocolBuffers-基本使用]]></title>
    <url>%2F2020%2F03%2F12%2FProtocolBuffers-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Protocol Buffers​ 一种跨语言，跨平台的可扩展的序列化数据格式 相比XML的优势 更简单 更轻量（数据体积小3~10倍） 更快速（20～100倍） 自动化生成更易于编码方式使用的数据访问类 使用方法 graph TD; A[定义protobuf消息格式] --> B[编译protobuf]; B --> C[使用protobuf API进行读写]; 使用protobuf语法描述需要存储的数据结构（编写．proto文件） syntax = "proto3"; //默认为proto2,不能为空 package tutorial; //避免命名冲突 option java_package = "com.example.tutorial"; //生成类的包结构 option java_outer_classname = "AddressBookProtos"; //生成包括当前文件所有类的类名，默认是MyProto,生成my_proto.proto，不能与内部定义的类名称相同（不能设为AddressBook） message Person &#123; string name = 1; //用于二进制编码的唯一标识 int32 id = 2; string email = 3; enum PhoneType &#123; MOBILE = 0; //必须包含标识０，用于设置默认值和与proto2语义兼容 HOME = 1; WORK = 2; &#125; message PhoneNumber &#123; string number = 1; PhoneType type = 2 [packed = HOME]; &#125; PhoneNumber phones = 4; &#125; message AddressBook &#123; Person people = 1; &#125; 基本语法（proto3）： 消息是各种类型数据的集合， 可以包含bool,int32,float,double,string,枚举或者其他的消息 标识的范围为1 ~ 2^29^ - 1,1~15的标识比较高的数字少一个字节进行编码，适宜一些常用或者重复的字段;16以上的适用不太常使用的可选字段;19000 ~ 19999不可使用，为内置保留． 每个字段都必须标明注解： required:该字段必须设置值，否则该消息将被视为“未初始化”,构建未初始化的消息将抛出RuntimeException,解析未初始化的消息将抛出IOException;除此之外与optional一致 optional:该字段是可选字段，可以设置值也可以不设置值。如果不设置值，则使用默认值． repeated:该字段可以重复任意次数（包括零），重复值的顺序将保留在protobuf中。可将其视为动态大小的数组． Any字段： &gt; import "google/protobuf/any.proto"; &gt; &gt; message ErrorStatus &#123; &gt; string message = 1; &gt; google.protobuf.Any details = 2; &gt; &#125; &gt; Oneof字段： 一个.proto文件中可以定义多种消息 每个message类以及它的子类有自己的builder类 ，通过builder类来进行设置 数据类型 不能在proto3中直接导入proto2的枚举进行使用，要导入其消息． Map类型 &gt; map&lt;key_type, value_type&gt; map_field = N; &gt; map&lt;string, Project&gt; projects = 3; &gt; 1. `key_type` 可以是任何 int 或者 string 类型(任何的标量类型，具体可以见上面标量类型对应表格，但是要除去 float、double 和 bytes) 2. `value_type` 可以是除去 map 以外的任何类型。 定义service 如果要使用 RPC（远程过程调用）系统的消息类型，可以在 .proto 文件中定义 RPC 服务接口，protocol buffer 编译器将使用所选语言生成服务接口代码和 stubs &gt; //参数为SearchRequest,返回值为SearchResponse &gt; service SearchService &#123; &gt; rpc Search (SearchRequest) returns (SearchResponse); &gt; &#125; &gt; JSON Map 如果一个值在json编码的数据中丢失或者它的值是null, 在被解析成protocol buffer时它将设置为对应的默认值.如果一个字段的值正好是protocol buffer的默认值, 这个字段默认就不会出现在json编码的数据中以便节约空间. 通过protobuf编译器编译．proto文件（生成对应平台的文件） 使用命令 ##命令格式 protoc [option] PROTO_FILES ##Java protoc -I=$SRC_DIR --java_out=$DST_DIR $SRC_DIR/addressbook.proto ##Python protoc -I=$SRC_DIR --python_out=$DST_DIR $SRC_DIR/addressbook.proto SRC_DIR:源代码路径，默认为当前文件夹 DST_DIR:生成的代码路径，默认与SRC_DIR相同 –Java_out:生成不同语言对应的文件 对于Android使用Java Lite可以减小生成类的体积 1.安装java_lite环境 2.编译java_lite版文件 &gt; protoc --javalite_out=$DST_DIR PROTO_FILES &gt; 使用Android Studio 安装Protocol Support插件 配置gradle 编写．proto文件 编译项目 使用protobuf进行数据读写 除了访问器，生成的类中还有其它的方法： 消息构建接口 isInitialized():检测 所有required的字段是否有被设置 toString(): 生成可读的字符串 mergeFrom(Message other): (builder only)与另一个消息进行合并 clear(): (builder only) 将所有字段清除为空状态 解析接口 byte[] toByteArray();: 序列化数据 static Person parseFrom(byte[] data);: 反序列化数据 void writeTo(OutputStream output);: 序列化数据并写入OutputStream static Person parseFrom(InputStream input);: 从InputStream中解析读取消息 具体Demo 兼容处理 如果要让新版本向后兼容，旧版本向前兼容，需要遵守以下规则 不能修改已存在字段的标识（tag） 不能添加或删除required字段 可以删除optional或repeated字段 可以增加optional或repeated字段，但必须使用没有用过的标识，已经删除的也不能用]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo基本命令]]></title>
    <url>%2F2020%2F03%2F10%2FHexo%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[inithexo init [folder] 新建一个网站 hexo newhexo new [layout] &lt;title&gt; 新建一个title.md文档 hexo generate(hexo g) 选项 描述 -d, –deploy 文件生成后立即部署网站 -w, –watch 监视文件变动 -b, –bail 生成过程中如果发生任何未处理的异常则抛出异常 -f, –force 强制重新生成文件 Hexo 引入了差分机制，如果 public 目录存在，那么 hexo g 只会重新生成改动的文件。 使用该参数的效果接近 hexo clean &amp;&amp; hexo generate -c, –concurrency 最大同时生成文件的数量，默认无限制 生成网站静态文件到默认设置的 public 文件夹 publishhexo publish [layout] &lt;fileName&gt; 发表草稿 hexo server(hexo s) 启动服务器，默认网址为http://localhost:4000/ 项 描述 -p, –port 重设端口 -s, –static 只使用静态文件 -l, –log 启动日记记录，使用覆盖记录格式 hexo deploy(hexo d) 部署网站到服务器 参数 描述 -g, –generate 部署之前预先生成静态文件 hexo clean 清除缓存文件 (db.json) 和已生成的静态文件 (public)。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
