<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android开发艺术探索学习笔记-第四章]]></title>
    <url>%2F2020%2F07%2F12%2FAndroid%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%9B%9B%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[Android开发艺术探索 第四章笔记第四章 View的工作原理 初识ViewRoot和DecorView ViewRoot:对应于ViewRootImpl类，是连接WindowManager和DecorView的纽带，View的三大流程(measure,layout,draw)来完成的。 //在ActivityThread中，当Activity对象被创建完后，会将DecorView添加到Window中，同时创建 //ViewRootImpl对象，并将这两者关联起来 root = new ViewRootImpl(view.getContext(),display); root.setView(view,wparams,panelParentView); View的绘制流程从ViewRoot的performTraversals方法开始，经过三大流程完成绘制。 ​ 图 4-1 performTraversals的工作流程图 measure:测量View的宽和高 layout:确定View在父容器中的放置位置 draw:将View绘制在屏幕上 理解MeasureSpec 在很大程度上决定了一个View的尺寸规格(会受到父容器的影响)。 MeasureSpec:代表一个32位int值，高2位代表SpecMode，低30位代表SpecSize。 SpecMode：测量模式 SpecSize：在某种测量模式下的规格大小 private static final int MODE_SHIFT = 30; private static final int MODE_MASK = 0x3 &lt;&lt; MODE_SHIFT; private static final int UNSPECIFIED = 0 &lt;&lt; MODE_SHIFT; private static final int EXACTLY = 1 &lt;&lt; MODE_SHIFT; private static final int AT_MOST = 2 &lt;&lt; MODE_SHIFT; public static int makeMeasureSpec(int size,int mode)&#123; if(sUseBrokenMakeMeasureSpec)&#123; return size + mode; &#125;else&#123; return (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK) &#125; &#125; public static int getMode(int measureSpec)&#123; return (measureSpec &amp; MODE_MASK); &#125; public static int getSize(int measureSpec)&#123; return (measureSpec &amp; ~MODE_MASK); &#125; UNSPECIFIED:父容器不对View有任何限制 EXACTLY：父容器已检测出View所需要的精确大小，对应于LayoutParams中的match_parent和具体的尺寸数值。 AT_MOST：父容器给View指定了可用大小，View的大小不能大于这个值，对应于LayoutParams中的wrap_content。 MeasureSpec和LayoutParams的对应关系 顶级View（Decoriew）：Measurespec由窗口的尺寸和其自身的LayoutParams来共同确定； MATVH_PARENT：精确模式，大小就是窗口的大小； WRAP_CONTENT:最大模式，大小不定，不能超过窗口的大小； 固定大小：精确模式，大小为LayoutParams中指定到大小。 普通View:Measurespec由父容器的MeasureSpec和自身到LayoutParams共同决定。 TODO View的工作流程 measure过程 View的measure过程 //在View的measur方法中会去调用View的onMeasure方法 protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(),widthMeasureSpec),getDefaultSize(getSuggestedMinimumHeight(),heightMeasureSpec)); &#125; getSuggestedMinimumXXX:如果View没有设置背景，那么返回android:minXXX这个属性的值；如果View设置了背景，则返回android:minXXX和背景的最小尺寸这两个的最大值。 直接继承View的自定义控件需要重写onMeasure方法并设置wrap_content时的大小，否则在布局中使用wrap_content就相当于使用match_parent ViewGroup的measure过程 除了完成自己的measure过程外，还需要遍历所有子元素的measure方法。 //ViewGroup是抽象类，没有重写onMeasure方法，提供了measureChildren方法 protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) &#123; final int size = mChildrenCount; final View[] children = mChildren; for(int i = 0; i &lt; size; ++i) &#123; final View child = children[i]; if ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123; measureChild(child, widthMeasureSpec, heightMeasureSpec); &#125; &#125; &#125; measure完成后，通过getMeasuredWidth/Height方法就可以正确获取到View的宽高，但由于存在多次measure的情况，所以在onMeasure中得到的测量宽高不一定准确，在onLayout方法中获取宽高比较好一点。View的measue过程和Activity的生命周期方法不是同步执行的。可以通过以下方法解决： Activity/View#onWindowFocusChanged view.post(runnable) ViewTreeObserver view.measure(int widthMeasureSpec, int heightMeasureSpec) layout过程 Layout的作用是ViewGroup用来确定子元素的位置，当ViewGroup的位置被确定后，它在onLayout中会遍历所有的子元素并调用其layout方法，在layout方法中onLayout又会被调用。 View的layout方法流程 首先通过setFrame方法来设定View的四个顶点的位置，接着调用onLayout方法。 在View的默认实现中，View的测量宽高和最终宽高是相等的，不同点是测量宽高形成于View的measure过程，最终宽高形成于View的layout过程。 draw过程 将View绘制到屏幕上，绘制过程如下： 绘制背景：backgroud.draw(canvas) 绘制自身：onDraw 绘制子元素：dispatchDraw 绘制装饰：onDrawScrollBars View绘制过程的传递通过dispatchDraw实现，该方法会遍历调用所有子元素的draw方法 自定义View 自定义View的分类 graph LR A[自定义View] --> B[继承View重写onDraw方法] A --> C[继承ViewGroup派生特殊的Layout] A --> D[继承特定的View 如TextView等] A --> E[继承特定的ViewGroup 如LinearLayout等] 自定义View须知 让View支持wrap_content 支持Padding 尽量不要在View中使用Handler View中如果有线程或者动画，需要及时停止(View#onDetachedFromWindow) 处理好滑动冲突]]></content>
      <categories>
        <category>Android开发艺术探索</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发艺术探索学习笔记-第三章]]></title>
    <url>%2F2020%2F07%2F08%2FAndroid%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%89%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[Android开发艺术探索 第三章笔记第三章 View的事件体系3.1 View基础知识 什么是View View是Android中所有控件的基类，是一种界面层的控件的一种抽象。ViewGroup内部包含了许多控件，是一组View，它们之间的关系如下图。 View的位置参数 View的位置由它的四个顶点决定，分别对应于View的四个属性：top, left, right, bottom 即它的四个坐标，并且这四个坐标都是相对与View的父容器来说的，是相对坐标。 width = right - left height = bottom - top MotionEvent和TouchSlop MotionEvent:在手指接触屏幕后所产生的一系列事件 ACTION_DOWN——手指刚接触屏幕 ACTION_MOVE——手指在屏幕上移动 ACTION_UP——手指从屏幕上松开的一瞬间 典型事件序列 点击屏幕后离开松开，事件序列为——DOWN -&gt; UP; 点击屏幕滑动一会儿在松开，事件序列为——DOWN-&gt;MOVE-&gt;…-&gt;MOVE-&gt;UP 通过MotionEvent对象可以得到点击事件发生的x和y坐标。 getX/getY——返回的是相对于当前View左上角的x和y坐标； getRawX/getRawY——返回的是相对于手机屏幕左上角的x和y坐标。 TouchSlop：系统所能识别的滑动的最小距离，当两次滑动之间的距离小于这个常量时，系统不能识别为是滑动事件，值和设备有关，通过如下方法可以获取这个常量。 ViewConfiguration.get(getContext()).getScaledTouchSlop(); VelocityTracker,GestureDetector和Scroller VelocityTracker：速度追踪，用于追踪手指在滑动过程中的速度，包括水平和竖直方向。 //1.首先在View的onTouchEvent方法中追踪当前点击事件的速度 VelocityTracker velocityTracker = VelocityTracker.obtain(); velocityTracker.addMovement(event); //2.获取当前速度 velocityTracker.computeCurrentVelocity(1000);//计算一个时间段内的速度 int xVelocity = (int) velocityTracker.getXVelocity(); int yVelocity = (int) velocityTracker.getYVelocity(); //3.重置并回收内存 velocityTracker.clear(); velocityTracker.recycle(); GestureDetector：手势检测，用于辅助检测用户的单击，滑动，长按，双击等行为。 //1.创建一个GestureDetector对象，实现onGestureListener接口 GestureDetector mGestureDetector = new GestureDetector(this); mGestureDetector.setIsLongpressEnabled(false);//解决长按屏幕后无法拖动的现象 //2.接管目标View的onTouchEvent方法,在其中使用 boolean consume = mGestureDetector.onTouchEvent(event); return consume; //3.选择实现onGestureListener和OnDoubleTapListener中的方法 //比如onSingleTapup():单击 ，onFling():滑动，onScroll():拖动，onLongPress():长按， //onDoubleTap():双击 Scroller：弹性滑动对象，用于实现View的弹性滑动。 Scroller mScroller = new Scroller(mContext); //缓慢滚动到指定位置 private void smoothScrollTo(int destX,int destY)&#123; int scrollX = getScrollX(); int delta = destX-scrollX; mScroller.startScroll(ScrollX,0,delta,0,1000); &#125; @Override public void computeScroll()&#123; if(mScroller.computeScrollOffset())&#123; smoothScrollTo(mScroller.getCurrX(),mScroller.getCurrY()); postInvalidate(); &#125; &#125; 3.2 View的滑动 使用ScrollTo/scrollBy public void scrollTo（ int x,int y）&#123; if(mScrollX != x||mScrollY !=y)&#123; int oldX = mScrollX; int oldY = mScrollY; mScrollX = x; mScrollY = y; invalidateParentCaches(); onScrollChanged(mScrollX,mScrollY,oldX,oldY); if(!awakenScrollBars())&#123; postInvalidateOnAnimation(); &#125; &#125; public void scrollBy(int x,int y)&#123; scrollTo(mScrollX + x,mScrollY + y); &#125; &#125; 在滑动过程中，mScrollX的值总是等于View左边缘和View内容左边缘在水平方向的距离；mScrollY的值等于View上边缘和View内容上边缘在竖直方向上的距离 scrollTo和scrollBy只能改变View内容的位置而不能改变View在布局中的位置。 如果从左向右滑动，那么mScrollX为负值，反之为正值；如果从上往下滑动，那么mScrollY为负值，反之为正值。 b 使用动画 &lt;!--View动画实现移动--&gt; &lt;translate android:duration="100" android:fromXDelta="0" android:fromYDelta="0" android:interpolator="@android:anim/linear_interpolator" android:toXDelta="100" android:toYDelta="100"/&gt; //属性动画实现移动 ObjectAnimator.ofFloat(targetView,"translationX",0,100) .setDuration(100) .start(); 改变布局参数：即改变LayoutParams MarginLayoutParams params = (MarginLayoutParams)mButton.getLayoutParams(); params.width +=100; params.leftMargin +=100; mButton.requestLayout(); //或者 mButton.setLayoutParams(params); 各种滑动方式的对比 scrollTo/scrollBy : 操作简单，适合对View内容的滑动 动画 ：操作简单，主要适用于没有交互的View和实现复杂的动画效果 改变布局参数 ：操作稍复杂，适用于有交互的View 3.3 弹性滑动 使用Scroller 当View重绘后会在在draw方法中调用computeScroll，而computeScroll又会去向当前Scroller获取当前的scrollX和scrollY；然后通过scrollTo方法实现滑动，然后继续重绘，循环反复。 通过动画 使用延时策略 通过发送一系列延时消息达到渐进式的效果，可以使用Handler或View的postDelayed方法。 3.4 View的事件分发机制 点击事件的传递规则 //点击事件分发过程中的三个重要方法 public boolean dispatchTouchEvent(MotionEvent e) //用来进行事件的分发 public boolean onInterceptTouchEvent(MotionEvent e) //用来判断是否拦截某个事件 public boolean onTouchEvent(MotionEvent e) //在dispatchTouchEvent中调用，用来处理点击事件 //三个方法的关系（伪代码） public boolean dispatchTouchEvent(MotionEvent e)&#123; boolean consume =false; if(onInterceptTouchEvent(e))&#123; consume =onTOuchEvent(e); &#125;else&#123; consume = child.dispatchTouchEvent(e); &#125; return consume; &#125; 当一个点击事件产生时，它的传递过程为：Activity -&gt; Window -&gt;View,即事件先传递给Activity，Activity再传递给Window，最后Window再传递给顶级View，顶级View接收到事件后，就会按照事件分发机制去分发事件。 PS： 同一个事件序列是指从手指接触屏幕那一刻起到手指离开屏幕的那一刻结束，在这一过程中产生的一系列事件； 正常情况下，一个事件序列只能被一个View拦截且消耗； 某个View一旦决定拦截，那么这个事件序列都只能由它处理，并且它的onInterceptTouchEvent不会被调用； 某个View一旦开始处理事件，如果它不消耗ACTION_DOWN(onTouchEvent返回false)，那么同一事件序列的其它事件都不会交由它处理，事件会重新交由它的父元素处理(调用父元素的onTouchEvent); ViewGroup默认不拦截任何事件； View没有onInterceptTouchEvent方法，一旦有点击 事件传递给它，它的onTouchEvent方法就会调用； View的onTouchEvent默认都会消耗事件(返回true)。除非它是不可点击的(clickable和longClickable都为false)； View的enable属性不影响onTouchEvent的默认返回值。、 onClick会发生的前提是当前View是可点击的，并且它收到了down和up事件； 事件传递过程是由外向内的，即事件总是先传递给父元素，再由父元素分发给子View，通过requestDisallowInterceptTouchEvent方法可以在子元素中干预父元素的事件分发过程，但是ACTION_DOWN事件除外。 事件分发的源码解析 Activity对点击事件的分发过程 当一个点击操作发生时，事件最先传递给当前Activity，由Activity的dispatchTouchEvent来进行事件分发，具体是由Activity的Window来完成的。Window会将事件传递给decor view，decor view 一般是当前界面的底层容器(即setContentView所设置的View的父容器)。 //Activity # dispatchTouchEvent public boolean dispatchTouchEvent(MotionEvent ev)&#123; if(ev.getAction() == MotionEvent.ACTION_DOWN)&#123; onUserInteraction(); &#125; //交由所附属的Window进行分发 if(getWindow().superDispatchTouchEvent(ev))&#123; return true; &#125; return onTouchEvent(ev);//所有View都没有处理，调用Activity的onTouchEvent() &#125; //Window的分发 //Window # superDispatchTouchEvent public abstract boolean superDispatchTouchEvent(MotionEvent event) //Window的唯一实现是PhoneWindow //PhoneWindow # superDispatchTouchEvent public boolean superDispatchTouchEvent(MotionEvent event)&#123; return mDecor.superDispatchTouchEvent(event); &#125; //DecorView private final class DecorView extends FrameLayout implements RootViewSurfaceTaker&#123; private DecorView mDecor; @Override public final View getDecorView()&#123; if(mDecor == null)&#123; installDecor(); &#125; return mDecor; &#125; &#125; 顶级View对点击事件的分发过程 点击事件到达顶级View(一般是ViewGroup)以后，会调用ViewGroup的dispatchTouchEvent方法，然后如果ViewGroup拦截事件(onInterceptTouchEvent返回true)，则事件由ViewGroup处理，此时如果ViewGroup设置了onTouchListener，则onTouch会被调用，否则调用onTouchEvent，且如果设置了onClickListener，则会调用onClick。如果顶级View不拦截，则事件会传递给它所在的点击事件链上的子View，调用子View的dispatchTouchEvent，如此循环，完成整个事件的分发。 //check for interception # dispatchTouchEvent # ViewGroup final boolean intercepted; if(actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null)&#123; final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if(!disallowIntercept)&#123; intercepted = onInterceptTouchEvent(ev); ev.setAction(action);//restore action in case it was changed &#125;else&#123; intercepted = true; &#125; &#125;else&#123; intercepated = true; &#125; onInterceptTouchEvent不是每次事件都会被调用，当事件能够传递到当前的ViewGroup时，dispatchTouchEvent会每次都调用 FLAG_DISALLOW_INTERCEPT标记可以让ViewGroup不再拦截事件 View对点击事件的处理过程 3.5 View的滑动冲突 常见的滑动冲突场景 外部滑动方向和内部滑动方向不一致 外部滑动方向和内部滑动方向一致 上面两种情况的嵌套 滑动冲突的处理规则 第一种滑动冲突：根据滑动时水平滑动还是竖直滑动来判断由谁拦截事件。 第二种滑动冲突：根据实际业务需求来进行处理 第三种滑动冲突：与第二种一致 滑动冲突的解决方式 外部拦截法 点击事件都先经过父容器的拦截处理，根据父容器的需求即可解决滑动冲突 内部拦截法 父容器不拦截任何事件，所有的事件都传递给子元素，子元素可以直接消耗掉或者交由父容器进行处理。需要配合requestDisallowInterceptTouchEvent方法才能正常工作。]]></content>
      <categories>
        <category>Android开发艺术探索</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发艺术探索学习笔记-第二章]]></title>
    <url>%2F2020%2F07%2F05%2FAndroid%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[Android开发艺术探索 第二章笔记第二章 IPC机制 Android IPC 简介IPC：Inter-Process Communication的缩写，意思为进程间通信或者跨进程通信，指两个进程之间进行数据交换的过程。 线程：CPU调度的最小单元，是一种有限的系统资源。 进程：一般指一个执行单元，在PC和移动设备上指一个程序或者应用。一个进程可以包含多个线程。 Android中的多进程模式 开启多进程模式 在Android中使用多进程只有一个方法，那就是给四大组件在AndroidManifest中指定android:process属性。 进程名以“：”开头的进程属于当前应用的私有进程，其他应用的组件不可以和它在同一进程中，而进程名不以“：”开头的进程属于全局进程，其他应用可以通过ShareUID方式和它在同一进程中。Android系统会为每个应用分配一个唯一的UID，具有相同UID的应用才能共享数据。(两个应用通过ShareUID在同一个进程张，不但ShareUID要相同，签名也必须相同才可以互相访问数据) 多进程模式运行机制 多进程造成的问题： 静态成员和单例模式完全失效。 线程同步机制完全失效。 SharedPreferences的可靠性下降。 Application会多次创建。 在多进程模式中，不同进程的组件会拥有独立的虚拟机，Application以及内存空间。 IPC基础概念介绍 Serializable接口：Java所提供的一个序列化接口，是一个空接口，为对象提供序列化和反序列化操作。 实现只要实现该接口，并且在类的声明中指定下面的标识即可自动实现默认的序列化操作。 public class User implements Serializable&#123; private static final long serialVersionUID = 871136882100083044L private String userName; private boolean isMale; ... 』 //序列化操作 User user = new User("Stephanie",false); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream("cache.txt")); out.writeObject(user); out.close //反序列化操作 ObjectInputStream in = new ObjectInputStream(new FileInputStream("cache.txt")); User user = (User)in.readObject(); in.close(); serialVersionUID工作机制：序列化时系统会将当前类的serialVersionUID写入序列化的文件中，当反序列化时系统会去检测文件中的serialVersionUID，看它是否和当前类的serialVersionUID一致，一致则说明版本相同可以成功反序列化；否则无法正常反序列化 Notice: 静态成员变量属于类不属于对象，所以不会参与序列化过程； 用transient关键字标记的成员变量不参与序列化过程。 通过重写readObject()和writeObject()方法可以改变系统的默认序列化过程。 Parcelable接口：Android提供的新的序列化方式。 //实现Parcelable典型用法 public class User implements Parcelable&#123; public int userId; public String userName; public boolean isMale; public Book book; //构造方法 public User(int UserId,String userName,boolean isMale)&#123; this.userId = userId; this.userName = userName; this.isMale = isMale; &#125; //返回当前对象的内容描述，含文件描述符返回1，否则返回0 public int describeContents()&#123; reaturn 0; &#125; //将当前对象写入序列化结构中，flags标识有两种值(0,1),为1时标识当前对象需要作为返回值返回，不能 //立即释放资源 public void writeToParcel(Parcel out,int flags)&#123; out.writeInt(userId); out.writeString(userName); out.writeInt(isMale ? 1 : 0); out.writeParcelable(book,0); &#125; //实现反序列化功能 public static final Parcelable.Creator&lt;User&gt; CREATER = new Parcelable.Creator&lt;User&gt;()&#123; //从序列化后的对象中创建原始对象 public User createrFromParcel(Parcel in)&#123; return new User(in); &#125; //创建指定长度的原始对象数组 public User[] newArray(int size)&#123; return new User[size]; &#125; &#125;; // private User(Parcel in)&#123; userId = in.readInt(); userName = in.readString(); isMale = in.readInt() == 1; book = in.readParcelable(Thread.currentThread().getContextClassLoader()); &#125; &#125; Parcelable 和Serializable选取： Serializable是Java中的序列化接口，使用简单但需要大量I/O操作，开销很大；Parcelable使用较麻烦但在Android平台上效率很高，所以首选Parcelable接口。 Binder:Binder是Android中的一种跨进程通信方式。在Android开发中，Binder主要用于Service中，包括AIDL和Messenger。 当客户端发起远程请求时，由于当前线程会被挂起直至服务端进程返回数据，所以不能在UI线程中发起耗时的远程请求； 由于服务打的Binder方法运行在Binder的线程池中，所以Binder方法不管是否耗时都应该采用同步的方法去实现。 Binder实现步骤 声明一个AIDL性质的接口，只需继承IInterface接口 实现Stub类和Stub类的Proxy代理类 给Binder设置死亡代理： 声明一个Deathecipient对象。Deathecipient是一个接口，我们需要实现其内部的回调方法binderDied private IBinder.DeathRecipient mDeathRecipient = new IBinder.DeathRecipient()&#123; @Override public void binderDied()&#123; if(mBookManager == null) return; mBookManager.asBinder().unlinkToDeath(mDeathRecipient,0); mBookManager = null; &#125; &#125; 在客户端绑定远程服务成功后，给binder设置死亡代理 mService = IMessageBoxManager.Stub.asInterface(binder); binder.linkToDeath(mDeathRecipient,0); 通过Binderd方法isBinderAlive可以判断Binder是否死亡 Android中IPC方式 使用Bundle 四大组件中的三大组件(Activity，Service，Receiver)都是支持Intent中传递Bundle数据的，由于Bundle实现了Parcelable接口，所以它可以在不同的进程之间传输。但是，传输的数据必须能够被序列化，比如基本类型和实现了Parcelable接口的对象。 使用文件共享 即两个进程通过读/写同一个文件来交换数据。除了可以交换一些文本信息外，还可以序列化一个对象到文件系统的同时另一个进程中恢复这个对象。 //MainActivity private void persistToFile()&#123; new Thread(new Runnable()&#123; @Override public void run()&#123; User user = new User(1,"hello world",false); File dir = new File(MyConstants.CHAPTER_2_PATH); if(!dir.exists())&#123; dir.mkdirs(); &#125; File cachedFile = new File(MyConstants.CACHE_FILE_PATH); ObjectOutputStream objectOutputStream = null; try&#123; objectOutputStream = new ObjectOutputStream(new FileOutputStream(cacheFile)); objectOutputStream.writeObject(user); Log.d(TAG,"persist user : " + user); &#125;catch(IOException e)&#123; e.printStackTrace(); &#125;finally&#123; MyUtils.close(objectOutputStream); &#125; &#125; &#125;).start(); &#125; //SecondActivity private void recoverFromFile()&#123; new Thread(new Runnable()&#123; @Override public void run()&#123; User user = null; File cachedFile = new File(MyConstants.CACHE_FILE_PATH); if(cachedFile.exists())&#123; ObjectInputStream objectInputStream = null; try&#123; objectInputStream = new ObjectInputStream(new FileInputStream( cachedFile)); user = (User) objectInputStream.readObject(); Log.d(TAG,"recover user :"+user); &#125;catch(IOException)&#123; e.printStackTrace(); &#125;catch(ClassNotFoundException e)&#123; e.printStackTrace(); &#125;finally&#123; MyUtils.close(objectInputStream); &#125; &#125; &#125; &#125;).start(); &#125; 文件共享方式适合在对数据同步要求不高的进程之间进行通信，并且要妥善处理并发读/写的问题。 使用Messenger 译为“信使”，可以在Message中放入需要传递的数据，通过它在不同进程中传递Message对象。它的底层实现是AIDL //Messenger的构造方法 public Messenger(Handler target)&#123; mTarget = target.getIMessenger(); &#125; public Messenger(IBinder target)&#123; mTarget = IMessenger.Stub.asInterface(target); &#125; Messenger一次处理一个请求，因此在服务端不用考虑线程同步的问题 实现Messenger的步骤： 服务端进程 首先在服务端创建一个Service来处理客户端的连接请求，同时创建一个Handler并通过它来创建 Messenger对象，然后在Service的onBind中返回Messenger对象底层的Binder。 客户端进程 首先绑定服务端的Service，绑定成功后用服务端返回的IBinder对象创建一个Messenger，通过这个Messenger就可以向服务端发送Message对象。 //服务端 public class MessengerService extends Service&#123; private static final String TAG = "MessengerService"; private static class MessengerHandler extend Handler&#123; @Override public void handleMessage(Message msg)&#123; switch(msg.what)&#123; case MyConstants.MSG_FROM_CLIENT: Log.i(TAG,"receive msg from client : "+msg.getData().getString("msg")); break; default: super.handleMessage(msg); &#125; &#125; &#125; &#125; //注册Service &lt;service android:name = "com.ryg.chapter_2.messenger.MessengerService" android:process = ":remote"&gt; //客户端 public class MessengerActivity extends Activity&#123; private static final String TAG = "MessengerActivity"; private Messenger mService; private ServicerConnection mConnection = new ServiceConnection()&#123; public void onServiceConnected(ComponentName className,IBinder service)&#123; mService = new Messenger(service); Message msg = Message.obtain(null,"MyConstants.MSG_FROM_CLIENT"); Bundle data = new Bundle(); data.putString("msg","hello ,this is client."); msg.setData(data); try&#123; mService.send(msg); &#125;catch(RemoteException e)&#123; e.printStackTrace(); &#125; &#125; public void onServiceDisconnected(ComponentName className)&#123;&#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState)&#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_messenger); Intent intent = new Intent(this,MessengerService.class); bindService(intent,mConnection,Conatext.BIND_AUTO_CREATE); &#125; @Override protected void onDestroy()&#123; unbindService(mConnection); super.onDestroy(); &#125; &#125; 使用AIDL AIDL的使用流程: 服务端 创建一个Service用来监听客户端的连接 创建一个AIDL文件声明给客户端的接口 在Service中实现这个AIDL接口 客户端 需要绑定服务端的Service 绑定成功后将服务端返回的Binder对象转换成AIDL接口所属的类型 AIDL接口的创建 //IBookManager.aidl package com.ryg.chapter_2.aidl import com.ryg.chapter_2.aidl.Book; interface IBookManager&#123; List&lt;Book&gt; getBookList(); void addBook(in Book book); &#125; AIDL文件支持的数据类型 基本数据类型(int , long , char , boolean , double等); String和CharSequence; List:只支持ArrayList,并且里面的每个元素都必须能够被AIDL支持； Map:只支持Hashap，并且里面的每个元素都必须能够被AIDL支持； Parcelabel：所有实现了Parcelable接口的对象； AIDL：所有的AIDL接口本身也可以在AIDL文件中使用。 自定义的Parcelable对象和AIDL对象必须要显式import进来，无论它是否与当前AIDL文件位于同一个包内。 如果AIDL文件中用到了自定义的Parcelable对象，必须新建一个和它同名的AIDL文件，并在其中声明它为Parcelabel类型。 AIDL中除了基本数据类型，其他类型的参数必须标上方向：in，out，inout AIDL中的定向 tag 表示了在跨进程通信中数据的流向,数据流向是针对在客户端中的那个传入方法的对象而言的。 ​ in： 表示数据只能由客户端流向服务端 ​ out：表示数据只能由服务端流向客户端 ​ inout：表示数据可在服务端与客户端之间双向流通 远程服务端Service的实现 //服务端Service public class BookManagerService extends Service&#123; private static final String TAG = "BMS"; //CopyOnWriteArrayList:支持并发读/写。 private CopyOnWriteArrayList&lt;Book&gt; mBookList = new CopyOnWriteArrayList&lt;Book&gt;(); private Binder mBinder = new IBookManager.Stub()&#123; @Override public List&lt;Book&gt; getBookList() throws RemoteException&#123; return mBookList; &#125; @Override public void addBook(Book book)throws RemoteException&#123; mBookList.add(Book); &#125; &#125;; @Override public void onCreate()&#123; super.onCreate(); mBookList.add(new Book(1,"Android")); mBookList.add(new Book(2,"IOS")); &#125; @Override public IBinder onBind(Intent intent)&#123; return mBinder; &#125; &#125; &lt;service android:name=".aidl.BookManagerService" android:process=":remote"/&gt; 客户端的实现 public class BookManagerActivity extends Activity&#123; private static final String TAG = "BookManagerActivity"; private ServiceConnection mConnection = new ServiceConnection()&#123; public void onServiceConnected(ComponentName className,IBinder service)&#123; IBookManager bookManager = IBookManager.Stub.asInterface(service); try&#123; List&lt;Book&gt; list = bookManager.getBookList(); Log.i(TAG,"query book list ,list"+ "type:"+list.getClass().getCanonicalName()); Log.i(TAG,"query book list :"+list.toString()); &#125;catch(RemoteException e)&#123; e.printStackTrace(); &#125; &#125; public void onServiceDisconnected(ComponentName className)&#123;&#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState)&#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_book_manager); Intent intent = new Intent(this,BookManagerService.class); bindService(intent,mConnection,Context.BIND_AUTOCREATE); &#125; @Override protected void onDestroy()&#123; unbindService(mConnection); super.onDestroy(); &#125; &#125; 6. 解除监听 `RemoteCallbackList`是系统提供的用于删除跨进程Listener的接口 //声明RemoteCalbackList private RemoteCallbackList&lt;IOnNewBookListener&gt; mListenerList = new RemoteCallbackList&lt;&gt;(); //修改注册和注销方法 public void registerListener(IOnNewBookListener listener) throws RemoteException&#123; mListener.register(listener); &#125; public void unregisterListener(IOnNewBookListener listener) throws RemoteException&#123; mListener.unregister(listener); &#125; //通知Listener int N = mListenerList.beginBroadcast(); for(int i = 0; i &lt; N; i++) &#123; IOnNewBookListener l = mListenerList.getBroadcastItem(i); if(l != null)&#123; ...... &#125; &#125; mListenerList.finishBroadcast(); &gt; RemoteCallbackList并不是一个List,遍历时必须按照上述流程进行，`beginBroadcast`和`finishBroadcast`必须要配对使用。 &gt; &gt; 客户端的`onServiceConnected`和`onServiceDisconnected`方法都运行在主线程，不能在其中直接调用服务端的耗时方法。 &gt; &gt; `onServiceDiscnnected`在客户端的UI线程中被回调，而`binderDied`在客户端的Binder线程池中被回调 7. 在AIDL中进行权限验证 - 在onBind中进行验证 - 在服务端的onTransact方法中进行验证 使用ContentProvider ContentProvider是Android中提供的用于不同应用间进行数据共享的方式,其底层实现是Binder。 自定义ContentProvider步骤： 继承自ContentProvider类 实现其中的抽象方法：onCreate,query,update,insert,delete和getType。 注册这个类 与query方法不同的是，update,insert和delete方法会引起数据源的改变，需要通过ContentResolver的notifyhange方法进行更新。 要观察一个ContentProvider中的数据变化，可以通过ContentResolver的registerContentObserver方法注册观察者，用unregisterContentObserver来进行解除。 使用Socket Socket，也称为“套接字”，它分为流式套接字和用户数据报套接字，分别对应与网络传输控制层中的TCP和UDP协议。两个进程可以通过Socket来实现信息的传输，Socket本身可以支持传输任意字节流。 Socket连接过程 Binder连接池将每个业务模块的Binder请求统一转发到远程Service中去执行，从而避免了重复创建Service。 选用合适的IPC方式| 名称 | 优点 | 缺点 | 适用场景 || ————— | ——————————— | —————————————- | ———————————- || Bundle | 简单易用 | 只能传输Bundle支持的数据类型 | 四大组件间的进程间通信 || 文件共享 | 简单易用 | 不适合高并发场景，并且无法做到进程间的即时通信 | 无并发访问情形，交换简单的数据实时性不高的场景 || AIDL | 功能强大 | 使用稍复杂，需要处理好线程同步 | 一对多通信且有RPC需求 || Messenger | 功能一般，支持一对多串行通信，支持实时通信 | 不能很好处理高并发，不支持RPC，数据只能通过Message传输Bundle支持的数据类型 | 低并发的一对多即时通信，无RPC需求，或者无须要返回结果的RPC需求 || ContentProvicer | 数据源访问功能强大，支持一对多并发数据共享，可通过Call方法扩展 | 可以理解为受约束的AIDL，主要提供数据源的CRUD操作 | 一对多的进程间的数据共享 || Socket | 功能强大，可以通过网络传输字节流，支持一对多并发实时通信 | 实现细节稍繁琐，不支持直接的RPC | 网络数据交换 |]]></content>
      <categories>
        <category>Android开发艺术探索</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发艺术探索学习笔记(第一章)]]></title>
    <url>%2F2020%2F06%2F27%2FAndroid%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E7%AC%AC%E4%B8%80%E7%AB%A0)%2F</url>
    <content type="text"><![CDATA[Android 开发艺术探索 第一章笔记第一章 Activity 的生命周期和启动模式Activity 的生命周期 典型情况下的生命周期 : 在用户参与的情况下，Activity 所经过的生命周期的改变 onRestart:Activity 正在重新启动。 onCreate:Activity 正在被创建。可以在这个方法中进行初始化工作，比如加载界面布局资源，初始化数据等。 onStart:Activity 正在被启动，此时 Activity 已经可见，但是没有出现在前台，无法和用户进行交互。 onResume:Activity 已经可见，且出现在前台开始活动。 onPause:Activity 正在停止。 onStop:Activity 即将停止，可以做一些回收工作，但不能太耗时。 onDestroy:Activity 即将被销毁，生命周期最后一个回调，可以做一些回收工作和最终资源的释放。 (1) 一个 Activity 第一次启动时的回调为:onCreate-&gt;onStart-&gt;onResume (2)打开新的 Activity 或切换到桌面时的回调为:onPause-&gt;onStop(如果新 Activity 采用了透明主题，则不会调用 onStop) (3)再次回到原 Activity 时的回调为:onRestart-&gt;onStart-&gt;onResume (4)使用 back 键回退时的回调:onPause-&gt;onStop-&gt;onDestroy Remarks:onStart 和 onStop 是从 Activity 是否可见的角度进行回调的;onResume 和 onPause 是从 Activity 是否位于前台的角度。 异常情况下的生命周期 : Activity 被系统回收或者当前设备的 Configuration 发生改变而导致 Activity 被销毁重建 资源相关的系统配置发生改变导致 Activity 被杀死并重新创建 资源内存不足导致低优先级的 Activity 被杀死 Activity 优先级情况(由高到低) 前台 Activity ——正在与用户交互的 Activity，优先级最高 可见但非前台 Activity 后台 Activity ——已经被暂停的 Activity Activity 的启动模式 Activity 的 LaunchMode standard:标准模式。每次启动一个 Activity 都会重新创建一个新的实例，不管这个实例是否已经存在。在这种模式下，谁启动了这个 Activity，那么这个 Activity 就运行在启动它的那个 Activity 所在的栈中。 singleTop:栈顶复用模式。在这种模式下，如果新的 Activity 已经位于任务栈的栈顶，那么此 Activity 不会被重新创建，同时它的 onNewIntent 方法会被回调，并且这个 Activity 的 onCreate,onStart 不会被系统调用;如果新 Activity 的实例已存在但不是位于栈顶，那么新 Activity 仍然会重新创建。 singleTask:栈内复用模式。这是一种单实例模式，在这种模式下，只要 Activity 在一个栈中存在，那么多次启动此 Activity 都不会重新创建实例。 singleInstance:单实例模式。除了具有 singleTask 模式的所有特性外，在这种模式下的 Activity 只能单独地位于一个任务栈中。 TaskAffinity:任务相关性。这个参数标识了一个 Activity 所需要的任务栈的名字，默认情况下为应用的包名。TaskAffinity 属性主要和 singleTask 启动模式或者 AllowTaskReparenting 属性配对使用；任务栈分为前台任务栈和后台任务栈，后台任务栈中的 Activity 处于暂停状态。 给 Activity 指定启动模式 通过 AndroidManifest 文件给 Activity 指定启动模式 &lt;activity android:name="com.ryg.chapter_1.secondActivity" android:configChanges="screenLayout" android:launchMode="singleTask" android:label="@string/app_name"/&gt; 通过在 Intent 中设置标志位为 Activity 指定启动模式 Intent intent = new Intent(); intent.setClass(MainActivity.this,SecondActivity.class); intent.addFlags(Intetn.FLAG_ACTIVITY_NEW_TASK); startActivity(intent); 两种方式的区别： 第二种的优先级要高于第一种，当两种同时存在时，以第二种方式为准； 第一种方式无法直接为 Activity 设定 FLAG_ACTIVITY_CLEAR_TOP 标识，而第二种方式无法为 Activity 指定 singlenstance 模式 Activity的Flags FLAG_ACTIVITY_NEW_TASK:为Activity指定“singleTask”启动模式 FLAG_ACTIVITY_SINGLE_TOP:为Activity指定“singleTop”启动模式 FLAG_ACTIVITY_CLEAR_TOP:具有此标记位的Activity启动时，在同一个任务栈中所有位于它上面的Activity都要出栈 FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS:具有此标记的Activity不会出现在历史Activity的列表中。 IntentFilter 的匹配规则 action(字符串)的匹配规则：Intent 中的 action 必须能够和过滤规则中的 action 匹配，即 action 的字符串值完全一样。一个过滤规则中可以有多个 action，只要 Intent 中的 action 能够和过滤规则中的任何一个 action 相同即可匹配成功。但如果 Intent 中没有指定 action，则匹配失败，并且 action 区分大小写。 category(字符串)的匹配规则：它要求 Intent 中如果含有 category，那么所有的 category 都必须和过滤规则中的其中一个 category 相同。如果 Intent 中没有，仍然可以匹配成功。 data 的匹配规则 结构：由 mimeType 和 URI 两部分组成。其中 mimeType 指的是媒体类型，URI 是资源地址。 &lt;!-- 语法 --&gt; &lt;data android:scheme="string" android:host="string" android:port="string" android:path="string" andrid:pathPattern="string" android:pathPrefix="string" android:mimeType="string" /&gt; &lt;!-- 结构 --&gt; &lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;/[&lt;path&gt;|&lt;pathPrefix&gt;|&lt;pathPattern&gt;] 2. 匹配规则：Intent中必须含有data数据，并且data数据能够完全匹配过滤规则中的某一个data]]></content>
      <categories>
        <category>Android开发艺术探索</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown基本语法速查]]></title>
    <url>%2F2020%2F03%2F27%2FMarkdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E9%80%9F%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[MarkDown基本语法 简介 Markdown是一种轻量级标记语言，创始人为约翰·格鲁伯（英语：John Gruber）。它允许人们使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML（或者HTML）文档。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。 由于Markdown的轻量化、易读易写特性，并且对于图片，图表、数学式都有支持，当前许多网站都广泛使用Markdown来撰写帮助文档或是用于论坛上发表消息。如GitHub、Reddit、Diaspora、Stack Exchange、OpenStreetMap 、SourceForge、简书等，甚至还能被使用来撰写电子书。 ​ —WikiPedia 基本命令 标题 # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 字体 **加粗** *斜体* ~~删除线~~ &lt;u&gt;下划线&lt;/u&gt; `注释` ==高亮== 列表 ## 有序列表 1. 2. 3. ## 无序列表 - - - ## 任务列表 - [ ] 任务1 - [ ] 任务2 - [x] 任务3 引用 &gt; 这是引用部分内容 代码块 ​public static void main(String[] args) &#123; &#125; ​ 表格 | First Header | Second Header | | ------------- | ------------- | | Content Cell | Content Cell | | Content Cell | Content Cell | 目录 [TOC] 链接 超链接 [链接名称](链接地址) - 图片链接 ![图片名称](图片地址) 脚注 You can create footnotes like this[^footnote]. [^footnote]: Here is the *text* of the **footnote**. Emoji表情 :smile: :kissing_smiling_eyes::kissing_smiling_eyes: 视频 &lt;video src=&quot;xxx.mp4&quot; HTML &lt;span style=&quot;color:red&quot;&gt;红色的文本&lt;/span&gt; 绘制结构图 流程图 ## Flowchart.js ​st=&gt;start: Start op=&gt;operation: Your Operation cond=&gt;condition: Yes or No? e=&gt;end st-&gt;op-&gt;cond cond(yes)-&gt;e cond(no)-&gt;op ## Mermaid ​&lt;pre class=&quot;mermaid&quot;&gt; graph LR A[Hard edge] --&gt;B(Round edge) B --&gt; C&#123;Decision&#125; C --&gt;|One| D[Result one] C --&gt;|Two| E[Result two] ​&lt;/pre&gt; 时序图 ## js-sequence ​Alice-&gt;Bob: Hello Bob, how are you? Note right of Bob: Bob thinks Bob--&gt;Alice: I am good thanks! ​ ## Mermaid ​&lt;pre class=&quot;mermaid&quot;&gt; %% Example of sequence diagram sequenceDiagram Alice-&gt;&gt;Bob: Hello Bob, how are you? alt is sick Bob-&gt;&gt;Alice: Not so good :( else is well Bob-&gt;&gt;Alice: Feeling fresh like a daisy end opt Extra response Bob-&gt;&gt;Alice: Thanks for asking end ​&lt;/pre&gt; 甘特图 ## Mermaid ​&lt;pre class=&quot;mermaid&quot;&gt; %% Example with selection of syntaxes gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d ​&lt;/pre&gt; 类图 ## Mermaid ​&lt;pre class=&quot;mermaid&quot;&gt; classDiagram Animal &lt;|-- Duck Animal &lt;|-- Fish Animal &lt;|-- Zebra Animal : +int age Animal : +String gender Animal: +isMammal() Animal: +mate() class Duck{ +String beakColor +swim() +quack() } class Fish{ -int sizeInFeet -canEat() } class Zebra{ +bool is_wild +run() } ​&lt;/pre&gt; 状态图 ​&lt;pre class=&quot;mermaid&quot;&gt; stateDiagram [*] --&gt; Still Still --&gt; [*] Still --&gt; Moving Moving --&gt; Still Moving --&gt; Crash Crash --&gt; [*] ​&lt;/pre&gt; - 饼图 ​&lt;pre class="mermaid"&gt; pie title Pie Chart "Dogs" : 386 "Cats" : 85 "Rats" : 150 ​&lt;/pre&gt; 4. 数学公式 ```markdown ## 行内公式 $ a^2 + b^2 = c^2 $ ## 行间公式 $$ y = x ^ &#123;2&#125; x_&#123;a + b&#125; x^&#123;a + b&#125; $$ 符号 代码 具体含义 $\sum$ $\sum$ 求和公式 $\sum_{i=0}^n$ $\sum_{i=0}^n$ 求和上下标 $\times$ $\times$ 乘号 $\pm$ $\pm$ 正负号 $\div$ $\div$ 除号 $\mid$ $\mid$ 竖线 $\cdot$ $\cdot$ 点 $\circ$ $\circ$ 圈 $\ast $ $\ast $ 星号 $\bigotimes$ $\bigotimes$ 克罗内克积 $\bigoplus$ $\bigoplus$ 异或 $\leq$ $\leq$ 小于等于 $\geq$ $\geq$ 大于等于 $\neq$ $\neq$ 不等于 $\approx$ $\approx$ 约等于 $\prod$ $\prod$ N元乘积 $\coprod$ $\coprod$ N元余积 $\cdots$ $\cdots$ 省略号 $\int$ $\int$ 积分 $\iint$ $\iint$ 双重积分 $\oint$ $\oint$ 曲线积分 $\infty$ $\infty$ 无穷 $\nabla$ $\nabla$ 梯度 $\because$ $\because$ 因为 $\therefore$ $\therefore$ 所以 $\forall$ $\forall$ 任意 $\exists$ $\exists$ 存在 $\not=$ $\not=$ 不等于 $\not&gt;$ $\not&gt;$ 不大于 $\leq$ $\leq$ 小于等于 $\geq$ $\geq$ 大于等于 $\not\subset$ $\not\subset$ 不属于 $\emptyset$ $\emptyset$ 空集 $\in$ $\in$ 属于 $\notin$ $\notin$ 不属于 $\subset$ $\subset$ 子集 $\subseteq$ $\subseteq$ 真子集 $\bigcup$ $\bigcup$ 并集 $\bigcap$ $\bigcap$ 交集 $\bigvee$ $\bigvee$ 逻辑或 $\bigwedge$ $\bigwedge$ 逻辑与 $\alpha$ $\alpha$ $\beta$ $\beta$ $\gamma$ $\gamma$ $\Gamma$ $\Gamma$ $\delta$ $\delta$ $\Delta$ $\Delta$ $\epsilon$ $\epsilon$ $\varepsilon$ $\varepsilon$ $\zeta$ $\zeta$ $\eta$ $\eta$ $\theta$ $\theta$ $\Theta$ $\Theta$ ϑ $\vartheta$ ι $\iota$ π $\pi$ ϕ $\phi$ Φ $\Phi$ ψ $\psi$ Ψ $\Psi$ ω $\omega$ Ω $\Omega$ χ \chi ρ $\rho$ ο $\omicron$ σ $\sigma$ Σ $\Sigma$ ν $\nu$ ξ $\xi$ τ $\tau$ λ $\lambda$ Λ $\Lambda$ μ \mu ∂ $\partial$ {} $\lbrace \rbrace$ a $\overline{a}$ ​]]></content>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ProtocolBuffers-基本使用]]></title>
    <url>%2F2020%2F03%2F12%2FProtocolBuffers-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Protocol Buffers​ 一种跨语言，跨平台的可扩展的序列化数据格式 相比XML的优势 更简单 更轻量（数据体积小3~10倍） 更快速（20～100倍） 自动化生成更易于编码方式使用的数据访问类 使用方法 graph TD; A[定义protobuf消息格式] --> B[编译protobuf]; B --> C[使用protobuf API进行读写]; 使用protobuf语法描述需要存储的数据结构（编写．proto文件） syntax = "proto3"; //默认为proto2,不能为空 package tutorial; //避免命名冲突 option java_package = "com.example.tutorial"; //生成类的包结构 option java_outer_classname = "AddressBookProtos"; //生成包括当前文件所有类的类名，默认是MyProto,生成my_proto.proto，不能与内部定义的类名称相同（不能设为AddressBook） message Person &#123; string name = 1; //用于二进制编码的唯一标识 int32 id = 2; string email = 3; enum PhoneType &#123; MOBILE = 0; //必须包含标识０，用于设置默认值和与proto2语义兼容 HOME = 1; WORK = 2; &#125; message PhoneNumber &#123; string number = 1; PhoneType type = 2 [packed = HOME]; &#125; PhoneNumber phones = 4; &#125; message AddressBook &#123; Person people = 1; &#125; 基本语法（proto3）： 消息是各种类型数据的集合， 可以包含bool,int32,float,double,string,枚举或者其他的消息 标识的范围为1 ~ 2^29^ - 1,1~15的标识比较高的数字少一个字节进行编码，适宜一些常用或者重复的字段;16以上的适用不太常使用的可选字段;19000 ~ 19999不可使用，为内置保留． 每个字段都必须标明注解： required:该字段必须设置值，否则该消息将被视为“未初始化”,构建未初始化的消息将抛出RuntimeException,解析未初始化的消息将抛出IOException;除此之外与optional一致 optional:该字段是可选字段，可以设置值也可以不设置值。如果不设置值，则使用默认值． repeated:该字段可以重复任意次数（包括零），重复值的顺序将保留在protobuf中。可将其视为动态大小的数组． Any字段： &gt; import "google/protobuf/any.proto"; &gt; &gt; message ErrorStatus &#123; &gt; string message = 1; &gt; google.protobuf.Any details = 2; &gt; &#125; &gt; Oneof字段： 一个.proto文件中可以定义多种消息 每个message类以及它的子类有自己的builder类 ，通过builder类来进行设置 数据类型 不能在proto3中直接导入proto2的枚举进行使用，要导入其消息． Map类型 &gt; map&lt;key_type, value_type&gt; map_field = N; &gt; map&lt;string, Project&gt; projects = 3; &gt; 1. `key_type` 可以是任何 int 或者 string 类型(任何的标量类型，具体可以见上面标量类型对应表格，但是要除去 float、double 和 bytes) 2. `value_type` 可以是除去 map 以外的任何类型。 定义service 如果要使用 RPC（远程过程调用）系统的消息类型，可以在 .proto 文件中定义 RPC 服务接口，protocol buffer 编译器将使用所选语言生成服务接口代码和 stubs &gt; //参数为SearchRequest,返回值为SearchResponse &gt; service SearchService &#123; &gt; rpc Search (SearchRequest) returns (SearchResponse); &gt; &#125; &gt; JSON Map 如果一个值在json编码的数据中丢失或者它的值是null, 在被解析成protocol buffer时它将设置为对应的默认值.如果一个字段的值正好是protocol buffer的默认值, 这个字段默认就不会出现在json编码的数据中以便节约空间. 通过protobuf编译器编译．proto文件（生成对应平台的文件） 使用命令 ##命令格式 protoc [option] PROTO_FILES ##Java protoc -I=$SRC_DIR --java_out=$DST_DIR $SRC_DIR/addressbook.proto ##Python protoc -I=$SRC_DIR --python_out=$DST_DIR $SRC_DIR/addressbook.proto SRC_DIR:源代码路径，默认为当前文件夹 DST_DIR:生成的代码路径，默认与SRC_DIR相同 –Java_out:生成不同语言对应的文件 对于Android使用Java Lite可以减小生成类的体积 1.安装java_lite环境 2.编译java_lite版文件 &gt; protoc --javalite_out=$DST_DIR PROTO_FILES &gt; 使用Android Studio 安装Protocol Support插件 配置gradle 编写．proto文件 编译项目 使用protobuf进行数据读写 除了访问器，生成的类中还有其它的方法： 消息构建接口 isInitialized():检测 所有required的字段是否有被设置 toString(): 生成可读的字符串 mergeFrom(Message other): (builder only)与另一个消息进行合并 clear(): (builder only) 将所有字段清除为空状态 解析接口 byte[] toByteArray();: 序列化数据 static Person parseFrom(byte[] data);: 反序列化数据 void writeTo(OutputStream output);: 序列化数据并写入OutputStream static Person parseFrom(InputStream input);: 从InputStream中解析读取消息 具体Demo 兼容处理 如果要让新版本向后兼容，旧版本向前兼容，需要遵守以下规则 不能修改已存在字段的标识（tag） 不能添加或删除required字段 可以删除optional或repeated字段 可以增加optional或repeated字段，但必须使用没有用过的标识，已经删除的也不能用]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo基本命令]]></title>
    <url>%2F2020%2F03%2F10%2FHexo%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[inithexo init [folder] 新建一个网站 hexo newhexo new [layout] &lt;title&gt; 新建一个title.md文档 hexo generate(hexo g) 选项 描述 -d, –deploy 文件生成后立即部署网站 -w, –watch 监视文件变动 -b, –bail 生成过程中如果发生任何未处理的异常则抛出异常 -f, –force 强制重新生成文件 Hexo 引入了差分机制，如果 public 目录存在，那么 hexo g 只会重新生成改动的文件。 使用该参数的效果接近 hexo clean &amp;&amp; hexo generate -c, –concurrency 最大同时生成文件的数量，默认无限制 生成网站静态文件到默认设置的 public 文件夹 publishhexo publish [layout] &lt;fileName&gt; 发表草稿 hexo server(hexo s) 启动服务器，默认网址为http://localhost:4000/ 项 描述 -p, –port 重设端口 -s, –static 只使用静态文件 -l, –log 启动日记记录，使用覆盖记录格式 hexo deploy(hexo d) 部署网站到服务器 参数 描述 -g, –generate 部署之前预先生成静态文件 hexo clean 清除缓存文件 (db.json) 和已生成的静态文件 (public)。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
