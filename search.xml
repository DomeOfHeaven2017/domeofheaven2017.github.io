<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[剑指Offer-14-I-剪绳子]]></title>
    <url>%2F2020%2F04%2F09%2F%E5%89%91%E6%8C%87Offer-14-I-%E5%89%AA%E7%BB%B3%E5%AD%90%2F</url>
    <content type="text"><![CDATA[(14-I)剪绳子问题描述给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]...k[m] 。请问 k[0]*k[1]*...*k[m] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。 示例 1： 输入: 2 输出: 1 解释: 2 = 1 + 1, 1 × 1 = 1 示例 2: 输入: 10 输出: 36 解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36 提示： 2 &lt;= n &lt;= 58 解题思路 动态规划 贪心算法 代码/** * 面试题14-I * 剪绳子 * @param n 绳子长度 * @return 最大乘积 */ //动态规划 public int cuttingRope(int n) { if (n &lt;= 2) { return 1; } if (n == 3) { return 2; } int[] rope = new int[n + 1]; int max = 0; rope[0] = 0; rope[1] = 1; rope[2] = 2; rope[3] = 3; for (int i = 4 ; i &lt;= n ; i ++) { for (int j = 1 ; j &lt;= i / 2 ; j ++){ int temp = rope[j]*rope[i-j]; if (max &lt; temp) { max = temp; } } rope[i] = max; } return rope[n]; } //贪心算法 public int cuttingRope(int n) { if (n &lt;= 2) { return 1; } if (n == 3) { return 2; } int time3 = n / 3; if (n - 3 * time3 == 1) { time3 -= 1; } int time = n - 3 * time3; if (time == 0) { return (int) Math.pow(3, time3); } else { return (int) (Math.pow(3, time3) * time); } }]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>贪心算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-27-移除元素]]></title>
    <url>%2F2020%2F04%2F08%2FLeetCode-27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[(27)移除元素题目描述:给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2: 给定 nums = [0,1,2,2,3,0,4,2], val = 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。 注意这五个元素可为任意顺序。 你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: // nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝 int len = removeElement(nums, val); // 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。 for (int i = 0; i &lt; len; i++) { print(nums[i]); } 解题思路: 声明两个变量first,last first : 数组遍历位置 last : 元素替换位置 遍历数组如果匹配到所给值则将当前位置的数组元素和last位置的数组元素进行交换,最后返回last + 1 代码://Java public int removeElement(int[] nums, int val) { int first = 0; int last = nums.length -1; while(first &lt;= last){ if(nums[first] == val){ int temp = nums[first]; nums[first] = nums[last]; nums[last] = temp; last -= 1; }else{ first += 1; } } return last + 1; } //Kotlin #Python3 def removeElement(nums: List[int], val: int) -&gt; int: first,last = 0,len(nums) - 1 while first &lt;= last: if nums[first] == val: nums[first],nums[last] = nums[last],nums[first] last -= 1 else: first +=1 return last + 1]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序员面试宝典(16.01)-交换数字]]></title>
    <url>%2F2020%2F04%2F05%2F%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8(16.01)-%E4%BA%A4%E6%8D%A2%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[(16.01)交换数字问题描述编写一个函数，不用临时变量，直接交换numbers = [a, b]中a与b的值。 示例： 输入: numbers = [1,2] 输出: [2,1] 提示： numbers.length == 2 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/swap-numbers-lcci 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 根据相同的两个数异或之后会抵消的规律即可解决 $ xor = a \bigoplus b$ $a = xor \bigoplus a$ $b = xor \bigoplus b$ 代码/** * 面试题16.01 * 交换数字 * @param numbers 源数组 * @return 交换后的数组 */ public static int[] swapNumbers(int[] numbers) { int[] result = new int[2]; int xor = numbers[0] ^ numbers[1]; result[0] = xor ^ numbers[0]; result[1] = xor ^ numbers[1]; return result; }]]></content>
      <tags>
        <tag>算法</tag>
        <tag>程序员面试宝典</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown基本语法速查]]></title>
    <url>%2F2020%2F03%2F27%2FMarkdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E9%80%9F%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[MarkDown基本语法 简介 Markdown是一种轻量级标记语言，创始人为约翰·格鲁伯（英语：John Gruber）。它允许人们使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML（或者HTML）文档。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。 由于Markdown的轻量化、易读易写特性，并且对于图片，图表、数学式都有支持，当前许多网站都广泛使用Markdown来撰写帮助文档或是用于论坛上发表消息。如GitHub、Reddit、Diaspora、Stack Exchange、OpenStreetMap 、SourceForge、简书等，甚至还能被使用来撰写电子书。 ​ —WikiPedia 基本命令 标题 # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 字体 **加粗** *斜体* ~~删除线~~ &lt;u&gt;下划线&lt;/u&gt; `注释` ==高亮== 列表 ## 有序列表 1. 2. 3. ## 无序列表 - - - ## 任务列表 - [ ] 任务1 - [ ] 任务2 - [x] 任务3 引用 &gt; 这是引用部分内容 代码块 ​```java public static void main(String[] args) { } ​ ` 表格 | First Header | Second Header | | ------------- | ------------- | | Content Cell | Content Cell | | Content Cell | Content Cell | 目录 [TOC] 链接 超链接 [链接名称](链接地址) 图片链接 ![图片名称](图片地址) 脚注 You can create footnotes like this[^footnote]. [^footnote]: Here is the *text* of the **footnote**. Emoji表情 :smile: :kissing_smiling_eyes::kissing_smiling_eyes: 视频 &lt;video src=&quot;xxx.mp4&quot; HTML &lt;span style=&quot;color:red&quot;&gt;红色的文本&lt;/span&gt; 绘制结构图 流程图 ## Flowchart.js ​```flow st=&gt;start: Start op=&gt;operation: Your Operation cond=&gt;condition: Yes or No? e=&gt;end st-&gt;op-&gt;cond cond(yes)-&gt;e cond(no)-&gt;op ​ Mermaid​ graph LRA[Hard edge] –&gt;B(Round edge) B --&gt; C{Decision} C --&gt;|One| D[Result one] C --&gt;|Two| E[Result two] ​` 时序图 ## js-sequence ​```sequence Alice-&gt;Bob: Hello Bob, how are you? Note right of Bob: Bob thinks Bob--&gt;Alice: I am good thanks! ​ Mermaid​ %% Example of sequence diagram sequenceDiagram Alice-&gt;&gt;Bob: Hello Bob, how are you? alt is sick Bob-&gt;&gt;Alice: Not so good :( else is well Bob-&gt;&gt;Alice: Feeling fresh like a daisy end opt Extra response Bob-&gt;&gt;Alice: Thanks for asking end ​` 甘特图 ## Mermaid ​&lt;pre class=&quot;mermaid&quot;&gt; %% Example with selection of syntaxes gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d ​&lt;/pre&gt; 类图 ## Mermaid ​&lt;pre class=&quot;mermaid&quot;&gt; classDiagram Animal &lt;|-- Duck Animal &lt;|-- Fish Animal &lt;|-- Zebra Animal : +int age Animal : +String gender Animal: +isMammal() Animal: +mate() class Duck{ +String beakColor +swim() +quack() } class Fish{ -int sizeInFeet -canEat() } class Zebra{ +bool is_wild +run() } ​&lt;/pre&gt; 状态图 ​&lt;pre class=&quot;mermaid&quot;&gt; stateDiagram [*] --&gt; Still Still --&gt; [*] Still --&gt; Moving Moving --&gt; Still Moving --&gt; Crash Crash --&gt; [*] ​&lt;/pre&gt; 饼图 ​&lt;pre class=&quot;mermaid&quot;&gt; pie title Pie Chart &quot;Dogs&quot; : 386 &quot;Cats&quot; : 85 &quot;Rats&quot; : 150 ​&lt;/pre&gt; 数学公式 ## 行内公式 $ a^2 + b^2 = c^2 $ ## 行间公式 $$ y = x ^ {2} x_{a + b} x^{a + b} $$ | 符号 | 代码 | 具体含义 || ——————————————– | ——————— | ———- || $\sum$ | $\sum$ | 求和公式 || $\sum_{i=0}^n$ | $\sum_{i=0}^n$ | 求和上下标 || $\times$ | $\times$ | 乘号 || $\pm$ | $\pm$ | 正负号 || $\div$ | $\div$ | 除号 || $\mid$ | $\mid$ | 竖线 || $\cdot$ | $\cdot$ | 点 || $\circ$ | $\circ$ | 圈 || $\ast $ | $\ast $ | 星号 || $\bigotimes$ | $\bigotimes$ | 克罗内克积 || $\bigoplus$ | $\bigoplus$ | 异或 || $\leq$ | $\leq$ | 小于等于 || $\geq$ | $\geq$ | 大于等于 || $\neq$ | $\neq$ | 不等于 || $\approx$ | $\approx$ | 约等于 || $\prod$ | $\prod$ | N元乘积 || $\coprod$ | $\coprod$ | N元余积 || $\cdots$ | $\cdots$ | 省略号 || $\int$ | $\int$ | 积分 || $\iint$ | $\iint$ | 双重积分 || $\oint$ | $\oint$ | 曲线积分 || $\infty$ | $\infty$ | 无穷 || $\nabla$ | $\nabla$ | 梯度 || $\because$ | $\because$ | 因为 || $\therefore$ | $\therefore$ | 所以 || $\forall$ | $\forall$ | 任意 || $\exists$ | $\exists$ | 存在 || $\not=$ | $\not=$ | 不等于 || $\not&gt;$ | $\not&gt;$ | 不大于 || $\leq$ | $\leq$ | 小于等于 || $\geq$ | $\geq$ | 大于等于 || $\not\subset$ | $\not\subset$ | 不属于 || $\emptyset$ | $\emptyset$ | 空集 || $\in$ | $\in$ | 属于 || $\notin$ | $\notin$ | 不属于 || $\subset$ | $\subset$ | 子集 || $\subseteq$ | $\subseteq$ | 真子集 || $\bigcup$ | $\bigcup$ | 并集 || $\bigcap$ | $\bigcap$ | 交集 || $\bigvee$ | $\bigvee$ | 逻辑或 || $\bigwedge$ | $\bigwedge$ | 逻辑与 || $\alpha$ | $\alpha$ | || $\beta$ | $\beta$ | || $\gamma$ | $\gamma$ | || $\Gamma$ | $\Gamma$ | || $\delta$ | $\delta$ | || $\Delta$ | $\Delta$ | || $\epsilon$ | $\epsilon$ | || $\varepsilon$ | $\varepsilon$ | || $\zeta$ | $\zeta$ | || $\eta$ | $\eta$ | || $\theta$ | $\theta$ | || $\Theta$ | $\Theta$ | || ϑ | $\vartheta$ | || ι | $\iota$ | || π | $\pi$ | || ϕ | $\phi$ | || Φ | $\Phi$ | || ψ | $\psi$ | || Ψ | $\Psi$ | || ω | $\omega$ | || Ω | $\Omega$ | || χ | \chi | || ρ | $\rho$ | || ο | $\omicron$ | || σ | $\sigma$ | || Σ | $\Sigma$ | || ν | $\nu$ | || ξ | $\xi$ | || τ | $\tau$ | || λ | $\lambda$ | || Λ | $\Lambda$ | || μ | \mu | || ∂ | $\partial$ | || {} | $\lbrace \rbrace$ | || a | $\overline{a}$ | | ​]]></content>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer-11-旋转数组的的最小数字]]></title>
    <url>%2F2020%2F03%2F23%2F%E5%89%91%E6%8C%87Offer-11-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[(11)旋转数组的最小数字问题描述把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。 示例 1： 输入：[3,4,5,1,2] 输出：1 示例 2： 输入：[2,2,2,0,1] 输出：0 解题思路 注意题目中的递增排序的数组，则可以理解为所给数组由两部分组成，每个部分内部都是递增排序的，取得这两个部分里面的最小值即可 遍历取得最小值，复杂度$O(n)$ 二分法查找，复杂度$O(log(n))$ 代码/** * 面试题11 * 旋转数组的最小数字 * @param numbers 所给数组 * @return 最小数字 */ public int minArray(int[] numbers) { int l = 0, h = numbers.length - 1; while (l &lt; h) { int mid = (( h - l ) &gt;&gt; 2 ) + l; if (numbers[h] &gt; numbers[mid]) { h = mid; } else if (numbers[h] &lt; numbers[mid]) { l = mid + 1; } else { h -- ; } } return numbers[l]; }]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>剑指Offer</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer-10-II-青蛙跳台阶问题]]></title>
    <url>%2F2020%2F03%2F16%2F%E5%89%91%E6%8C%87Offer-10-II-%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[(10-II)青蛙跳台阶问题问题描述一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 示例 1： 输入：n = 2 输出：2 示例 2： 输入：n = 7 输出：21 提示： 0 &lt;= n &lt;= 100 解题思路 从后往前思考，即最好一步有两种跳法, 跳一步，则前面有$f(n-1)$种跳法 跳两步，则前面有$f(n-2)$种跳法 则n级台阶的跳法有$f(n) = f(n-1) + f(n-2)$种跳法，与斐波那契数列的递推公式一致 代码/** * 面试题10-II * 青蛙跳台阶问题 * @param n n级台阶 * @return n级台阶的跳法 */ public static int numWays(int n) { if (n &lt;= 1) { return 1; } long num1 = 0, num2 = 1; long temp = 0; int i = 0; while (i &lt; n) { temp = (num1 + num2)%1000000007; num1 = num2; num2 = temp; i ++; } return (int) temp; }]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>剑指Offer</tag>
        <tag>Fibonacci</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer-10-I-斐波那契数列]]></title>
    <url>%2F2020%2F03%2F16%2F%E5%89%91%E6%8C%87Offer-10-I-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%2F</url>
    <content type="text"><![CDATA[(10)斐波那契数列问题描述写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下： F(0) = 0, F(1) = 1 F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1. 斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 示例 1： 输入：n = 2 输出：1 示例 2： 输入：n = 5 输出：5 提示： 0 &lt;= n &lt;= 100 解题思路 递归法：方法简洁，但是由于中间重复计算，会超时 循环法：从0开始计算可以记录中间值，避免进行重复计算 公式法：根据 $F_n = \frac{(\frac{1+\sqrt[]{5}}{2})^n -(\frac{1-\sqrt[]{5}}{2})^n}{\sqrt[]{5}}$,但是大数会有误差 代码/** * 面试题10-I * 斐波那契数列 * @param n 所求第n项 * @return 斐波那契数列第n项 */ public static final long THRES_HOLD = 1000000007; public static int fib(int n) { //递归法 if (n &lt; 1) { return n; } return (fib(n - 1) + fib(n - 2)) % THRES_HOLD; //循环法 if (n &lt;= 1) { return n; } long num1 = 0, num2 = 1; long temp = 0; int i = 2; while (i &lt;= n) { temp = (num1 + num2)%THRES_HOLD; num1 = num2; num2 = temp; i ++; } return (int) temp; //公式法 double temp = Math.sqrt(5); return (int) ((Math.pow((1 + temp) / 2, n) - Math.pow((1 - temp) / 2, n)) / temp % THRES_HOLD) ; }]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>剑指Offer</tag>
        <tag>Fibonacci</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer-09-用两个栈实现队列]]></title>
    <url>%2F2020%2F03%2F14%2F%E5%89%91%E6%8C%87Offer-09-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[(09)用两个栈实现队列问题描述用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 ) 示例 1： 输入： [&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;] [[],[3],[],[]] 输出：[null,null,3,-1] 示例 2： 输入： [&quot;CQueue&quot;,&quot;deleteHead&quot;,&quot;appendTail&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;] [[],[],[5],[2],[],[]] 输出：[null,-1,null,null,5,2] 提示： 1 &lt;= values &lt;= 10000 最多会对 appendTail、deleteHead 进行 10000 次调用 解题思路 首先必须记住栈的特点是：先进后出；队列的特点是先入先出 以此为基础则数据分别从两个栈先后进入弹出则可以实现队列的特点。 核心思想是两个栈一个为输出栈，一个为输入栈，在插入数据时可以直接将数据压到输入栈中；在删除头数据时就需要对不同情况进行分别处理： 1.输出栈不为空：直接弹出 2.输出栈为空，输入栈不为空：先将输入栈中的数据压到输出栈中，再从输出栈中弹出数据 3.输出栈为孔，输入栈为孔：则整个队列无数据，直接返回-1 代码class CQueue { //输入,用于数据插入 private Stack&lt;Integer&gt; inStack; //输出栈，用于将尾部数据弹出 private Stack&lt;Integer&gt; outStack; public CQueue() { inStack = new Stack&lt;&gt;(); outStack = new Stack&lt;&gt;(); } /** * 从尾部插入，则直接将数据压到输入当中 * @param value 压入数据 */ public void appendTail(int value) { inStack.push(value); } /** * 从头部删除，由于需要保持队列的顺序需要注意输入和输出栈之中的数据 * @return 删除元素 */ public int deleteHead() { //如果输出栈中有元素，则直接弹出 if (!outStack.isEmpty()) { return outStack.pop(); } //如果输出栈不为空且输入栈也不为空，就需要将输入栈中数据全部压到输出栈中以保持其顺序正确 while (!inStack.isEmpty()) { outStack.push(inStack.pop()); } return outStack.isEmpty() ? -1 : outStack.pop(); } }class CQueue { //输入,用于数据插入 private Stack&lt;Integer&gt; inStack; //输出栈，用于将尾部数据弹出 private Stack&lt;Integer&gt; outStack; public CQueue() { inStack = new Stack&lt;&gt;(); outStack = new Stack&lt;&gt;(); } /** * 从尾部插入，则直接将数据压到输入当中 * @param value 压入数据 */ public void appendTail(int value) { inStack.push(value); } /** * 从头部删除，由于需要保持队列的顺序需要注意输入和输出栈之中的数据 * @return 删除元素 */ public int deleteHead() { //如果输出栈中有元素，则直接弹出 if (!outStack.isEmpty()) { return outStack.pop(); } //如果输出栈不为空且输入栈也不为空，就需要将输入栈中数据全部压到输出栈中以保持其顺序正确 while (!inStack.isEmpty()) { outStack.push(inStack.pop()); } return outStack.isEmpty() ? -1 : outStack.pop(); } }]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ProtocolBuffers-基本使用]]></title>
    <url>%2F2020%2F03%2F12%2FProtocolBuffers-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Protocol Buffers​ 一种跨语言，跨平台的可扩展的序列化数据格式 相比XML的优势 更简单 更轻量（数据体积小3~10倍） 更快速（20～100倍） 自动化生成更易于编码方式使用的数据访问类 使用方法 graph TD; A[定义protobuf消息格式] --> B[编译protobuf]; B --> C[使用protobuf API进行读写]; 使用protobuf语法描述需要存储的数据结构（编写．proto文件） syntax = &quot;proto3&quot;; //默认为proto2,不能为空 package tutorial; //避免命名冲突 option java_package = &quot;com.example.tutorial&quot;; //生成类的包结构 option java_outer_classname = &quot;AddressBookProtos&quot;; //生成包括当前文件所有类的类名，默认是MyProto,生成my_proto.proto，不能与内部定义的类名称相同（不能设为AddressBook） message Person { string name = 1; //用于二进制编码的唯一标识 int32 id = 2; string email = 3; enum PhoneType { MOBILE = 0; //必须包含标识０，用于设置默认值和与proto2语义兼容 HOME = 1; WORK = 2; } message PhoneNumber { string number = 1; PhoneType type = 2 [packed = HOME]; } PhoneNumber phones = 4; } message AddressBook { Person people = 1; } 基本语法（proto3）： 消息是各种类型数据的集合， 可以包含bool,int32,float,double,string,枚举或者其他的消息 标识的范围为1 ~ 2^29^ - 1,1~15的标识比较高的数字少一个字节进行编码，适宜一些常用或者重复的字段;16以上的适用不太常使用的可选字段;19000 ~ 19999不可使用，为内置保留． 每个字段都必须标明注解： required:该字段必须设置值，否则该消息将被视为“未初始化”,构建未初始化的消息将抛出RuntimeException,解析未初始化的消息将抛出IOException;除此之外与optional一致 optional:该字段是可选字段，可以设置值也可以不设置值。如果不设置值，则使用默认值． repeated:该字段可以重复任意次数（包括零），重复值的顺序将保留在protobuf中。可将其视为动态大小的数组． Any字段： import &quot;google/protobuf/any.proto&quot;; message ErrorStatus { string message = 1; google.protobuf.Any details = 2; } Oneof字段： 一个.proto文件中可以定义多种消息 每个message类以及它的子类有自己的builder类 ，通过builder类来进行设置 数据类型 不能在proto3中直接导入proto2的枚举进行使用，要导入其消息． Map类型 map&lt;key_type, value_type&gt; map_field = N; map&lt;string, Project&gt; projects = 3; key_type 可以是任何 int 或者 string 类型(任何的标量类型，具体可以见上面标量类型对应表格，但是要除去 float、double 和 bytes) value_type 可以是除去 map 以外的任何类型。 定义service 如果要使用 RPC（远程过程调用）系统的消息类型，可以在 .proto 文件中定义 RPC 服务接口，protocol buffer 编译器将使用所选语言生成服务接口代码和 stubs //参数为SearchRequest,返回值为SearchResponse service SearchService { rpc Search (SearchRequest) returns (SearchResponse); } JSON Map 如果一个值在json编码的数据中丢失或者它的值是null, 在被解析成protocol buffer时它将设置为对应的默认值.如果一个字段的值正好是protocol buffer的默认值, 这个字段默认就不会出现在json编码的数据中以便节约空间. 通过protobuf编译器编译．proto文件（生成对应平台的文件） 使用命令 ##命令格式 protoc [option] PROTO_FILES ##Java protoc -I=$SRC_DIR --java_out=$DST_DIR $SRC_DIR/addressbook.proto ##Python protoc -I=$SRC_DIR --python_out=$DST_DIR $SRC_DIR/addressbook.proto SRC_DIR:源代码路径，默认为当前文件夹 DST_DIR:生成的代码路径，默认与SRC_DIR相同 –Java_out:生成不同语言对应的文件 对于Android使用Java Lite可以减小生成类的体积 1.安装java_lite环境 2.编译java_lite版文件 protoc --javalite_out=$DST_DIR PROTO_FILES 使用Android Studio 安装Protocol Support插件 配置gradle 编写．proto文件 编译项目 使用protobuf进行数据读写 除了访问器，生成的类中还有其它的方法： 消息构建接口 isInitialized():检测 所有required的字段是否有被设置 toString(): 生成可读的字符串 mergeFrom(Message other): (builder only)与另一个消息进行合并 clear(): (builder only) 将所有字段清除为空状态 解析接口 byte[] toByteArray();: 序列化数据 static Person parseFrom(byte[] data);: 反序列化数据 void writeTo(OutputStream output);: 序列化数据并写入OutputStream static Person parseFrom(InputStream input);: 从InputStream中解析读取消息 具体Demo 兼容处理 如果要让新版本向后兼容，旧版本向前兼容，需要遵守以下规则 不能修改已存在字段的标识（tag） 不能添加或删除required字段 可以删除optional或repeated字段 可以增加optional或repeated字段，但必须使用没有用过的标识，已经删除的也不能用]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer-06-从尾到头打印链表]]></title>
    <url>%2F2020%2F03%2F12%2F%E5%89%91%E6%8C%87Offer-06-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[(06)从尾到头打印链表问题描述输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。 示例 1： 输入：head = [1,3,2] 输出：[2,3,1] 限制： 0 &lt;= 链表长度 &lt;= 10000 解题思路 问题难点在于链表无法知道长度，以及无法进行随机访问 使用栈或类似栈先进后出机制的数据结构来保存链表遍历的结果，最后将结果转换成数组即可，由于Java中有装箱拆箱机制，所以会增加耗时 遍历两次链表，第一次取得链表的长度，以此来初始化数组长度；第二次遍历利用数组可以随机访问的特点，从数组的尾到头进行赋值。 代码public int[] reversePrint(ListNode head) { int count = 0; ListNode temp = head; while (temp != null) { count ++; temp = temp.next; } int[] result = new int[count]; while (head != null) { result[count - 1] = head.val; count -- ; head = head.next; } return result; }]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer-05-替换空格]]></title>
    <url>%2F2020%2F03%2F12%2F%E5%89%91%E6%8C%87Offer-05-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[(05)替换空格问题描述请实现一个函数，把字符串 s 中的每个空格替换成&quot;%20&quot;。 示例 1： 输入：s = &quot;We are happy.&quot; 输出：&quot;We%20are%20happy.&quot; 限制： 0 &lt;= s 的长度 &lt;= 10000 解题思路 1.遍历字符串，遇到空格就加入“%20”，遇到非空格直接加入。 2.通过正则表达式进行匹配替换（java中的replace API，但是提交发现比较耗时） 代码public static String replaceSpace(String s) { StringBuilder sb = new StringBuilder(s.length() * 3); for (char c : s.toCharArray()) { if (c == &#39; &#39;){ sb.append(&quot;%20&quot;); } else { sb.append(c); } } return sb.toString(); // return s.replaceAll(&quot; &quot;, &quot;%20&quot;); }]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(剑指Offer-04)二维数组中的查找]]></title>
    <url>%2F2020%2F03%2F11%2F(%E5%89%91%E6%8C%87Offer-03)%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[(04)二维数组中的查找问题描述在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 示例: 现有矩阵 matrix 如下： [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] 给定 target = 5，返回 true。 给定 target = 20，返回 false。 限制： 0 &lt;= n &lt;= 1000 0 &lt;= m &lt;= 1000 解题思路 最简单的就是使用暴力破解，遍历进行比较，但这会使复杂度达到$O(n *m)$ 仔细阅读题目可以看到该数组是有规律的，即每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序,利用这个规律，可以减少比较的次数。 根据这个规律，我们可以得到该二维数组左下角的值($matrix[n - 1][0]$)为该列的最大值，也是该行的最小值;右上角的值($matrix[0][m - 1]$)为该行的最大值，也是该列的最小值。可以从这两个位置出发，遵循一下原则(从左下角开始为例)： 如果$matrix[i][j] &gt; target$则该值的行肯定小于i,所以可以直接跳到上一行，即i++ 如果$matrix[i][j] &lt; target$则该值的列一定大于j，所以可以从该行往后找，即j-- 如果$matrix[i][j] == target$则找到了该值 代码/** * 面试题04 二维数组中的查找 * @param matrix 二维数组 * @param target 目标数字 * @return 目标数字是否存在 */ //从左下角开始查找 public boolean findNumberIn2DArray(int[][] matrix, int target) { if (matrix == null) return false; int m = matrix.length; if (m == 0) return false; int n = matrix[0].length; int i = m - 1, j = 0; while (i &gt;= 0 &amp;&amp; j &lt; n) { if (matrix[i][j] &gt; target) { i--; } else if (matrix[i][j] &lt; target) { j++; } else { return true; } } return false; } //从右下角开始查找 public boolean findNumberIn2DArray(int[][] matrix, int target) { if (matrix == null) return false; int m = matrix.length; if (m == 0) return false; int n = matrix[0].length; int i = 0, j = n - 1; while (i &lt; m &amp;&amp; j &gt;= 0) { if (matrix[i][j] &gt; target) { j--; } else if (matrix[i][j] &lt; target) { i++; } else { return true; } } return false; }]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(剑指Offer-03)数组中重复的数字]]></title>
    <url>%2F2020%2F03%2F10%2F(%E5%89%91%E6%8C%87Offer-03)%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[(03)数组中重复的数字问题描述找出数组中重复的数字。 在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。 示例 1： 输入： [2, 3, 1, 0, 2, 5, 3] 输出：2 或 3 限制： 2 &lt;= n &lt;= 100000 解题思路 使用HashSet的特性，当添加到没有的数字时返回True即可判断是否为重复的数字；也可以使用一个数组辅助实现hash方法。 问题中在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内为核心要点，这句的意思即为若该数组无重复且排序的话，则该数组的值与其序号是相同的。所以可以通过将nums[i]与nums[nums[i]]位置的数字进行交换，若数字相同则进行返回。 代码/** * 面试题03 * 数组中重复的数字 * @param nums 所给数组 * @return 重复数字 */ //HashSet方法 public int findRepeatNumber(int[] nums) { if (nums == null || nums.length &lt; 2 || nums.length &gt; 100000) { return 0; } Set&lt;Integer&gt; set = new HashSet&lt;&gt;(nums.length); for (int i : nums) { if (!set.add(i)) { return i; } } return -1; } //自实现Hash方法 public int findRepeatNumber(int[] nums) { int[] temp = new int[nums.length]; for (int i = 0 ; i &lt; nums.length ; i++) { temp[nums[i]] ++; if (temp[nums[i]] &gt; 1) { return nums[i]; } } return -1; } //原地交换 public int findRepeatNumber(int[] nums) { int temp = 0; for (int i = 0 ; i &lt; nums.length ; i ++) { while (nums[i] != i) { if (nums[i] == nums[nums[i]]) { return nums[i]; } else { temp = nums[i]; nums[i] = nums[temp]; nums[temp] = temp; } } } return 0; }]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo基本命令]]></title>
    <url>%2F2020%2F03%2F10%2FHexo%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[inithexo init [folder] 新建一个网站 hexo newhexo new [layout] &lt;title&gt; 新建一个title.md文档 hexo generate(hexo g) 选项 描述 -d, –deploy 文件生成后立即部署网站 -w, –watch 监视文件变动 -b, –bail 生成过程中如果发生任何未处理的异常则抛出异常 -f, –force 强制重新生成文件 Hexo 引入了差分机制，如果 public 目录存在，那么 hexo g 只会重新生成改动的文件。 使用该参数的效果接近 hexo clean &amp;&amp; hexo generate -c, –concurrency 最大同时生成文件的数量，默认无限制 生成网站静态文件到默认设置的 public 文件夹 publishhexo publish [layout] &lt;fileName&gt; 发表草稿 hexo server(hexo s) 启动服务器，默认网址为http://localhost:4000/ 项 描述 -p, –port 重设端口 -s, –static 只使用静态文件 -l, –log 启动日记记录，使用覆盖记录格式 hexo deploy(hexo d) 部署网站到服务器 参数 描述 -g, –generate 部署之前预先生成静态文件 hexo clean 清除缓存文件 (db.json) 和已生成的静态文件 (public)。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
