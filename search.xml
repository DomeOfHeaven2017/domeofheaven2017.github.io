<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数据结构与算法-二叉树]]></title>
    <url>%2F2020%2F08%2F09%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[二叉树 一. 定义每个节点最多只有两个分支（即不存在分支度大于 2 的节点）的树结构。左子树和右子树是有顺序的，不能任意颠倒。 二. 性质 非空的二叉树，若树叶总数为n0,分支度为n2,则$n0 = n2 + 1$ 三. 类型graph LR D[二叉树] --> G[完全二叉树] D --> H[平衡二叉树] D --> I[排序二叉树] G --> J[满二叉树] 满二叉树(Full Binary Tree)：一棵深度为k，且有2^k^ - 1个节点的二叉树。 完全二叉树(Complete Tree)：除最后一层外，如其余层都是满的，并且最后一层是满的或者是在右边缺少连续若干节点的二叉树 具有n个节点的完全二叉树的深度为$\log_2{n} + 1$ 深度为k的完全二叉树，至少有2^k-1^个节点，至多有2^k^ -1个节点 平衡二叉树 排序二叉树 四. 存储结构 顺序存储表示 二叉树可以用数组或链接串列来存储，若是满二叉树就能紧凑排列而不浪费空间。如果某个节点的索引为i，（假设根节点的索引为0）则在它左子节点的索引会是$2i + 1$，以及右子节点会是$2i + 2$；而它的父节点（如果有）索引则为$ \lfloor \frac{i-1}{2} \rfloor$这种方法更有利于紧凑存储和更好的访问的局部性，特别是在前序遍历中。然而，它需要连续的存储空间，这样在存储高度为h的n个节点所组成的一般树时，将浪费很多空间。在最糟糕的情况下，如果深度为h的二叉树其每个节点都只有右孩子，则该存储结构需要占用2^h^ - 1的空间，实际上却有h个节点，浪费了不少空间，是顺序存储结构的一大缺点。 链表存储表示 二叉树通常用树结点结构来存储。有时也包含指向唯一的父节点的指针。如果一个结点的子结点个数小于2，一些子结点指针可能为空值，或者为特殊的哨兵结点。 使用链表能避免顺序存储浪费空间的问题，算法和结构相对简单，但使用二叉链表，由于缺乏父链的指引，在找回父节点时需要重新扫描树得知父节点的节点地址。 public class TreeNode &#123; public int val; public TreeNode left; public TreeNode right; public TreeNode(int x) &#123; val = x; &#125; &#125; 五. 遍历方法 前序遍历：先访问根节点，再访问根的左节点和右节点 //递归方式 public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); treeNodeTraversal(list, root); return list; &#125; private void treeNodeTraversal(List&lt;Integer&gt; list, TreeNode root)&#123; if (root == null) &#123; return; &#125;; //访问根节点 list.add(root.val); //遍历左子树 treeNodeTraversal(list, root.left, 0); //遍历右子树 treeNodeTraversal(list, root.right, 0); &#125; //迭代方式 public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if (root == null) &#123; return list; &#125; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); //将根节点压入栈中 stack.push(root); while (!stack.isEmpty()) &#123; TreeNode node = stack.pop(); //访问根节点 list.add(node.val); //由于栈是先入后出，所以右子节点先入栈，左子节点后入栈 if (node.right != null) &#123; stack.push(node.right); &#125; if (node.left != null) &#123; stack.push(node.left); &#125; &#125; return list; &#125; 中序遍历：先遍历左子节点，再遍历根节点，最后遍历右子节点 //递归方式 public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); treeNodeTraversal(list, root); return list; &#125; private void treeNodeTraversal(List&lt;Integer&gt; list, TreeNode root)&#123; if (root == null) &#123; return; &#125;; //先遍历左子节点 treeNodeTraversal(list, root.left, 0); //访问 list.add(root.val); treeNodeTraversal(list, root.right, 0); &#125; //非递归方式 //先将左节点全部入栈，遍历到叶子节点后一层层向上遍历根节点和右节点 public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if (root == null) &#123; return list; &#125; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode node = root; //判断条件 1. 栈为空，即遍历完毕或开始遍历； // 2. node不为空则开始遍历 while (!stack.isEmpty() || node != null) &#123; if (node != null) &#123; //将左节点入栈 stack.push(node); node = node.left; &#125; else &#123; //左节点不存在，则访问该节点，再遍历右节点 node = stack.pop(); list.add(node.val); node = node.right; &#125; &#125; return list; &#125; 后序遍历：先遍历左子节点，再遍历右子节点，最后遍历根节点 //递归方式 public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); treeNodeTraversal(list, root); return list; &#125; private void treeNodeTraversal(List&lt;Integer&gt; list, TreeNode root)&#123; if (root == null) &#123; return; &#125;; //遍历左子树 treeNodeTraversal(list, root.left, 0); //遍历右子树 treeNodeTraversal(list, root.right, 0); //访问根节点 list.add(root.val); &#125; //非递归方式 //前序遍历结果为“根左右”，如果修改遍历次序则为“根右左”，在进行倒序则为后序遍历“左右根” public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if (root == null) &#123; return list; &#125; //遍历栈,遍历树节点 Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); //记录“根右左”遍历的值 Stack&lt;Integer&gt; temp = new Stack&lt;&gt;(); stack.push(root); //根据前序遍历修改遍历次序，使结果输出"根右左" while (!stack.isEmpty()) &#123; TreeNode node = stack.pop(); temp.push(node.val); if (node.left != null) &#123; stack.push(node.left); &#125; if (node.right != null) &#123; stack.push(node.right); &#125; &#125; //将“根右左”的结果倒序输出为"左右根" while (!temp.isEmpty()) &#123; list.add(temp.pop()); &#125; return list; &#125; 层次遍历：每一层按照从左到右的顺序打印节点 //非递归方式 //使用一个队列，依次将节点子节点入队列，再依次出队列即可 public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); if (root == null) &#123; return result; &#125; //遍历队列 Queue&lt;TreeNode&gt; queue = new ArrayDeque&lt;&gt;(); //先将根节点入队列 queue.add(root); while ( !queue.isEmpty()) &#123; //每层的数据放在一个数组中 List&lt;Integer&gt; temp = new ArrayList&lt;&gt;(); //当前队列里元素的数量就是当前层数的总节点数量 int size = queue.size(); //使用一个循环遍历当前层数所有的节点 for (int i = 0 ; i &lt; size ; i ++) &#123; TreeNode node = queue.poll(); if (node !=null) &#123; //访问当前节点，并将其子节点入队列 temp.add(node.val); if (node.left != null) &#123; queue.add(node.left); &#125; if (node.right != null) &#123; queue.add(node.right); &#125; &#125; &#125; //一层遍历完成，将数据添加到结果中 result.add(temp); &#125; return result; &#125; //递归方式 //增加level表示层级，根据节点的层级，将节点的数据添加到想要数组中 public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); if (root == null) &#123; return result; &#125; //加入根节点，开始递归遍历 levelOrderDfs(1, root, result); return result; &#125; private void levelOrderDfs(int level, TreeNode node, List&lt;List&lt;Integer&gt;&gt; lists) &#123; //当前层级无相应数组时，添加一个空数组 if (lists.size() &lt; level) &#123; lists.add(new ArrayList&lt;&gt;()); &#125; //访问节点值，并将其添加到对应层级的数组里 lists.get(level - 1).add(node.val); //层级递增，遍历下一层，递归遍历左子节点和右子节点 if (node.left != null) &#123; levelOrderDfs(level + 1, node.left, lists); &#125; if (node.right != null) &#123; levelOrderDfs(level + 1, node.right, lists); &#125; &#125;]]></content>
      <categories>
        <category>树</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法-树]]></title>
    <url>%2F2020%2F08%2F09%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%A0%91%2F</url>
    <content type="text"><![CDATA[树 一. 定义树是一种 抽象数据类型(ADT) 或是实现这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由 n 个有限节点组成的一个具有层次关系的集合。 抽象数据类型(Abstract Data Type，ADT),是计算机科学中具有类似行为的特定类别的数据结构的数学模型 二. 特点 每个节点只有有限个子节点或无子节点 没有父节点的节点称为根节点 每一个非根节点有且只有一个父节点 树里面没有环路 三. 术语 节点的度：一个节点含有的子树的个数称为该节点的度 树的度：一棵树中，最大的节点度称为树的度 叶节点或终端节点：度为零的节点 非终端节点或分支节点：度不为零的节点 父亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点 孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点 兄弟节点：具有相同父节点的节点互称为兄弟节点 节点的层次：从根开始定义起，根为第 1 层，根的子节点为第 2 层，以此类推 深度：对于任意节点 n,n 的深度为从根到 n 的唯一路径长，根的深度为 0 高度：对于任意节点 n,n 的高度为从 n 到一片树叶的最长路径长，所有树叶的高度为 0 堂兄弟节点：父节点在同一层的节点互为堂兄弟 节点的祖先：从根到该节点所经分支上的所有节点 子孙：以某节点为根的子树中任一节点都称为该节点的子孙 森林：由 m（m&gt;=0）棵互不相交的树的集合称为森林 四. 树的分类graph LR A[树] --> B[无序树] A --> C[有序树] C --> D[二叉树] C --> E[霍夫曼树] C --> F[B树] D --> G[完全二叉树] D --> H[平衡二叉树] D --> I[排序二叉树] G --> J[满二叉树] 无序树：树中任意节点的子节点之间没有顺序关系 有序树：树中任意节点的子节点之间有顺序关系 二叉树：每个节点最多含有两个子树的树 霍夫曼树：带权路径最短的二叉树称为哈夫曼树或最优二叉树 B 树：一种对读写操作进行优化的自平衡的二叉查找树，能够保持数据有序，拥有多于两个子树 五. 树的遍历graph LR a[树的遍历] --> b b[深度优先遍历] --> c[前序遍历] b --> e[中序遍历] b --> f[后序遍历] a --> d[广度优先遍历] 深度优先遍历：先访问子节点，再访问父节点，最后是第二个子节点 前序遍历：先访问根，然后访问子树的遍历方式 前序遍历：F, B, A, D, C, E, G, I, H. 中序遍历：先访问左（右）子树，然后访问根，最后访问右（左）子树的遍历方式 中序遍历：A, B, C, D, E, F, G, H, I. 后序遍历:先访问子树，然后访问根的遍历方式 后序遍历：A, C, E, D, B, H, I, G, F. 广度优先遍历层次遍历：F, B, G, A, D, I, C, E, H.]]></content>
      <categories>
        <category>树</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发艺术探索学习笔记-第十一章]]></title>
    <url>%2F2020%2F08%2F04%2FAndroid%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[Android中的线程和线程池 在操作系统中，线程是调度的最小单元，同时线程不能无限制的产生，线程的创建和销毁都需要开销，通过线程池可以避免因为频繁创建和销毁线程而导致的开销。 一. 主线程和子线程 主线程:指进程所拥有的线程,主要处理和界面相关的事情,也称UI线程. 为了避免界面卡顿,主线程中不能执行耗时的任务,会引起ANR 子线程:也称工作线程,除主线程以外的线程都是子线程.主要执行耗时任务，如网络请求，I/O操作等 二. Android中的线程形态 AsyncTask 内部封装了Thread和Handler,在线程池中执行后台任务,把执行进度和结果返回给主线程. AsyncTask不适合执行特别耗时的后台任务 public abstract class AsyncTask&lt;Params,Progress,Result&gt;&#123; //AsyncTask参数 //Params:表示参数的类型 //Progress:后台任务的执行进度的类型 //Result:任务的返回结果的类型 /** * 在主线程中执行,异步任务执行&#123;#doInBackground&#125;之前会被调用 **/ @MainThread protected void onPreExecute() &#123; &#125; /** * 用于执行异步任务,在此方法中可以通过publishProgress方法更新进度 **/ @WorkerThread protected abstract Result doInBackground(Params... params); /** * 在主线程中执行,用于更新任务进度 **/ @MainThread protected void onProgressUpdate(Progress... values) &#123; &#125; /** * 在主线程中执行,在异步任务执行之后调用,用于返回结果 **/ @MainThread protected void onPostExecute(Result result) &#123; &#125; /** * 执行在主线程,异步任务取消时调用,默认实现中直接调用了onCancelled()方法,所以 * 忽略了结果值,注意在覆写时不要使用super.onCancelled(result) **/ @MainThread protected void onCancelled(Result result) &#123; onCancelled(); &#125; &#125; AsyncTask使用限制： AsyncTask的类必须在主线程加载 AsyncTask的对象必须在主线程创建 execute方法必须在UI线程调用 不要在程序中直接调用onPreExecute, onPostExecute, doInBackground, onProgressUpdate 一个AsyncTask对象只能执行一次，即只能调用一次execute方法 工作原理: graph TB A["excute(Params... params)"] --> B["executeOnExecutor(sDefaultExecutor,param)"] B --> C["SERIAL_EXECUTOR#execute(Runnable r)"] C --> D["SERIAL_EXECUTOR#scheduleNext()"] D --> E["THREAD_POOL_EXECUTOR#execute(Runnable r)"] AsyncTask中有两个线程池(SERIAL_EXECUTOR,THREAD_POOL_EXECUTOR)和一个线程Handler(InternalHandler) SERIAL_EXECUTOR:内部实现的SerialExecutor,用于任务的排队,接收到传递过来的FutureTask对象后将其插入到任务队列中,如果此时没有任务在执行则调用scheduleNext方法执行下一个任务.可以看出AsyncTask是串行执行的 THREAD_POOL_EXECUTOR:用于执行任务 InternalHandler:用于子线程切换到主线程 HandlerThread HandlerThread继承自Thread,其内部构建了一个消息处理循环 用法 //创建HandlerThread实例 HandlerThread mMsgThread = new HandlerThread("msg-handler"); //启动 mMsgThread.start(); //关联Handler处理消息 Handler mMsgHandler = new Handler(mMsgThread.getLooper())&#123; @Override public void handleMessage(Message msg)&#123; //消息处理 &#125; &#125; IntentService IntentService是继承了Service的一个抽象类.可用于执行后台耗时的任务,当任务执行完成后自动停止. 工作原理: //onCreate //创建一个HandlerThread,并通过其再创建mServiceHandler @Override public void onCreate() &#123; super.onCreate(); HandlerThread thread = new HandlerThread("IntentService[" + mName + "]"); thread.start(); mServiceLooper = thread.getLooper(); mServiceHandler = new ServiceHandler(mServiceLooper); &#125; //onStart中通过mServiceHandler发送消息,然后在ServiceHandler中调用onHandleIntent //方法处理消息,并随后调用Service#stopSelt(startId)停止服务 private final class ServiceHandler extends Handler &#123; public ServiceHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message msg) &#123; onHandleIntent((Intent)msg.obj); stopSelf(msg.arg1); &#125; &#125; Service中的stopSelf()和stopSelf(int startId)都能停止服务,但stopSelf()会立刻停止服务,而stopSelf(int startId)会等待所有消息都处理完成后停止服务. onHandleIntent方法需要在子类中实现,根据Intent参数区分不同的任务并执行. onHandleIntent中的任务是排队执行的,执行顺序为发起请求的顺序. 三. Android中的线程池 线程池的优点 线程复用,避免线程重复创建和销毁带来的开销 有效控制线程池的最大并发数,避免大量的线程之间因资源抢占而阻塞 统一管理线程 ThreadPoolExecutor //构造方法 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) 构造参数 corePoolSize:线程池的核心线程数,默认会一直存活. maximumPoolSize:线程池能容纳的最大线程数,达到这个数值后,后续任务会被阻塞 keepAliveTime:非核心线程闲置时的超时时长,超过这个时间后会被回收. 如果设置allowCoreThreadTimeOut为True,可作用于核心线程 unit:keepAliveTime参数时间单位 workQueue:线程池中的任务队列,通过线程池的execute方法提交的Runnable对象会存储在该参数中 threadFactory:线程工厂,为线程池提供创建新线程的功能 handler:当线程池无法执行新任务时,ThreadPoolExecutor会调用该handler的rejectedExecution方法,默认直接抛出RejectedExecutionException 执行规则 如果线程池中的线程数未达到核心线程数,则直接启动核心线程执行任务 如果线程数量大于或等于核心线程数,任务会被插入到任务队列中排队等待 如果线程数量大于或等于核心线程数且任务队列也已满,此时如果线程数量未达到线程能容纳的最大值,则立刻启动一个非核心线程执行任务;如果达到了最大值则拒绝执行任务调用rejectedExecution方法 线程池的分类 FixedThreadPool public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt; ()); &#125; 通过Executors的newFixedThreadPool方法创建.一种线程数量固定的线程池,只有核心线程,没有超时机制和任务队列大小限制. CachedThreadPool public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;()); &#125; 通过Executors的newCachedThreadPool方法来创建.一种线程数量不定的线程池,只有非核心线程,且最大线程数为Interger.MAX_VALUE.线程池中的空闲线程都有超时机制,超时时间为60s ScheduledThreadPool public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123; return new ScheduledThreadPoolExecutor(corePoolSize); &#125; public ScheduledThreadPoolExecutor(int corePoolSize) &#123; super(corePoolSize, Integer.MAX_VALUE, DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS, new DelayedWorkQueue()); &#125; 通过Executors的newSingleThreadScheduledExecutor创建.核心线程数固定,非核心线程数最大为Interger.MAX_VALUE,非核心线程闲置时会被回收.用于执行定时任务和具有固定周期的重复任务. SingleThreadExecutor public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;())); &#125; 通过Executors的newSingleThreadExecutor方法创建.线程池中只有一个核心线程,确保所有的任务都在同一个线程中按顺序执行.]]></content>
      <categories>
        <category>Android开发艺术探索</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发艺术探索学习笔记-第十章]]></title>
    <url>%2F2020%2F08%2F03%2FAndroid%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%8D%81%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[Android的消息机制 Android的消息机制概述Android的消息机制主要指Handler的运行机制以及Handler所附带的MessageQueue和Looper的工作过程，Handler的主要作用是将一个任务切换到某个指定的线程中去执行。Handler创建时会采用当前线程的Looper来构建内部的消息循环系统，如果没有Looper会报错。线程中默认是没有Looper的，主线程（UI线程，即ActivityThread）被创建时会初始化Looper，所以主线程默认可以使用Handler Android的消息机制分析 ThreadLocal的工作原理 ThreadLocal:是一个线程内部的数据存储类，可以通过它在指定的线程存储和获取数据（其他线程无法获取） //定义 public class ThreadLocal&lt;T&gt; //set方法 public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); &#125; //get方法 public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings("unchecked") T result = (T)e.value; return result; &#125; &#125; return setInitialValue(); &#125; 消息队列的工作原理 MessageQueue主要包含两个操作：插入和读取，对应enqueueMessage和next，MessageQueue是通过一个单链表的数据结构来维护消息列表的，不是队列。 enqueueMessage方法的主要操作是单链表的插入操作 next方法的主要操作是构建一个无限循环，有消息时返回这条消息并移除；无消息时则进行阻塞。 Looper的工作原理 Looper是消息循环，会不停的查看MessageQueue中是否有新消息，有则立即处理；无则进行阻塞。 重要方法： prepare : 为当前线程创建一个Looper prepareMainLooper : ActivityThread创建Looper使用 getMainLooper : 获取主线程的Looper quit : 直接退出Looper quitSafely : 设定退出标记，在把消息队列中已有消息处理完后安全退出 loop : 调用MessageQueue的next方法来获取新消息 Handler的工作原理 Handler的工作主要包含消息的发送和接收过程。 发送消息的过程为向消息队列中插入一条消息，随后MessageQueue返回消息给Looper，Looper在交由Handler处理，即调用Handler的dispatchMessage方法 主线程的消息循环主线程即ActivityThread,其入口方法为main，在main方法中通过Looper.prepareMainLooper来创建主线程的Looper以及MessageQueue，并通过Looper.loop方法来开启主线程的消息循环 public static void main(String[] args) &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "ActivityThreadMain"); // Install selective syscall interception AndroidOs.install(); // CloseGuard defaults to true and can be quite spammy. We // disable it here, but selectively enable it later (via // StrictMode) on debug builds, but using DropBox, not logs. CloseGuard.setEnabled(false); Environment.initForCurrentUser(); // Make sure TrustedCertificateStore looks in the right place for CA certificates final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId()); TrustedCertificateStore.setDefaultUserDirectory(configDir); Process.setArgV0("&lt;pre-initialized&gt;"); Looper.prepareMainLooper(); // Find the value for &#123;@link #PROC_START_SEQ_IDENT&#125; if provided on the command line. // It will be in the format "seq=114" long startSeq = 0; if (args != null) &#123; for (int i = args.length - 1; i &gt;= 0; --i) &#123; if (args[i] != null &amp;&amp; args[i].startsWith(PROC_START_SEQ_IDENT)) &#123; startSeq = Long.parseLong( args[i].substring(PROC_START_SEQ_IDENT.length())); &#125; &#125; &#125; ActivityThread thread = new ActivityThread(); thread.attach(false, startSeq); if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; if (false) &#123; Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, "ActivityThread")); &#125; // End of event ActivityThreadMain. Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); Looper.loop(); throw new RuntimeException("Main thread loop unexpectedly exited"); &#125; ActivityThread通过ActivityThread.H来和消息队列进行交互。具体流程为：ActivityThread通过ApplicationThread和ActivityManagerService进行进程间通信，AMS以进程间通信的方式完成ActivityTread的请求后会回调ApplicationThread中的Binder方法，然后ApplicationThread会向H发送消息，H收到消息后将ApplicationThread中的逻辑切换到ActivityThread中去执行，即切换到主线程执行。]]></content>
      <categories>
        <category>Android开发艺术探索</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发艺术探索学习笔记-第九章]]></title>
    <url>%2F2020%2F08%2F02%2FAndroid%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B9%9D%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[第九章 四大组件的工作过程 四大组件的运行状态 Activity 展示一个界面并和用户进行交互．由Intent触发启动 ，分为显示Intent和隐式Intent，显示Intent可以明确指向一个Activity组件，隐式Intent可以指向一个或多个Activity组件 Service 一种计算型组件，用于在后台执行一系列计算．与Activity只有一种启动状态不同，Service有两种状态：启动状态（startService）和绑定状态（bindService）．Service是运行在主线程中的． BroadcastReceiver 一种消息型组件，用于在不同的组件，不同的应用之间传递消息． 广播有两种注册方式： 静态注册：在AndroidManifest中注册广播，在应用安装时被系统解析，无须应用启动就可以收到相应的广播． 动态注册：通过Context.registerReceiver()和Context.unRegisterReceiver()来注册和注销广播，需要应用启动才能注册并接收广播． ContentProvider 一种数据共享型组件，用于向其它组件和应用共享数据． Activity的工作过程 显示调用，启动Activity Intent intent = new Intent(this, TestActivity.Class); startActivity(intent); 启动流程 sequenceDiagram Activity ->> Activity : startActvity Activity ->> Activity : startActivityForResult Activity ->> Instrumentation : execStartActivity Instrumentation ->> ActivityManagerService : ActivityManagerNative.getDefault().startActivity ActivityManagerService ->> ActivityManagerService : startActivity ActivityManagerService ->> ActivityStackSupervisor : startActivityLocked ActivityStackSupervisor ->> ActivityStack : resumeTopActivitiesLocked ActivityStack ->> ActivityStackSupervisor : startSpecificActivityLocked ActivityStackSupervisor ->> ActivityStackSupervisor : realStartActivityLocked ActivityStackSupervisor ->> ApplicationThread : sceduleLaunchActivity ApplicationThread ->> ActivityThread : handleLaunchActivity ActivityThread ->> ActivityThread : performLaunchActivity performLaunchActivity方法具体内容： 从ActivityClientRecord中获取待启动的Activity的组件信息 通过Instrumentation的newActivity方法使用类加载器创建Activity对象 通过LoadedApk的makeApplication方法来尝试创建Application对象 创建ContextImpl对象并通过Activity的attach方法完成h重要数据初始化 调用Activity的onCreate方法 Service的工作过程 启动状态：主要用于执行后台计算 //启动Service Intent intentService = new Intent(this,TmpService.class); startService(intentService); 绑定状态：用于其他组件和Service的交互 //绑定Service Intent intentService = new Intent(this,TmpService.class); bindService(intentService,mServiceConn,BIND_AUTO_CREATE); 两种状态可以共存，一个Service既可以处于启动状态，也可以同时处于绑定状态 Service的启动过程 sequenceDiagram Activity ->> ContextWrapper : startService ContextWrapper ->> ContextImpl : startService ContextImpl ->> ContextImpl : startServiceCommon ContextImpl ->> ActivityManagerService : startService ActivityManagerService ->> ActiveServices : startServiceLocked ActiveServices ->> ActiveServices : startServiceInnerLocked ActiveServices ->> ActiveServices : bringUpServiceLocked ActiveServices ->> ApplicationThread : realStartServiceLocked ApplicationThread ->> ApplicationThread : scheduleCreateService ApplicationThread ->> ActivityThread : handleCreateService handleCreateService方法具体内容： 通过类加载器创建Service的实例 创建Application对象并调用其onCreate 创建ContextImpl对象并通过Service的attach方法建立联系 调用Service的onCreate方法并将Service对象存到ActivityThread的列表中 Service的绑定过程 sequenceDiagram ContextWrapper ->> ContextImpl : bindService ContextImpl ->> ContextImpl : bindServiceCommon ContextImpl ->> LoadedApk : getServiceDispatcher LoadedApk -->> ContextImpl : ServiceDispatcher.InnerConnection ContextImpl ->> ActivityManagerService : bindService ActivityManagerService ->> ActiveServices : bindServiceLocked ActiveServices ->> ActiveServices : bringUpServiceLocked ActiveServices ->> ApplicationThread : realStartServiceLocked ApplicationThread ->> ActivityManagerService : handleBindService ActivityManagerService ->> ActivityManagerService : publishService ActivityManagerService ->> ActiveServices : publishServiceLocked BroadcastReceiver的工作过程 广播的注册过程 静态注册 静态注册的广播在应用安装时由PackageManagerService来完成整个注册过程(其它三大组件亦是如此) 动态注册 sequenceDiagram ContextWrapper ->> ContextImpl : registerReceiver ContextImpl ->> ContextImpl : registerReceiverInternal ContextImpl ->> LoadedApk : getReceiverDispatcher LoadedApk -->> ContextImpl : IIntentReceiver ContextImpl ->> ActivityManagerService : registerReceiver 广播的发送和接收过程 广播的发送过程 sequenceDiagram ContextWrapper ->> ContextImpl : sendBroadcast ContextImpl ->> ActivityManagerService : broadcastIntent ActivityManagerService ->> ActivityManagerService : broadcastIntentLocked ActivityManagerService ->> ActivityManagerService : scheduleBroadcastsLocked ActivityManagerService ->> ActivityManagerService : processNextBroadcast ActivityManagerService ->> ActivityManagerService : performReceiveLocked ActivityManagerService ->> ApplicationThread : scheduleRegisteredReceiver ApplicationThread ->> InnerReceiver : performReceiver InnerReceiver ->> LoadedApk.ReceiverDispatcher : performReceive 应用处于停止状态的两种情形： 应用安装后未运行 应用被手动或其他应用强制停止 ContentProvider的工作过程ContentProvider是一种内容共享型组件，它通过Binder向其他组件乃至其他应用提供数据。当ContentProvider所在的进程启动时，ContentProvider会同时启动并被发布到AMS中。这时候ContentProvider的onCreate要先于Application的onCreate而执行 ContentProvider启动后，外界可以提供它所提供的增删改查四个接口来操作数据源，这四个方法都是通过Binder来调用的，外界无法直接访问ContentProvider，只能通过ActivityManagerService根据Uri来获取对应的ContentProvider的Binder接口IContentProvider，再通过IContentProvider访问ContentProvider中的数据源 ContentProvider的启动过程(以query为例) sequenceDiagram ActivityThread ->> ActivityManagerService : startProcessLocked ActivityManagerService ->> ActivityThread : main ActivityThread ->> ActivityThread : attach ActivityThread ->> ActivityManagerService : attachApplication ActivityManagerService ->> ActivityManagerService : attachApplicationLocked ActivityManagerService ->> ApplicationThread : bindApplication ApplicationThread ->> ActivityThread : handleBindApplication handleBindApplication具体内容： 创建ContextImpl和Instrumentation 创建Application对象 启动当前进程的ContentProvider并调用其onCreatef方法 调用Application的onCreate方法]]></content>
      <categories>
        <category>Android开发艺术探索</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发艺术探索学习笔记-第八章]]></title>
    <url>%2F2020%2F07%2F26%2FAndroid%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%85%AB%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[理解Window和WindowManager Window表示一个窗口的概念，是一个抽象类，它的具体实现是PhoneWindow。创建一个Window需要通过WindowManage来完成，WindowManager是外界访问Window的入口，Window的具体实现在WindowManagerService中，WindowManager和WindwManagerService的交互是一个IPC过程。Android中所有的视图都是通过Window来呈现的，Window是View的直接管理者。 1. Window和WindowManager​ WindowManager常用的有三个方法：添加View, 更新View, 删除View //添加View mButton = new Button(this); mLayoutParams = new WindowManager.LayoutParams(....); mLayoutParams.flags = LayoutParams.FLAG_NOT_TOUCH_MODAL...; mLayoutParams.gravity = Gravity.LEFT; mLayoutParams.x = 100; mLayoutParams.y = 300; mWindowManager.addView(mButton, mLayoutParams); flags参数表示Window的属性： FLAG_NOT_FOCUSABLE:Window不需要获取焦点，也不需要接收各种输入事件 FLAG_NOT_TOUCH_MODAL: 系统会将当前Window区域以外的单击事件传递给底层的Window,区域内View处理FLAG_SHOW_WHEN_LOCKED: 可以让Window显示在锁屏的界面上 Window是分层的，每个Window都有对应的z-ordered，层级大的会覆盖在层级小的上面。 type参数表示Window的类型，Window有三种类型，分别为 应用Window : 对应着一个Activity.层级范围是==1~99== 子Window : 不能单独存在，需要附属在特定的父Window中，比如dialog等，层级范围是==1000~1999== 系统Window ：需要声明权限才能创建的Window，比如Toast和系统状态栏，层级范围是==2000~2999== 2. Window的内部机制​ 每个Window都对应着一个View和一个ViewRootImpl,Window和View通过ViewRootImpl来建立联系。 Window的添加过程 sequenceDiagram Actor ->>+ Window : addView Window ->>+ WindowManager : addView WindowManager ->>+ WindowManagerImpl : addView WindowManagerImpl ->>+ WindowManagerGlobal : addView WindowManagerGlobal ->> WindowManagerGlobal : 检查参数是否合法 WindowManagerGlobal ->> WindowManagerGlobal : 创建ViewRootImpl,添加View列表 WindowManagerGlobal ->> ViewRootImpl : 更新界面 ViewRootImpl ->> WindowSession : 添加Window WindowSession ->> WindowManagerService : 添加Window Window的删除过程 sequenceDiagram Window... ->> WindowManagerImpl :removeView WindowManagerImpl ->> WindowManagerImpl : 查找待删除的View索引 WindowManagerImpl ->> WindowManagerImpl : 调用removeViewLocked完成删除 真正删除的逻辑在dispatchDetachedFromWindow方法中实现 垃圾回收 通过Session的remove方法删除Window 调用View的dispatchDetachedFromWindow方法 调用WindowManagerGlobal的doRemoveView方法刷新数据 Window的更新过程 更新逻辑在WindowManagerGlobal的updateViewLayout中 更新View的LayoutParams并替换掉原有的 更新ViewRootImpl中的LayoutParams 3. Window的创建过程 Activity的Window创建过程 sequenceDiagram Actor ->> ActivityThread : startActivity ActivityThread ->> ActivityThread : performLaunchActivity ActivityThread ->> PolicyManager : attach PolicyManager ->> PolicyManager : makeNewWindow PolicyManager ->> Policy : makeNewWindow Activity将具体实现交给了Window，所以其逻辑在PhoneWindow中,大致步骤如下： 如果没有DecorView，就创建它 将View添加到DecorView的mContentParent中 回调Activity的onContentChanged方法通知视图改变 调用Activity的makeVisible方法，完成DecorView的添加和显示 Dialog的Window创建过程 创建Window 初始化DecorView并将Dialog的视图添加到DecorView中 将DecorView添加到Window中并显示 普通的Dialog必须采用Activity的Context，否则会报缺失token的错误，应用token一般只有Activity拥有，但系统Window可以不需要token Toast的Window创建过程 在Toast内部有两类IPC过程，第一类是Toast访问NotificationManagerService,第二类是NotificationManagerService回调Toast中的TN接口。Toast属于系统Window。 sequenceDiagram Toast ->> NotificationManagerService : show NotificationManagerService ->> NotificationManagerService : enqueueToast NotificationManagerService ->> NotificationManagerService : showNextToastoLocked NotificationManagerService ->>NotificationManagerService : scheduleTimeoutLocked]]></content>
      <categories>
        <category>Android开发艺术探索</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发艺术探索学习笔记-第七章]]></title>
    <url>%2F2020%2F07%2F22%2FAndroid%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%83%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[Android动画深入分析 1. View动画​ View动画的作用对象是View,支持平移动画,缩放动画,旋转动画,透明度动画四种动画效果 名称 标签 子类 效果 平移动画 &lt;translate&#62; TransateAnimation 移动View 缩放动画 &lt;scale&#62; ScaleAnimation 放大或缩小View 旋转动画 &lt;rotate&#62; RotateAnimation 旋转View 透明度动画 &lt;alpha&#62; AlphaAnimation 改变View透明度 1.使用步骤 在res/anim/路径下创建动画的xml文件 &lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;set xmlns:android="http://scemas.android.com/apk/res/android" android:fillAfter="true" android:zAdjustment="normal" &gt; &lt;rotate android:duration="400" android:fromDegress="0" android:toDegress="90" /&gt; &lt;/set&gt; 在代码中调用 Animation animation = AnimationUtils.loadAnimation(this, R.anim.animation_file); mButton.startAnimation(animation) 也可直接在代码中进行设置和调用 AlphaAnimation alphaAnim = new AlphaAnimation(0, 1); alphaAnim.setDuration(300); mButton.startAnimation(animation) 2.自定义View动画 继承Animation 重写initialize和applyTransformation方法 initialize : 初始化 applyTransformation : 进行相应的矩阵变换 2. 帧动画​ 帧动画是顺序播放一组预先定义好的图片。 1. 使用步骤 通过XML定义AnimationDrawable &lt;!-- res/drawable/frame_anim.xml --&gt; &lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;animation-list xmlns:android="http://scemas.android.com/apk/res/android" android:oneshot="false"&gt; &lt;item andrid:drawable="@drawable/image1" android:duration="500" /&gt; &lt;item andrid:drawable="@drawable/image2" android:duration="500" /&gt; &lt;item andrid:drawable="@drawable/image3" android:duration="500" /&gt; &lt;/animation-list&gt; 代码中调用 mButton.setBackroundResource(R.drawable.frame_anim); AnimationDrawable drawable = (AnimationDrawable) mButton.getBackground(); drawable.start(); 3. View动画的特殊使用场景 LayoutAnimation LayoutAnimation作用于ViewGroup,为ViewGroup指定一个动画，子元素都会具有该动画效果 Activity的切换效果 主要用到overridePendingTransition(int enterAnim, int exitAnim)方法，这个方法必须在startActivity或者finish方法之后调用才能生效 enterAnim ： Activity被打开时的动画资源 exitAnim ： Activity被暂停时的动画资源 4. 属性动画​ 属性动画可以对任意对象的属性进行动画而不仅仅是View,动画的默认时间间隔是300ms,默认帧率是10ms/帧，其可以达到的效果是：在一个时间间隔内完成对象从一个属性值到另一个属性值的改变。 插值器(TimeInterpolator)：根据时间流逝的百分比来计算当前属性值改变的百分比 估值器(TypeEvaluator)：根据当前属性改变的百分比来计算改变后的属性值 属性动画的监听器： public static interface AnimatorListener&#123; void onAnimationStart(Animator animation); void onAnimationEnd(Animator animation); void onAnimationCancel(Animator animation); void onAnimationRepeat(Animator animation); &#125; 属性动画的工作原理：]]></content>
      <categories>
        <category>Android开发艺术探索</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发艺术探索学习笔记-第五章]]></title>
    <url>%2F2020%2F07%2F19%2FAndroid%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%94%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[理解RemoteViews1. RemoteViews的应用RemoteViews在实际开发中主要用在通知栏和桌面小部件的开发中。通知栏主要通过NotificationManager的notify方法实现，桌面小部件则通过AppWidgetProvider实现。这两个的界面都运行在系统的SystemServer进程中，无法直接更新View. 1.RemoteViews在通知栏上的应用 使用系统默认样式 // Build the notification and add the action. Notification newMessageNotification = new Notification.Builder(context, CHANNEL_ID) .setSmallIcon(R.drawable.ic_message) .setContentTitle(getString(R.string.title)) .setContentText(getString(R.string.content)) .addAction(action) .build(); // Issue the notification. NotificationManagerCompat notificationManager = NotificationManagerCompat.from(this); notificationManager.notify(notificationId, newMessageNotification); 自定义通知 // Get the layouts to use in the custom notification RemoteViews notificationLayout = new RemoteViews(getPackageName(), R.layout.notification_small); RemoteViews notificationLayoutExpanded = new RemoteViews(getPackageName(), R.layout.notification_large); // Apply the layouts to the notification Notification customNotification = new NotificationCompat.Builder(context, CHANNEL_ID) .setSmallIcon(R.drawable.notification_icon) .setStyle(new NotificationCompat.DecoratedCustomViewStyle()) .setCustomContentView(notificationLayout) .setCustomBigContentView(notificationLayoutExpanded) .build(); 2.RemoteViews在桌面小部件上的应用AppWidgetProvider是Android中提供的用于实现桌面小部件的类，本质是一个广播 定义小部件界面 在res/layout/下建立小部件布局界面 定义小部件配置信息 在res/xml/下建立小部件配置信息 重要参数说明： initLayout:初始化界面 updatePeriodMillis:自动更新周期 定义小部件的实现类 继承AppWidgetProvider实现具体逻辑 重要方法说明： onEnable:小部件第一次添加到桌面时调用该方法 onUpdate:小部件被添加时或者每次小部件更新时都会调用该方法 onDeleted:每删除一次桌面小部件就调用一次 onDisabled:最后一个该类型的桌面小部件被删除时调用该方法 onReceive:分发具体的事件给其他方法 在AndroidManifest.xml中声明小部件 3.PendingIntent概述 ​ PendingIntent表示一种处于待定，等待，即将发生状态的意图，支持三种待定意图：启动Activity,启动Service,发送 广播 getActivity(Context context, int requestCode, Intent intent, int flags); getService(Context context, int requestCode, Intent intent, int flags); getBroadcast(Context context, int requestCode, Intent intent, int flags); 匹配规则：如果两个PendingIntent它们内部的Intent相同并且requestCode也相同，则这两个PendingIntent相同 Intent匹配规则：如果两个Intent的ComponentName和intent-filter都相同，则这两个Intent相同 Flag参数 FLAG_ONE_SHOT 当前PendingIntent只能使用一次 FLAG_NO_CREATE 当前PendingIntent不会主动创建，如果不存在，则get方法会直接返回null FLAG_CANCEL_CURRENT 当前描述的PendingIntent如果已存在，那么它们都会被cancel FLAG_UPDATE_CURRENT 当前描述的PendingIntent如果已存在，那么它们都会被更新 2.RemoteViews的内部机制 构造方法 /** * @param packageName 当前应用的包名 * @param layoutId 待加载的布局文件 **/ public RemoteViews(String packageName, int layoutId) RemoteViews目前并不支持所有的View类型，支持的所有类型如下 Layout : FrameLayout, LinearLayout, RelativeLayout, GridLayout View : AnalogClock, Button, Chronometer, ImageButton, ImageView, ProgressBar, TextView, ViewFlipper, ListView, GridView, StackView, AdapterViewFlipper, ViewStub 使用 RemoteViews没有提供findViewById方法，无法直接访问View元素，必须通过RemoteViews所提供的一系列set方法来完成 内部机制 RemoteViews会通过Binder传递到SystemServer进程 系统根据RemoteViews中的包名等信息得到该应用的资源，加载RemoteViews中的文件 系统对生成的View进行一系列界面更新任务 单击事件，RemoteViews中只支持发起PendingIntent,不支持onClickListener. setOnClickPendingIntent用于给普通View设置单击事件，但不能给集合(ListView,StackView)中的View设置单击事件 要给ListView或StackView中的item添加单击事件，必须将setPendingIntentTemplate和setOnClickFillInIntent组合使用]]></content>
      <categories>
        <category>Android开发艺术探索</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发艺术探索学习笔记-第四章]]></title>
    <url>%2F2020%2F07%2F12%2FAndroid%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%9B%9B%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[Android开发艺术探索 第四章笔记第四章 View的工作原理 初识ViewRoot和DecorView ViewRoot:对应于ViewRootImpl类，是连接WindowManager和DecorView的纽带，View的三大流程(measure,layout,draw)来完成的。 //在ActivityThread中，当Activity对象被创建完后，会将DecorView添加到Window中，同时创建 //ViewRootImpl对象，并将这两者关联起来 root = new ViewRootImpl(view.getContext(),display); root.setView(view,wparams,panelParentView); View的绘制流程从ViewRoot的performTraversals方法开始，经过三大流程完成绘制。 ​ 图 4-1 performTraversals的工作流程图 measure:测量View的宽和高 layout:确定View在父容器中的放置位置 draw:将View绘制在屏幕上 理解MeasureSpec 在很大程度上决定了一个View的尺寸规格(会受到父容器的影响)。 MeasureSpec:代表一个32位int值，高2位代表SpecMode，低30位代表SpecSize。 SpecMode：测量模式 SpecSize：在某种测量模式下的规格大小 private static final int MODE_SHIFT = 30; private static final int MODE_MASK = 0x3 &lt;&lt; MODE_SHIFT; private static final int UNSPECIFIED = 0 &lt;&lt; MODE_SHIFT; private static final int EXACTLY = 1 &lt;&lt; MODE_SHIFT; private static final int AT_MOST = 2 &lt;&lt; MODE_SHIFT; public static int makeMeasureSpec(int size,int mode)&#123; if(sUseBrokenMakeMeasureSpec)&#123; return size + mode; &#125;else&#123; return (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK) &#125; &#125; public static int getMode(int measureSpec)&#123; return (measureSpec &amp; MODE_MASK); &#125; public static int getSize(int measureSpec)&#123; return (measureSpec &amp; ~MODE_MASK); &#125; UNSPECIFIED:父容器不对View有任何限制 EXACTLY：父容器已检测出View所需要的精确大小，对应于LayoutParams中的match_parent和具体的尺寸数值。 AT_MOST：父容器给View指定了可用大小，View的大小不能大于这个值，对应于LayoutParams中的wrap_content。 MeasureSpec和LayoutParams的对应关系 顶级View（Decoriew）：Measurespec由窗口的尺寸和其自身的LayoutParams来共同确定； MATVH_PARENT：精确模式，大小就是窗口的大小； WRAP_CONTENT:最大模式，大小不定，不能超过窗口的大小； 固定大小：精确模式，大小为LayoutParams中指定到大小。 普通View:Measurespec由父容器的MeasureSpec和自身到LayoutParams共同决定。 TODO View的工作流程 measure过程 View的measure过程 //在View的measur方法中会去调用View的onMeasure方法 protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(),widthMeasureSpec),getDefaultSize(getSuggestedMinimumHeight(),heightMeasureSpec)); &#125; getSuggestedMinimumXXX:如果View没有设置背景，那么返回android:minXXX这个属性的值；如果View设置了背景，则返回android:minXXX和背景的最小尺寸这两个的最大值。 直接继承View的自定义控件需要重写onMeasure方法并设置wrap_content时的大小，否则在布局中使用wrap_content就相当于使用match_parent ViewGroup的measure过程 除了完成自己的measure过程外，还需要遍历所有子元素的measure方法。 //ViewGroup是抽象类，没有重写onMeasure方法，提供了measureChildren方法 protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) &#123; final int size = mChildrenCount; final View[] children = mChildren; for(int i = 0; i &lt; size; ++i) &#123; final View child = children[i]; if ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123; measureChild(child, widthMeasureSpec, heightMeasureSpec); &#125; &#125; &#125; measure完成后，通过getMeasuredWidth/Height方法就可以正确获取到View的宽高，但由于存在多次measure的情况，所以在onMeasure中得到的测量宽高不一定准确，在onLayout方法中获取宽高比较好一点。View的measue过程和Activity的生命周期方法不是同步执行的。可以通过以下方法解决： Activity/View#onWindowFocusChanged view.post(runnable) ViewTreeObserver view.measure(int widthMeasureSpec, int heightMeasureSpec) layout过程 Layout的作用是ViewGroup用来确定子元素的位置，当ViewGroup的位置被确定后，它在onLayout中会遍历所有的子元素并调用其layout方法，在layout方法中onLayout又会被调用。 View的layout方法流程 首先通过setFrame方法来设定View的四个顶点的位置，接着调用onLayout方法。 在View的默认实现中，View的测量宽高和最终宽高是相等的，不同点是测量宽高形成于View的measure过程，最终宽高形成于View的layout过程。 draw过程 将View绘制到屏幕上，绘制过程如下： 绘制背景：backgroud.draw(canvas) 绘制自身：onDraw 绘制子元素：dispatchDraw 绘制装饰：onDrawScrollBars View绘制过程的传递通过dispatchDraw实现，该方法会遍历调用所有子元素的draw方法 自定义View 自定义View的分类 graph LR A[自定义View] --> B[继承View重写onDraw方法] A --> C[继承ViewGroup派生特殊的Layout] A --> D[继承特定的View 如TextView等] A --> E[继承特定的ViewGroup 如LinearLayout等] 自定义View须知 让View支持wrap_content 支持Padding 尽量不要在View中使用Handler View中如果有线程或者动画，需要及时停止(View#onDetachedFromWindow) 处理好滑动冲突]]></content>
      <categories>
        <category>Android开发艺术探索</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发艺术探索学习笔记-第三章]]></title>
    <url>%2F2020%2F07%2F08%2FAndroid%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%89%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[Android开发艺术探索 第三章笔记第三章 View的事件体系3.1 View基础知识 什么是View View是Android中所有控件的基类，是一种界面层的控件的一种抽象。ViewGroup内部包含了许多控件，是一组View，它们之间的关系如下图。 View的位置参数 View的位置由它的四个顶点决定，分别对应于View的四个属性：top, left, right, bottom 即它的四个坐标，并且这四个坐标都是相对与View的父容器来说的，是相对坐标。 width = right - left height = bottom - top MotionEvent和TouchSlop MotionEvent:在手指接触屏幕后所产生的一系列事件 ACTION_DOWN——手指刚接触屏幕 ACTION_MOVE——手指在屏幕上移动 ACTION_UP——手指从屏幕上松开的一瞬间 典型事件序列 点击屏幕后离开松开，事件序列为——DOWN -&gt; UP; 点击屏幕滑动一会儿在松开，事件序列为——DOWN-&gt;MOVE-&gt;…-&gt;MOVE-&gt;UP 通过MotionEvent对象可以得到点击事件发生的x和y坐标。 getX/getY——返回的是相对于当前View左上角的x和y坐标； getRawX/getRawY——返回的是相对于手机屏幕左上角的x和y坐标。 TouchSlop：系统所能识别的滑动的最小距离，当两次滑动之间的距离小于这个常量时，系统不能识别为是滑动事件，值和设备有关，通过如下方法可以获取这个常量。 ViewConfiguration.get(getContext()).getScaledTouchSlop(); VelocityTracker,GestureDetector和Scroller VelocityTracker：速度追踪，用于追踪手指在滑动过程中的速度，包括水平和竖直方向。 //1.首先在View的onTouchEvent方法中追踪当前点击事件的速度 VelocityTracker velocityTracker = VelocityTracker.obtain(); velocityTracker.addMovement(event); //2.获取当前速度 velocityTracker.computeCurrentVelocity(1000);//计算一个时间段内的速度 int xVelocity = (int) velocityTracker.getXVelocity(); int yVelocity = (int) velocityTracker.getYVelocity(); //3.重置并回收内存 velocityTracker.clear(); velocityTracker.recycle(); GestureDetector：手势检测，用于辅助检测用户的单击，滑动，长按，双击等行为。 //1.创建一个GestureDetector对象，实现onGestureListener接口 GestureDetector mGestureDetector = new GestureDetector(this); mGestureDetector.setIsLongpressEnabled(false);//解决长按屏幕后无法拖动的现象 //2.接管目标View的onTouchEvent方法,在其中使用 boolean consume = mGestureDetector.onTouchEvent(event); return consume; //3.选择实现onGestureListener和OnDoubleTapListener中的方法 //比如onSingleTapup():单击 ，onFling():滑动，onScroll():拖动，onLongPress():长按， //onDoubleTap():双击 Scroller：弹性滑动对象，用于实现View的弹性滑动。 Scroller mScroller = new Scroller(mContext); //缓慢滚动到指定位置 private void smoothScrollTo(int destX,int destY)&#123; int scrollX = getScrollX(); int delta = destX-scrollX; mScroller.startScroll(ScrollX,0,delta,0,1000); &#125; @Override public void computeScroll()&#123; if(mScroller.computeScrollOffset())&#123; smoothScrollTo(mScroller.getCurrX(),mScroller.getCurrY()); postInvalidate(); &#125; &#125; 3.2 View的滑动 使用ScrollTo/scrollBy public void scrollTo（ int x,int y）&#123; if(mScrollX != x||mScrollY !=y)&#123; int oldX = mScrollX; int oldY = mScrollY; mScrollX = x; mScrollY = y; invalidateParentCaches(); onScrollChanged(mScrollX,mScrollY,oldX,oldY); if(!awakenScrollBars())&#123; postInvalidateOnAnimation(); &#125; &#125; public void scrollBy(int x,int y)&#123; scrollTo(mScrollX + x,mScrollY + y); &#125; &#125; 在滑动过程中，mScrollX的值总是等于View左边缘和View内容左边缘在水平方向的距离；mScrollY的值等于View上边缘和View内容上边缘在竖直方向上的距离 scrollTo和scrollBy只能改变View内容的位置而不能改变View在布局中的位置。 如果从左向右滑动，那么mScrollX为负值，反之为正值；如果从上往下滑动，那么mScrollY为负值，反之为正值。 b 使用动画 &lt;!--View动画实现移动--&gt; &lt;translate android:duration="100" android:fromXDelta="0" android:fromYDelta="0" android:interpolator="@android:anim/linear_interpolator" android:toXDelta="100" android:toYDelta="100"/&gt; //属性动画实现移动 ObjectAnimator.ofFloat(targetView,"translationX",0,100) .setDuration(100) .start(); 改变布局参数：即改变LayoutParams MarginLayoutParams params = (MarginLayoutParams)mButton.getLayoutParams(); params.width +=100; params.leftMargin +=100; mButton.requestLayout(); //或者 mButton.setLayoutParams(params); 各种滑动方式的对比 scrollTo/scrollBy : 操作简单，适合对View内容的滑动 动画 ：操作简单，主要适用于没有交互的View和实现复杂的动画效果 改变布局参数 ：操作稍复杂，适用于有交互的View 3.3 弹性滑动 使用Scroller 当View重绘后会在在draw方法中调用computeScroll，而computeScroll又会去向当前Scroller获取当前的scrollX和scrollY；然后通过scrollTo方法实现滑动，然后继续重绘，循环反复。 通过动画 使用延时策略 通过发送一系列延时消息达到渐进式的效果，可以使用Handler或View的postDelayed方法。 3.4 View的事件分发机制 点击事件的传递规则 //点击事件分发过程中的三个重要方法 public boolean dispatchTouchEvent(MotionEvent e) //用来进行事件的分发 public boolean onInterceptTouchEvent(MotionEvent e) //用来判断是否拦截某个事件 public boolean onTouchEvent(MotionEvent e) //在dispatchTouchEvent中调用，用来处理点击事件 //三个方法的关系（伪代码） public boolean dispatchTouchEvent(MotionEvent e)&#123; boolean consume =false; if(onInterceptTouchEvent(e))&#123; consume =onTOuchEvent(e); &#125;else&#123; consume = child.dispatchTouchEvent(e); &#125; return consume; &#125; 当一个点击事件产生时，它的传递过程为：Activity -&gt; Window -&gt;View,即事件先传递给Activity，Activity再传递给Window，最后Window再传递给顶级View，顶级View接收到事件后，就会按照事件分发机制去分发事件。 PS： 同一个事件序列是指从手指接触屏幕那一刻起到手指离开屏幕的那一刻结束，在这一过程中产生的一系列事件； 正常情况下，一个事件序列只能被一个View拦截且消耗； 某个View一旦决定拦截，那么这个事件序列都只能由它处理，并且它的onInterceptTouchEvent不会被调用； 某个View一旦开始处理事件，如果它不消耗ACTION_DOWN(onTouchEvent返回false)，那么同一事件序列的其它事件都不会交由它处理，事件会重新交由它的父元素处理(调用父元素的onTouchEvent); ViewGroup默认不拦截任何事件； View没有onInterceptTouchEvent方法，一旦有点击 事件传递给它，它的onTouchEvent方法就会调用； View的onTouchEvent默认都会消耗事件(返回true)。除非它是不可点击的(clickable和longClickable都为false)； View的enable属性不影响onTouchEvent的默认返回值。、 onClick会发生的前提是当前View是可点击的，并且它收到了down和up事件； 事件传递过程是由外向内的，即事件总是先传递给父元素，再由父元素分发给子View，通过requestDisallowInterceptTouchEvent方法可以在子元素中干预父元素的事件分发过程，但是ACTION_DOWN事件除外。 事件分发的源码解析 Activity对点击事件的分发过程 当一个点击操作发生时，事件最先传递给当前Activity，由Activity的dispatchTouchEvent来进行事件分发，具体是由Activity的Window来完成的。Window会将事件传递给decor view，decor view 一般是当前界面的底层容器(即setContentView所设置的View的父容器)。 //Activity # dispatchTouchEvent public boolean dispatchTouchEvent(MotionEvent ev)&#123; if(ev.getAction() == MotionEvent.ACTION_DOWN)&#123; onUserInteraction(); &#125; //交由所附属的Window进行分发 if(getWindow().superDispatchTouchEvent(ev))&#123; return true; &#125; return onTouchEvent(ev);//所有View都没有处理，调用Activity的onTouchEvent() &#125; //Window的分发 //Window # superDispatchTouchEvent public abstract boolean superDispatchTouchEvent(MotionEvent event) //Window的唯一实现是PhoneWindow //PhoneWindow # superDispatchTouchEvent public boolean superDispatchTouchEvent(MotionEvent event)&#123; return mDecor.superDispatchTouchEvent(event); &#125; //DecorView private final class DecorView extends FrameLayout implements RootViewSurfaceTaker&#123; private DecorView mDecor; @Override public final View getDecorView()&#123; if(mDecor == null)&#123; installDecor(); &#125; return mDecor; &#125; &#125; 顶级View对点击事件的分发过程 点击事件到达顶级View(一般是ViewGroup)以后，会调用ViewGroup的dispatchTouchEvent方法，然后如果ViewGroup拦截事件(onInterceptTouchEvent返回true)，则事件由ViewGroup处理，此时如果ViewGroup设置了onTouchListener，则onTouch会被调用，否则调用onTouchEvent，且如果设置了onClickListener，则会调用onClick。如果顶级View不拦截，则事件会传递给它所在的点击事件链上的子View，调用子View的dispatchTouchEvent，如此循环，完成整个事件的分发。 //check for interception # dispatchTouchEvent # ViewGroup final boolean intercepted; if(actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null)&#123; final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if(!disallowIntercept)&#123; intercepted = onInterceptTouchEvent(ev); ev.setAction(action);//restore action in case it was changed &#125;else&#123; intercepted = true; &#125; &#125;else&#123; intercepated = true; &#125; onInterceptTouchEvent不是每次事件都会被调用，当事件能够传递到当前的ViewGroup时，dispatchTouchEvent会每次都调用 FLAG_DISALLOW_INTERCEPT标记可以让ViewGroup不再拦截事件 View对点击事件的处理过程 3.5 View的滑动冲突 常见的滑动冲突场景 外部滑动方向和内部滑动方向不一致 外部滑动方向和内部滑动方向一致 上面两种情况的嵌套 滑动冲突的处理规则 第一种滑动冲突：根据滑动时水平滑动还是竖直滑动来判断由谁拦截事件。 第二种滑动冲突：根据实际业务需求来进行处理 第三种滑动冲突：与第二种一致 滑动冲突的解决方式 外部拦截法 点击事件都先经过父容器的拦截处理，根据父容器的需求即可解决滑动冲突 内部拦截法 父容器不拦截任何事件，所有的事件都传递给子元素，子元素可以直接消耗掉或者交由父容器进行处理。需要配合requestDisallowInterceptTouchEvent方法才能正常工作。]]></content>
      <categories>
        <category>Android开发艺术探索</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发艺术探索学习笔记-第二章]]></title>
    <url>%2F2020%2F07%2F05%2FAndroid%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[Android开发艺术探索 第二章笔记第二章 IPC机制 Android IPC 简介IPC：Inter-Process Communication的缩写，意思为进程间通信或者跨进程通信，指两个进程之间进行数据交换的过程。 线程：CPU调度的最小单元，是一种有限的系统资源。 进程：一般指一个执行单元，在PC和移动设备上指一个程序或者应用。一个进程可以包含多个线程。 Android中的多进程模式 开启多进程模式 在Android中使用多进程只有一个方法，那就是给四大组件在AndroidManifest中指定android:process属性。 进程名以“：”开头的进程属于当前应用的私有进程，其他应用的组件不可以和它在同一进程中，而进程名不以“：”开头的进程属于全局进程，其他应用可以通过ShareUID方式和它在同一进程中。Android系统会为每个应用分配一个唯一的UID，具有相同UID的应用才能共享数据。(两个应用通过ShareUID在同一个进程张，不但ShareUID要相同，签名也必须相同才可以互相访问数据) 多进程模式运行机制 多进程造成的问题： 静态成员和单例模式完全失效。 线程同步机制完全失效。 SharedPreferences的可靠性下降。 Application会多次创建。 在多进程模式中，不同进程的组件会拥有独立的虚拟机，Application以及内存空间。 IPC基础概念介绍 Serializable接口：Java所提供的一个序列化接口，是一个空接口，为对象提供序列化和反序列化操作。 实现只要实现该接口，并且在类的声明中指定下面的标识即可自动实现默认的序列化操作。 public class User implements Serializable&#123; private static final long serialVersionUID = 871136882100083044L private String userName; private boolean isMale; ... 』 //序列化操作 User user = new User("Stephanie",false); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream("cache.txt")); out.writeObject(user); out.close //反序列化操作 ObjectInputStream in = new ObjectInputStream(new FileInputStream("cache.txt")); User user = (User)in.readObject(); in.close(); serialVersionUID工作机制：序列化时系统会将当前类的serialVersionUID写入序列化的文件中，当反序列化时系统会去检测文件中的serialVersionUID，看它是否和当前类的serialVersionUID一致，一致则说明版本相同可以成功反序列化；否则无法正常反序列化 Notice: 静态成员变量属于类不属于对象，所以不会参与序列化过程； 用transient关键字标记的成员变量不参与序列化过程。 通过重写readObject()和writeObject()方法可以改变系统的默认序列化过程。 Parcelable接口：Android提供的新的序列化方式。 //实现Parcelable典型用法 public class User implements Parcelable&#123; public int userId; public String userName; public boolean isMale; public Book book; //构造方法 public User(int UserId,String userName,boolean isMale)&#123; this.userId = userId; this.userName = userName; this.isMale = isMale; &#125; //返回当前对象的内容描述，含文件描述符返回1，否则返回0 public int describeContents()&#123; reaturn 0; &#125; //将当前对象写入序列化结构中，flags标识有两种值(0,1),为1时标识当前对象需要作为返回值返回，不能 //立即释放资源 public void writeToParcel(Parcel out,int flags)&#123; out.writeInt(userId); out.writeString(userName); out.writeInt(isMale ? 1 : 0); out.writeParcelable(book,0); &#125; //实现反序列化功能 public static final Parcelable.Creator&lt;User&gt; CREATER = new Parcelable.Creator&lt;User&gt;()&#123; //从序列化后的对象中创建原始对象 public User createrFromParcel(Parcel in)&#123; return new User(in); &#125; //创建指定长度的原始对象数组 public User[] newArray(int size)&#123; return new User[size]; &#125; &#125;; // private User(Parcel in)&#123; userId = in.readInt(); userName = in.readString(); isMale = in.readInt() == 1; book = in.readParcelable(Thread.currentThread().getContextClassLoader()); &#125; &#125; Parcelable 和Serializable选取： Serializable是Java中的序列化接口，使用简单但需要大量I/O操作，开销很大；Parcelable使用较麻烦但在Android平台上效率很高，所以首选Parcelable接口。 Binder:Binder是Android中的一种跨进程通信方式。在Android开发中，Binder主要用于Service中，包括AIDL和Messenger。 当客户端发起远程请求时，由于当前线程会被挂起直至服务端进程返回数据，所以不能在UI线程中发起耗时的远程请求； 由于服务打的Binder方法运行在Binder的线程池中，所以Binder方法不管是否耗时都应该采用同步的方法去实现。 Binder实现步骤 声明一个AIDL性质的接口，只需继承IInterface接口 实现Stub类和Stub类的Proxy代理类 给Binder设置死亡代理： 声明一个Deathecipient对象。Deathecipient是一个接口，我们需要实现其内部的回调方法binderDied private IBinder.DeathRecipient mDeathRecipient = new IBinder.DeathRecipient()&#123; @Override public void binderDied()&#123; if(mBookManager == null) return; mBookManager.asBinder().unlinkToDeath(mDeathRecipient,0); mBookManager = null; &#125; &#125; 在客户端绑定远程服务成功后，给binder设置死亡代理 mService = IMessageBoxManager.Stub.asInterface(binder); binder.linkToDeath(mDeathRecipient,0); 通过Binderd方法isBinderAlive可以判断Binder是否死亡 Android中IPC方式 使用Bundle 四大组件中的三大组件(Activity，Service，Receiver)都是支持Intent中传递Bundle数据的，由于Bundle实现了Parcelable接口，所以它可以在不同的进程之间传输。但是，传输的数据必须能够被序列化，比如基本类型和实现了Parcelable接口的对象。 使用文件共享 即两个进程通过读/写同一个文件来交换数据。除了可以交换一些文本信息外，还可以序列化一个对象到文件系统的同时另一个进程中恢复这个对象。 //MainActivity private void persistToFile()&#123; new Thread(new Runnable()&#123; @Override public void run()&#123; User user = new User(1,"hello world",false); File dir = new File(MyConstants.CHAPTER_2_PATH); if(!dir.exists())&#123; dir.mkdirs(); &#125; File cachedFile = new File(MyConstants.CACHE_FILE_PATH); ObjectOutputStream objectOutputStream = null; try&#123; objectOutputStream = new ObjectOutputStream(new FileOutputStream(cacheFile)); objectOutputStream.writeObject(user); Log.d(TAG,"persist user : " + user); &#125;catch(IOException e)&#123; e.printStackTrace(); &#125;finally&#123; MyUtils.close(objectOutputStream); &#125; &#125; &#125;).start(); &#125; //SecondActivity private void recoverFromFile()&#123; new Thread(new Runnable()&#123; @Override public void run()&#123; User user = null; File cachedFile = new File(MyConstants.CACHE_FILE_PATH); if(cachedFile.exists())&#123; ObjectInputStream objectInputStream = null; try&#123; objectInputStream = new ObjectInputStream(new FileInputStream( cachedFile)); user = (User) objectInputStream.readObject(); Log.d(TAG,"recover user :"+user); &#125;catch(IOException)&#123; e.printStackTrace(); &#125;catch(ClassNotFoundException e)&#123; e.printStackTrace(); &#125;finally&#123; MyUtils.close(objectInputStream); &#125; &#125; &#125; &#125;).start(); &#125; 文件共享方式适合在对数据同步要求不高的进程之间进行通信，并且要妥善处理并发读/写的问题。 使用Messenger 译为“信使”，可以在Message中放入需要传递的数据，通过它在不同进程中传递Message对象。它的底层实现是AIDL //Messenger的构造方法 public Messenger(Handler target)&#123; mTarget = target.getIMessenger(); &#125; public Messenger(IBinder target)&#123; mTarget = IMessenger.Stub.asInterface(target); &#125; Messenger一次处理一个请求，因此在服务端不用考虑线程同步的问题 实现Messenger的步骤： 服务端进程 首先在服务端创建一个Service来处理客户端的连接请求，同时创建一个Handler并通过它来创建 Messenger对象，然后在Service的onBind中返回Messenger对象底层的Binder。 客户端进程 首先绑定服务端的Service，绑定成功后用服务端返回的IBinder对象创建一个Messenger，通过这个Messenger就可以向服务端发送Message对象。 //服务端 public class MessengerService extends Service&#123; private static final String TAG = "MessengerService"; private static class MessengerHandler extend Handler&#123; @Override public void handleMessage(Message msg)&#123; switch(msg.what)&#123; case MyConstants.MSG_FROM_CLIENT: Log.i(TAG,"receive msg from client : "+msg.getData().getString("msg")); break; default: super.handleMessage(msg); &#125; &#125; &#125; &#125; //注册Service &lt;service android:name = "com.ryg.chapter_2.messenger.MessengerService" android:process = ":remote"&gt; //客户端 public class MessengerActivity extends Activity&#123; private static final String TAG = "MessengerActivity"; private Messenger mService; private ServicerConnection mConnection = new ServiceConnection()&#123; public void onServiceConnected(ComponentName className,IBinder service)&#123; mService = new Messenger(service); Message msg = Message.obtain(null,"MyConstants.MSG_FROM_CLIENT"); Bundle data = new Bundle(); data.putString("msg","hello ,this is client."); msg.setData(data); try&#123; mService.send(msg); &#125;catch(RemoteException e)&#123; e.printStackTrace(); &#125; &#125; public void onServiceDisconnected(ComponentName className)&#123;&#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState)&#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_messenger); Intent intent = new Intent(this,MessengerService.class); bindService(intent,mConnection,Conatext.BIND_AUTO_CREATE); &#125; @Override protected void onDestroy()&#123; unbindService(mConnection); super.onDestroy(); &#125; &#125; 使用AIDL AIDL的使用流程: 服务端 创建一个Service用来监听客户端的连接 创建一个AIDL文件声明给客户端的接口 在Service中实现这个AIDL接口 客户端 需要绑定服务端的Service 绑定成功后将服务端返回的Binder对象转换成AIDL接口所属的类型 AIDL接口的创建 //IBookManager.aidl package com.ryg.chapter_2.aidl import com.ryg.chapter_2.aidl.Book; interface IBookManager&#123; List&lt;Book&gt; getBookList(); void addBook(in Book book); &#125; AIDL文件支持的数据类型 基本数据类型(int , long , char , boolean , double等); String和CharSequence; List:只支持ArrayList,并且里面的每个元素都必须能够被AIDL支持； Map:只支持Hashap，并且里面的每个元素都必须能够被AIDL支持； Parcelabel：所有实现了Parcelable接口的对象； AIDL：所有的AIDL接口本身也可以在AIDL文件中使用。 自定义的Parcelable对象和AIDL对象必须要显式import进来，无论它是否与当前AIDL文件位于同一个包内。 如果AIDL文件中用到了自定义的Parcelable对象，必须新建一个和它同名的AIDL文件，并在其中声明它为Parcelabel类型。 AIDL中除了基本数据类型，其他类型的参数必须标上方向：in，out，inout AIDL中的定向 tag 表示了在跨进程通信中数据的流向,数据流向是针对在客户端中的那个传入方法的对象而言的。 ​ in： 表示数据只能由客户端流向服务端 ​ out：表示数据只能由服务端流向客户端 ​ inout：表示数据可在服务端与客户端之间双向流通 远程服务端Service的实现 //服务端Service public class BookManagerService extends Service&#123; private static final String TAG = "BMS"; //CopyOnWriteArrayList:支持并发读/写。 private CopyOnWriteArrayList&lt;Book&gt; mBookList = new CopyOnWriteArrayList&lt;Book&gt;(); private Binder mBinder = new IBookManager.Stub()&#123; @Override public List&lt;Book&gt; getBookList() throws RemoteException&#123; return mBookList; &#125; @Override public void addBook(Book book)throws RemoteException&#123; mBookList.add(Book); &#125; &#125;; @Override public void onCreate()&#123; super.onCreate(); mBookList.add(new Book(1,"Android")); mBookList.add(new Book(2,"IOS")); &#125; @Override public IBinder onBind(Intent intent)&#123; return mBinder; &#125; &#125; &lt;service android:name=".aidl.BookManagerService" android:process=":remote"/&gt; 客户端的实现 public class BookManagerActivity extends Activity&#123; private static final String TAG = "BookManagerActivity"; private ServiceConnection mConnection = new ServiceConnection()&#123; public void onServiceConnected(ComponentName className,IBinder service)&#123; IBookManager bookManager = IBookManager.Stub.asInterface(service); try&#123; List&lt;Book&gt; list = bookManager.getBookList(); Log.i(TAG,"query book list ,list"+ "type:"+list.getClass().getCanonicalName()); Log.i(TAG,"query book list :"+list.toString()); &#125;catch(RemoteException e)&#123; e.printStackTrace(); &#125; &#125; public void onServiceDisconnected(ComponentName className)&#123;&#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState)&#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_book_manager); Intent intent = new Intent(this,BookManagerService.class); bindService(intent,mConnection,Context.BIND_AUTOCREATE); &#125; @Override protected void onDestroy()&#123; unbindService(mConnection); super.onDestroy(); &#125; &#125; 6. 解除监听 `RemoteCallbackList`是系统提供的用于删除跨进程Listener的接口 //声明RemoteCalbackList private RemoteCallbackList&lt;IOnNewBookListener&gt; mListenerList = new RemoteCallbackList&lt;&gt;(); //修改注册和注销方法 public void registerListener(IOnNewBookListener listener) throws RemoteException&#123; mListener.register(listener); &#125; public void unregisterListener(IOnNewBookListener listener) throws RemoteException&#123; mListener.unregister(listener); &#125; //通知Listener int N = mListenerList.beginBroadcast(); for(int i = 0; i &lt; N; i++) &#123; IOnNewBookListener l = mListenerList.getBroadcastItem(i); if(l != null)&#123; ...... &#125; &#125; mListenerList.finishBroadcast(); &gt; RemoteCallbackList并不是一个List,遍历时必须按照上述流程进行，`beginBroadcast`和`finishBroadcast`必须要配对使用。 &gt; &gt; 客户端的`onServiceConnected`和`onServiceDisconnected`方法都运行在主线程，不能在其中直接调用服务端的耗时方法。 &gt; &gt; `onServiceDiscnnected`在客户端的UI线程中被回调，而`binderDied`在客户端的Binder线程池中被回调 7. 在AIDL中进行权限验证 - 在onBind中进行验证 - 在服务端的onTransact方法中进行验证 使用ContentProvider ContentProvider是Android中提供的用于不同应用间进行数据共享的方式,其底层实现是Binder。 自定义ContentProvider步骤： 继承自ContentProvider类 实现其中的抽象方法：onCreate,query,update,insert,delete和getType。 注册这个类 与query方法不同的是，update,insert和delete方法会引起数据源的改变，需要通过ContentResolver的notifyhange方法进行更新。 要观察一个ContentProvider中的数据变化，可以通过ContentResolver的registerContentObserver方法注册观察者，用unregisterContentObserver来进行解除。 使用Socket Socket，也称为“套接字”，它分为流式套接字和用户数据报套接字，分别对应与网络传输控制层中的TCP和UDP协议。两个进程可以通过Socket来实现信息的传输，Socket本身可以支持传输任意字节流。 Socket连接过程 Binder连接池将每个业务模块的Binder请求统一转发到远程Service中去执行，从而避免了重复创建Service。 选用合适的IPC方式| 名称 | 优点 | 缺点 | 适用场景 || ————— | ——————————— | —————————————- | ———————————- || Bundle | 简单易用 | 只能传输Bundle支持的数据类型 | 四大组件间的进程间通信 || 文件共享 | 简单易用 | 不适合高并发场景，并且无法做到进程间的即时通信 | 无并发访问情形，交换简单的数据实时性不高的场景 || AIDL | 功能强大 | 使用稍复杂，需要处理好线程同步 | 一对多通信且有RPC需求 || Messenger | 功能一般，支持一对多串行通信，支持实时通信 | 不能很好处理高并发，不支持RPC，数据只能通过Message传输Bundle支持的数据类型 | 低并发的一对多即时通信，无RPC需求，或者无须要返回结果的RPC需求 || ContentProvicer | 数据源访问功能强大，支持一对多并发数据共享，可通过Call方法扩展 | 可以理解为受约束的AIDL，主要提供数据源的CRUD操作 | 一对多的进程间的数据共享 || Socket | 功能强大，可以通过网络传输字节流，支持一对多并发实时通信 | 实现细节稍繁琐，不支持直接的RPC | 网络数据交换 |]]></content>
      <categories>
        <category>Android开发艺术探索</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发艺术探索学习笔记(第一章)]]></title>
    <url>%2F2020%2F06%2F27%2FAndroid%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E7%AC%AC%E4%B8%80%E7%AB%A0)%2F</url>
    <content type="text"><![CDATA[Android 开发艺术探索 第一章笔记第一章 Activity 的生命周期和启动模式Activity 的生命周期 典型情况下的生命周期 : 在用户参与的情况下，Activity 所经过的生命周期的改变 onRestart:Activity 正在重新启动。 onCreate:Activity 正在被创建。可以在这个方法中进行初始化工作，比如加载界面布局资源，初始化数据等。 onStart:Activity 正在被启动，此时 Activity 已经可见，但是没有出现在前台，无法和用户进行交互。 onResume:Activity 已经可见，且出现在前台开始活动。 onPause:Activity 正在停止。 onStop:Activity 即将停止，可以做一些回收工作，但不能太耗时。 onDestroy:Activity 即将被销毁，生命周期最后一个回调，可以做一些回收工作和最终资源的释放。 (1) 一个 Activity 第一次启动时的回调为:onCreate-&gt;onStart-&gt;onResume (2)打开新的 Activity 或切换到桌面时的回调为:onPause-&gt;onStop(如果新 Activity 采用了透明主题，则不会调用 onStop) (3)再次回到原 Activity 时的回调为:onRestart-&gt;onStart-&gt;onResume (4)使用 back 键回退时的回调:onPause-&gt;onStop-&gt;onDestroy Remarks:onStart 和 onStop 是从 Activity 是否可见的角度进行回调的;onResume 和 onPause 是从 Activity 是否位于前台的角度。 异常情况下的生命周期 : Activity 被系统回收或者当前设备的 Configuration 发生改变而导致 Activity 被销毁重建 资源相关的系统配置发生改变导致 Activity 被杀死并重新创建 资源内存不足导致低优先级的 Activity 被杀死 Activity 优先级情况(由高到低) 前台 Activity ——正在与用户交互的 Activity，优先级最高 可见但非前台 Activity 后台 Activity ——已经被暂停的 Activity Activity 的启动模式 Activity 的 LaunchMode standard:标准模式。每次启动一个 Activity 都会重新创建一个新的实例，不管这个实例是否已经存在。在这种模式下，谁启动了这个 Activity，那么这个 Activity 就运行在启动它的那个 Activity 所在的栈中。 singleTop:栈顶复用模式。在这种模式下，如果新的 Activity 已经位于任务栈的栈顶，那么此 Activity 不会被重新创建，同时它的 onNewIntent 方法会被回调，并且这个 Activity 的 onCreate,onStart 不会被系统调用;如果新 Activity 的实例已存在但不是位于栈顶，那么新 Activity 仍然会重新创建。 singleTask:栈内复用模式。这是一种单实例模式，在这种模式下，只要 Activity 在一个栈中存在，那么多次启动此 Activity 都不会重新创建实例。 singleInstance:单实例模式。除了具有 singleTask 模式的所有特性外，在这种模式下的 Activity 只能单独地位于一个任务栈中。 TaskAffinity:任务相关性。这个参数标识了一个 Activity 所需要的任务栈的名字，默认情况下为应用的包名。TaskAffinity 属性主要和 singleTask 启动模式或者 AllowTaskReparenting 属性配对使用；任务栈分为前台任务栈和后台任务栈，后台任务栈中的 Activity 处于暂停状态。 给 Activity 指定启动模式 通过 AndroidManifest 文件给 Activity 指定启动模式 &lt;activity android:name="com.ryg.chapter_1.secondActivity" android:configChanges="screenLayout" android:launchMode="singleTask" android:label="@string/app_name"/&gt; 通过在 Intent 中设置标志位为 Activity 指定启动模式 Intent intent = new Intent(); intent.setClass(MainActivity.this,SecondActivity.class); intent.addFlags(Intetn.FLAG_ACTIVITY_NEW_TASK); startActivity(intent); 两种方式的区别： 第二种的优先级要高于第一种，当两种同时存在时，以第二种方式为准； 第一种方式无法直接为 Activity 设定 FLAG_ACTIVITY_CLEAR_TOP 标识，而第二种方式无法为 Activity 指定 singlenstance 模式 Activity的Flags FLAG_ACTIVITY_NEW_TASK:为Activity指定“singleTask”启动模式 FLAG_ACTIVITY_SINGLE_TOP:为Activity指定“singleTop”启动模式 FLAG_ACTIVITY_CLEAR_TOP:具有此标记位的Activity启动时，在同一个任务栈中所有位于它上面的Activity都要出栈 FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS:具有此标记的Activity不会出现在历史Activity的列表中。 IntentFilter 的匹配规则 action(字符串)的匹配规则：Intent 中的 action 必须能够和过滤规则中的 action 匹配，即 action 的字符串值完全一样。一个过滤规则中可以有多个 action，只要 Intent 中的 action 能够和过滤规则中的任何一个 action 相同即可匹配成功。但如果 Intent 中没有指定 action，则匹配失败，并且 action 区分大小写。 category(字符串)的匹配规则：它要求 Intent 中如果含有 category，那么所有的 category 都必须和过滤规则中的其中一个 category 相同。如果 Intent 中没有，仍然可以匹配成功。 data 的匹配规则 结构：由 mimeType 和 URI 两部分组成。其中 mimeType 指的是媒体类型，URI 是资源地址。 &lt;!-- 语法 --&gt; &lt;data android:scheme="string" android:host="string" android:port="string" android:path="string" andrid:pathPattern="string" android:pathPrefix="string" android:mimeType="string" /&gt; &lt;!-- 结构 --&gt; &lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;/[&lt;path&gt;|&lt;pathPrefix&gt;|&lt;pathPattern&gt;] 2. 匹配规则：Intent中必须含有data数据，并且data数据能够完全匹配过滤规则中的某一个data]]></content>
      <categories>
        <category>Android开发艺术探索</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown基本语法速查]]></title>
    <url>%2F2020%2F03%2F27%2FMarkdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E9%80%9F%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[MarkDown基本语法 简介 Markdown是一种轻量级标记语言，创始人为约翰·格鲁伯（英语：John Gruber）。它允许人们使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML（或者HTML）文档。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。 由于Markdown的轻量化、易读易写特性，并且对于图片，图表、数学式都有支持，当前许多网站都广泛使用Markdown来撰写帮助文档或是用于论坛上发表消息。如GitHub、Reddit、Diaspora、Stack Exchange、OpenStreetMap 、SourceForge、简书等，甚至还能被使用来撰写电子书。 ​ —WikiPedia 基本命令 标题 # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 字体 **加粗** *斜体* ~~删除线~~ &lt;u&gt;下划线&lt;/u&gt; `注释` ==高亮== 列表 ## 有序列表 1. 2. 3. ## 无序列表 - - - ## 任务列表 - [ ] 任务1 - [ ] 任务2 - [x] 任务3 引用 &gt; 这是引用部分内容 代码块 ​public static void main(String[] args) &#123; &#125; ​ 表格 | First Header | Second Header | | ------------- | ------------- | | Content Cell | Content Cell | | Content Cell | Content Cell | 目录 [TOC] 链接 超链接 [链接名称](链接地址) - 图片链接 ![图片名称](图片地址) 脚注 You can create footnotes like this[^footnote]. [^footnote]: Here is the *text* of the **footnote**. Emoji表情 :smile: :kissing_smiling_eyes::kissing_smiling_eyes: 视频 &lt;video src=&quot;xxx.mp4&quot; HTML &lt;span style=&quot;color:red&quot;&gt;红色的文本&lt;/span&gt; 绘制结构图 流程图 ## Flowchart.js ​st=&gt;start: Start op=&gt;operation: Your Operation cond=&gt;condition: Yes or No? e=&gt;end st-&gt;op-&gt;cond cond(yes)-&gt;e cond(no)-&gt;op ## Mermaid ​&lt;pre class=&quot;mermaid&quot;&gt; graph LR A[Hard edge] --&gt;B(Round edge) B --&gt; C&#123;Decision&#125; C --&gt;|One| D[Result one] C --&gt;|Two| E[Result two] ​&lt;/pre&gt; 时序图 ## js-sequence ​Alice-&gt;Bob: Hello Bob, how are you? Note right of Bob: Bob thinks Bob--&gt;Alice: I am good thanks! ​ ## Mermaid ​&lt;pre class=&quot;mermaid&quot;&gt; %% Example of sequence diagram sequenceDiagram Alice-&gt;&gt;Bob: Hello Bob, how are you? alt is sick Bob-&gt;&gt;Alice: Not so good :( else is well Bob-&gt;&gt;Alice: Feeling fresh like a daisy end opt Extra response Bob-&gt;&gt;Alice: Thanks for asking end ​&lt;/pre&gt; 甘特图 ## Mermaid ​&lt;pre class=&quot;mermaid&quot;&gt; %% Example with selection of syntaxes gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d ​&lt;/pre&gt; 类图 ## Mermaid ​&lt;pre class=&quot;mermaid&quot;&gt; classDiagram Animal &lt;|-- Duck Animal &lt;|-- Fish Animal &lt;|-- Zebra Animal : +int age Animal : +String gender Animal: +isMammal() Animal: +mate() class Duck{ +String beakColor +swim() +quack() } class Fish{ -int sizeInFeet -canEat() } class Zebra{ +bool is_wild +run() } ​&lt;/pre&gt; 状态图 ​&lt;pre class=&quot;mermaid&quot;&gt; stateDiagram [*] --&gt; Still Still --&gt; [*] Still --&gt; Moving Moving --&gt; Still Moving --&gt; Crash Crash --&gt; [*] ​&lt;/pre&gt; - 饼图 ​&lt;pre class="mermaid"&gt; pie title Pie Chart "Dogs" : 386 "Cats" : 85 "Rats" : 150 ​&lt;/pre&gt; 4. 数学公式 ```markdown ## 行内公式 $ a^2 + b^2 = c^2 $ ## 行间公式 $$ y = x ^ &#123;2&#125; x_&#123;a + b&#125; x^&#123;a + b&#125; $$ 符号 代码 具体含义 $\sum$ $\sum$ 求和公式 $\sum_{i=0}^n$ $\sum_{i=0}^n$ 求和上下标 $\times$ $\times$ 乘号 $\pm$ $\pm$ 正负号 $\div$ $\div$ 除号 $\mid$ $\mid$ 竖线 $\cdot$ $\cdot$ 点 $\circ$ $\circ$ 圈 $\ast $ $\ast $ 星号 $\bigotimes$ $\bigotimes$ 克罗内克积 $\bigoplus$ $\bigoplus$ 异或 $\leq$ $\leq$ 小于等于 $\geq$ $\geq$ 大于等于 $\neq$ $\neq$ 不等于 $\approx$ $\approx$ 约等于 $\prod$ $\prod$ N元乘积 $\coprod$ $\coprod$ N元余积 $\cdots$ $\cdots$ 省略号 $\int$ $\int$ 积分 $\iint$ $\iint$ 双重积分 $\oint$ $\oint$ 曲线积分 $\infty$ $\infty$ 无穷 $\nabla$ $\nabla$ 梯度 $\because$ $\because$ 因为 $\therefore$ $\therefore$ 所以 $\forall$ $\forall$ 任意 $\exists$ $\exists$ 存在 $\not=$ $\not=$ 不等于 $\not&gt;$ $\not&gt;$ 不大于 $\leq$ $\leq$ 小于等于 $\geq$ $\geq$ 大于等于 $\not\subset$ $\not\subset$ 不属于 $\emptyset$ $\emptyset$ 空集 $\in$ $\in$ 属于 $\notin$ $\notin$ 不属于 $\subset$ $\subset$ 子集 $\subseteq$ $\subseteq$ 真子集 $\bigcup$ $\bigcup$ 并集 $\bigcap$ $\bigcap$ 交集 $\bigvee$ $\bigvee$ 逻辑或 $\bigwedge$ $\bigwedge$ 逻辑与 $\alpha$ $\alpha$ $\beta$ $\beta$ $\gamma$ $\gamma$ $\Gamma$ $\Gamma$ $\delta$ $\delta$ $\Delta$ $\Delta$ $\epsilon$ $\epsilon$ $\varepsilon$ $\varepsilon$ $\zeta$ $\zeta$ $\eta$ $\eta$ $\theta$ $\theta$ $\Theta$ $\Theta$ ϑ $\vartheta$ ι $\iota$ π $\pi$ ϕ $\phi$ Φ $\Phi$ ψ $\psi$ Ψ $\Psi$ ω $\omega$ Ω $\Omega$ χ \chi ρ $\rho$ ο $\omicron$ σ $\sigma$ Σ $\Sigma$ ν $\nu$ ξ $\xi$ τ $\tau$ λ $\lambda$ Λ $\Lambda$ μ \mu ∂ $\partial$ {} $\lbrace \rbrace$ a $\overline{a}$ ​]]></content>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ProtocolBuffers-基本使用]]></title>
    <url>%2F2020%2F03%2F12%2FProtocolBuffers-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Protocol Buffers​ 一种跨语言，跨平台的可扩展的序列化数据格式 相比XML的优势 更简单 更轻量（数据体积小3~10倍） 更快速（20～100倍） 自动化生成更易于编码方式使用的数据访问类 使用方法 graph TD; A[定义protobuf消息格式] --> B[编译protobuf]; B --> C[使用protobuf API进行读写]; 使用protobuf语法描述需要存储的数据结构（编写．proto文件） syntax = "proto3"; //默认为proto2,不能为空 package tutorial; //避免命名冲突 option java_package = "com.example.tutorial"; //生成类的包结构 option java_outer_classname = "AddressBookProtos"; //生成包括当前文件所有类的类名，默认是MyProto,生成my_proto.proto，不能与内部定义的类名称相同（不能设为AddressBook） message Person &#123; string name = 1; //用于二进制编码的唯一标识 int32 id = 2; string email = 3; enum PhoneType &#123; MOBILE = 0; //必须包含标识０，用于设置默认值和与proto2语义兼容 HOME = 1; WORK = 2; &#125; message PhoneNumber &#123; string number = 1; PhoneType type = 2 [packed = HOME]; &#125; PhoneNumber phones = 4; &#125; message AddressBook &#123; Person people = 1; &#125; 基本语法（proto3）： 消息是各种类型数据的集合， 可以包含bool,int32,float,double,string,枚举或者其他的消息 标识的范围为1 ~ 2^29^ - 1,1~15的标识比较高的数字少一个字节进行编码，适宜一些常用或者重复的字段;16以上的适用不太常使用的可选字段;19000 ~ 19999不可使用，为内置保留． 每个字段都必须标明注解： required:该字段必须设置值，否则该消息将被视为“未初始化”,构建未初始化的消息将抛出RuntimeException,解析未初始化的消息将抛出IOException;除此之外与optional一致 optional:该字段是可选字段，可以设置值也可以不设置值。如果不设置值，则使用默认值． repeated:该字段可以重复任意次数（包括零），重复值的顺序将保留在protobuf中。可将其视为动态大小的数组． Any字段： &gt; import "google/protobuf/any.proto"; &gt; &gt; message ErrorStatus &#123; &gt; string message = 1; &gt; google.protobuf.Any details = 2; &gt; &#125; &gt; Oneof字段： 一个.proto文件中可以定义多种消息 每个message类以及它的子类有自己的builder类 ，通过builder类来进行设置 数据类型 不能在proto3中直接导入proto2的枚举进行使用，要导入其消息． Map类型 &gt; map&lt;key_type, value_type&gt; map_field = N; &gt; map&lt;string, Project&gt; projects = 3; &gt; 1. `key_type` 可以是任何 int 或者 string 类型(任何的标量类型，具体可以见上面标量类型对应表格，但是要除去 float、double 和 bytes) 2. `value_type` 可以是除去 map 以外的任何类型。 定义service 如果要使用 RPC（远程过程调用）系统的消息类型，可以在 .proto 文件中定义 RPC 服务接口，protocol buffer 编译器将使用所选语言生成服务接口代码和 stubs &gt; //参数为SearchRequest,返回值为SearchResponse &gt; service SearchService &#123; &gt; rpc Search (SearchRequest) returns (SearchResponse); &gt; &#125; &gt; JSON Map 如果一个值在json编码的数据中丢失或者它的值是null, 在被解析成protocol buffer时它将设置为对应的默认值.如果一个字段的值正好是protocol buffer的默认值, 这个字段默认就不会出现在json编码的数据中以便节约空间. 通过protobuf编译器编译．proto文件（生成对应平台的文件） 使用命令 ##命令格式 protoc [option] PROTO_FILES ##Java protoc -I=$SRC_DIR --java_out=$DST_DIR $SRC_DIR/addressbook.proto ##Python protoc -I=$SRC_DIR --python_out=$DST_DIR $SRC_DIR/addressbook.proto SRC_DIR:源代码路径，默认为当前文件夹 DST_DIR:生成的代码路径，默认与SRC_DIR相同 –Java_out:生成不同语言对应的文件 对于Android使用Java Lite可以减小生成类的体积 1.安装java_lite环境 2.编译java_lite版文件 &gt; protoc --javalite_out=$DST_DIR PROTO_FILES &gt; 使用Android Studio 安装Protocol Support插件 配置gradle 编写．proto文件 编译项目 使用protobuf进行数据读写 除了访问器，生成的类中还有其它的方法： 消息构建接口 isInitialized():检测 所有required的字段是否有被设置 toString(): 生成可读的字符串 mergeFrom(Message other): (builder only)与另一个消息进行合并 clear(): (builder only) 将所有字段清除为空状态 解析接口 byte[] toByteArray();: 序列化数据 static Person parseFrom(byte[] data);: 反序列化数据 void writeTo(OutputStream output);: 序列化数据并写入OutputStream static Person parseFrom(InputStream input);: 从InputStream中解析读取消息 具体Demo 兼容处理 如果要让新版本向后兼容，旧版本向前兼容，需要遵守以下规则 不能修改已存在字段的标识（tag） 不能添加或删除required字段 可以删除optional或repeated字段 可以增加optional或repeated字段，但必须使用没有用过的标识，已经删除的也不能用]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo基本命令]]></title>
    <url>%2F2020%2F03%2F10%2FHexo%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[inithexo init [folder] 新建一个网站 hexo newhexo new [layout] &lt;title&gt; 新建一个title.md文档 hexo generate(hexo g) 选项 描述 -d, –deploy 文件生成后立即部署网站 -w, –watch 监视文件变动 -b, –bail 生成过程中如果发生任何未处理的异常则抛出异常 -f, –force 强制重新生成文件 Hexo 引入了差分机制，如果 public 目录存在，那么 hexo g 只会重新生成改动的文件。 使用该参数的效果接近 hexo clean &amp;&amp; hexo generate -c, –concurrency 最大同时生成文件的数量，默认无限制 生成网站静态文件到默认设置的 public 文件夹 publishhexo publish [layout] &lt;fileName&gt; 发表草稿 hexo server(hexo s) 启动服务器，默认网址为http://localhost:4000/ 项 描述 -p, –port 重设端口 -s, –static 只使用静态文件 -l, –log 启动日记记录，使用覆盖记录格式 hexo deploy(hexo d) 部署网站到服务器 参数 描述 -g, –generate 部署之前预先生成静态文件 hexo clean 清除缓存文件 (db.json) 和已生成的静态文件 (public)。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
