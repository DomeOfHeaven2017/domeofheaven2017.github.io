<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android开发艺术探索学习笔记(第一章)]]></title>
    <url>%2F2020%2F06%2F27%2FAndroid%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E7%AC%AC%E4%B8%80%E7%AB%A0)%2F</url>
    <content type="text"><![CDATA[Android 开发艺术探索 第一章笔记第一章 Activity 的生命周期和启动模式Activity 的生命周期 典型情况下的生命周期 : 在用户参与的情况下，Activity 所经过的生命周期的改变 onRestart:Activity 正在重新启动。 onCreate:Activity 正在被创建。可以在这个方法中进行初始化工作，比如加载界面布局资源，初始化数据等。 onStart:Activity 正在被启动，此时 Activity 已经可见，但是没有出现在前台，无法和用户进行交互。 onResume:Activity 已经可见，且出现在前台开始活动。 onPause:Activity 正在停止。 onStop:Activity 即将停止，可以做一些回收工作，但不能太耗时。 onDestroy:Activity 即将被销毁，生命周期最后一个回调，可以做一些回收工作和最终资源的释放。 (1) 一个 Activity 第一次启动时的回调为:onCreate-&gt;onStart-&gt;onResume (2)打开新的 Activity 或切换到桌面时的回调为:onPause-&gt;onStop(如果新 Activity 采用了透明主题，则不会调用 onStop) (3)再次回到原 Activity 时的回调为:onRestart-&gt;onStart-&gt;onResume (4)使用 back 键回退时的回调:onPause-&gt;onStop-&gt;onDestroy Remarks:onStart 和 onStop 是从 Activity 是否可见的角度进行回调的;onResume 和 onPause 是从 Activity 是否位于前台的角度。 异常情况下的生命周期 : Activity 被系统回收或者当前设备的 Configuration 发生改变而导致 Activity 被销毁重建 资源相关的系统配置发生改变导致 Activity 被杀死并重新创建 资源内存不足导致低优先级的 Activity 被杀死 Activity 优先级情况(由高到低) 前台 Activity ——正在与用户交互的 Activity，优先级最高 可见但非前台 Activity 后台 Activity ——已经被暂停的 Activity Activity 的启动模式 Activity 的 LaunchMode standard:标准模式。每次启动一个 Activity 都会重新创建一个新的实例，不管这个实例是否已经存在。在这种模式下，谁启动了这个 Activity，那么这个 Activity 就运行在启动它的那个 Activity 所在的栈中。 singleTop:栈顶复用模式。在这种模式下，如果新的 Activity 已经位于任务栈的栈顶，那么此 Activity 不会被重新创建，同时它的 onNewIntent 方法会被回调，并且这个 Activity 的 onCreate,onStart 不会被系统调用;如果新 Activity 的实例已存在但不是位于栈顶，那么新 Activity 仍然会重新创建。 singleTask:栈内复用模式。这是一种单实例模式，在这种模式下，只要 Activity 在一个栈中存在，那么多次启动此 Activity 都不会重新创建实例。 singleInstance:单实例模式。除了具有 singleTask 模式的所有特性外，在这种模式下的 Activity 只能单独地位于一个任务栈中。 TaskAffinity:任务相关性。这个参数标识了一个 Activity 所需要的任务栈的名字，默认情况下为应用的包名。TaskAffinity 属性主要和 singleTask 启动模式或者 AllowTaskReparenting 属性配对使用；任务栈分为前台任务栈和后台任务栈，后台任务栈中的 Activity 处于暂停状态。 给 Activity 指定启动模式 通过 AndroidManifest 文件给 Activity 指定启动模式 &lt;activity android:name="com.ryg.chapter_1.secondActivity" android:configChanges="screenLayout" android:launchMode="singleTask" android:label="@string/app_name"/&gt; 通过在 Intent 中设置标志位为 Activity 指定启动模式 Intent intent = new Intent(); intent.setClass(MainActivity.this,SecondActivity.class); intent.addFlags(Intetn.FLAG_ACTIVITY_NEW_TASK); startActivity(intent); 两种方式的区别： 第二种的优先级要高于第一种，当两种同时存在时，以第二种方式为准； 第一种方式无法直接为 Activity 设定 FLAG_ACTIVITY_CLEAR_TOP 标识，而第二种方式无法为 Activity 指定 singlenstance 模式 Activity的Flags FLAG_ACTIVITY_NEW_TASK:为Activity指定“singleTask”启动模式 FLAG_ACTIVITY_SINGLE_TOP:为Activity指定“singleTop”启动模式 FLAG_ACTIVITY_CLEAR_TOP:具有此标记位的Activity启动时，在同一个任务栈中所有位于它上面的Activity都要出栈 FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS:具有此标记的Activity不会出现在历史Activity的列表中。 IntentFilter 的匹配规则 action(字符串)的匹配规则：Intent 中的 action 必须能够和过滤规则中的 action 匹配，即 action 的字符串值完全一样。一个过滤规则中可以有多个 action，只要 Intent 中的 action 能够和过滤规则中的任何一个 action 相同即可匹配成功。但如果 Intent 中没有指定 action，则匹配失败，并且 action 区分大小写。 category(字符串)的匹配规则：它要求 Intent 中如果含有 category，那么所有的 category 都必须和过滤规则中的其中一个 category 相同。如果 Intent 中没有，仍然可以匹配成功。 data 的匹配规则 结构：由 mimeType 和 URI 两部分组成。其中 mimeType 指的是媒体类型，URI 是资源地址。 &lt;!-- 语法 --&gt; &lt;data android:scheme="string" android:host="string" android:port="string" android:path="string" andrid:pathPattern="string" android:pathPrefix="string" android:mimeType="string" /&gt; &lt;!-- 结构 --&gt; &lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;/[&lt;path&gt;|&lt;pathPrefix&gt;|&lt;pathPattern&gt;] 2. 匹配规则：Intent中必须含有data数据，并且data数据能够完全匹配过滤规则中的某一个data]]></content>
      <tags>
        <tag>Android</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown基本语法速查]]></title>
    <url>%2F2020%2F03%2F27%2FMarkdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E9%80%9F%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[MarkDown基本语法 简介 Markdown是一种轻量级标记语言，创始人为约翰·格鲁伯（英语：John Gruber）。它允许人们使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML（或者HTML）文档。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。 由于Markdown的轻量化、易读易写特性，并且对于图片，图表、数学式都有支持，当前许多网站都广泛使用Markdown来撰写帮助文档或是用于论坛上发表消息。如GitHub、Reddit、Diaspora、Stack Exchange、OpenStreetMap 、SourceForge、简书等，甚至还能被使用来撰写电子书。 ​ —WikiPedia 基本命令 标题 # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 字体 **加粗** *斜体* ~~删除线~~ &lt;u&gt;下划线&lt;/u&gt; `注释` ==高亮== 列表 ## 有序列表 1. 2. 3. ## 无序列表 - - - ## 任务列表 - [ ] 任务1 - [ ] 任务2 - [x] 任务3 引用 &gt; 这是引用部分内容 代码块 ​public static void main(String[] args) &#123; &#125; ​ 表格 | First Header | Second Header | | ------------- | ------------- | | Content Cell | Content Cell | | Content Cell | Content Cell | 目录 [TOC] 链接 超链接 [链接名称](链接地址) - 图片链接 ![图片名称](图片地址) 脚注 You can create footnotes like this[^footnote]. [^footnote]: Here is the *text* of the **footnote**. Emoji表情 :smile: :kissing_smiling_eyes::kissing_smiling_eyes: 视频 &lt;video src=&quot;xxx.mp4&quot; HTML &lt;span style=&quot;color:red&quot;&gt;红色的文本&lt;/span&gt; 绘制结构图 流程图 ## Flowchart.js ​st=&gt;start: Start op=&gt;operation: Your Operation cond=&gt;condition: Yes or No? e=&gt;end st-&gt;op-&gt;cond cond(yes)-&gt;e cond(no)-&gt;op ## Mermaid ​&lt;pre class=&quot;mermaid&quot;&gt; graph LR A[Hard edge] --&gt;B(Round edge) B --&gt; C&#123;Decision&#125; C --&gt;|One| D[Result one] C --&gt;|Two| E[Result two] ​&lt;/pre&gt; 时序图 ## js-sequence ​Alice-&gt;Bob: Hello Bob, how are you? Note right of Bob: Bob thinks Bob--&gt;Alice: I am good thanks! ​ ## Mermaid ​&lt;pre class=&quot;mermaid&quot;&gt; %% Example of sequence diagram sequenceDiagram Alice-&gt;&gt;Bob: Hello Bob, how are you? alt is sick Bob-&gt;&gt;Alice: Not so good :( else is well Bob-&gt;&gt;Alice: Feeling fresh like a daisy end opt Extra response Bob-&gt;&gt;Alice: Thanks for asking end ​&lt;/pre&gt; 甘特图 ## Mermaid ​&lt;pre class=&quot;mermaid&quot;&gt; %% Example with selection of syntaxes gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d ​&lt;/pre&gt; 类图 ## Mermaid ​&lt;pre class=&quot;mermaid&quot;&gt; classDiagram Animal &lt;|-- Duck Animal &lt;|-- Fish Animal &lt;|-- Zebra Animal : +int age Animal : +String gender Animal: +isMammal() Animal: +mate() class Duck{ +String beakColor +swim() +quack() } class Fish{ -int sizeInFeet -canEat() } class Zebra{ +bool is_wild +run() } ​&lt;/pre&gt; 状态图 ​&lt;pre class=&quot;mermaid&quot;&gt; stateDiagram [*] --&gt; Still Still --&gt; [*] Still --&gt; Moving Moving --&gt; Still Moving --&gt; Crash Crash --&gt; [*] ​&lt;/pre&gt; - 饼图 ​&lt;pre class="mermaid"&gt; pie title Pie Chart "Dogs" : 386 "Cats" : 85 "Rats" : 150 ​&lt;/pre&gt; 4. 数学公式 ```markdown ## 行内公式 $ a^2 + b^2 = c^2 $ ## 行间公式 $$ y = x ^ &#123;2&#125; x_&#123;a + b&#125; x^&#123;a + b&#125; $$ 符号 代码 具体含义 $\sum$ $\sum$ 求和公式 $\sum_{i=0}^n$ $\sum_{i=0}^n$ 求和上下标 $\times$ $\times$ 乘号 $\pm$ $\pm$ 正负号 $\div$ $\div$ 除号 $\mid$ $\mid$ 竖线 $\cdot$ $\cdot$ 点 $\circ$ $\circ$ 圈 $\ast $ $\ast $ 星号 $\bigotimes$ $\bigotimes$ 克罗内克积 $\bigoplus$ $\bigoplus$ 异或 $\leq$ $\leq$ 小于等于 $\geq$ $\geq$ 大于等于 $\neq$ $\neq$ 不等于 $\approx$ $\approx$ 约等于 $\prod$ $\prod$ N元乘积 $\coprod$ $\coprod$ N元余积 $\cdots$ $\cdots$ 省略号 $\int$ $\int$ 积分 $\iint$ $\iint$ 双重积分 $\oint$ $\oint$ 曲线积分 $\infty$ $\infty$ 无穷 $\nabla$ $\nabla$ 梯度 $\because$ $\because$ 因为 $\therefore$ $\therefore$ 所以 $\forall$ $\forall$ 任意 $\exists$ $\exists$ 存在 $\not=$ $\not=$ 不等于 $\not&gt;$ $\not&gt;$ 不大于 $\leq$ $\leq$ 小于等于 $\geq$ $\geq$ 大于等于 $\not\subset$ $\not\subset$ 不属于 $\emptyset$ $\emptyset$ 空集 $\in$ $\in$ 属于 $\notin$ $\notin$ 不属于 $\subset$ $\subset$ 子集 $\subseteq$ $\subseteq$ 真子集 $\bigcup$ $\bigcup$ 并集 $\bigcap$ $\bigcap$ 交集 $\bigvee$ $\bigvee$ 逻辑或 $\bigwedge$ $\bigwedge$ 逻辑与 $\alpha$ $\alpha$ $\beta$ $\beta$ $\gamma$ $\gamma$ $\Gamma$ $\Gamma$ $\delta$ $\delta$ $\Delta$ $\Delta$ $\epsilon$ $\epsilon$ $\varepsilon$ $\varepsilon$ $\zeta$ $\zeta$ $\eta$ $\eta$ $\theta$ $\theta$ $\Theta$ $\Theta$ ϑ $\vartheta$ ι $\iota$ π $\pi$ ϕ $\phi$ Φ $\Phi$ ψ $\psi$ Ψ $\Psi$ ω $\omega$ Ω $\Omega$ χ \chi ρ $\rho$ ο $\omicron$ σ $\sigma$ Σ $\Sigma$ ν $\nu$ ξ $\xi$ τ $\tau$ λ $\lambda$ Λ $\Lambda$ μ \mu ∂ $\partial$ {} $\lbrace \rbrace$ a $\overline{a}$ ​]]></content>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ProtocolBuffers-基本使用]]></title>
    <url>%2F2020%2F03%2F12%2FProtocolBuffers-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Protocol Buffers​ 一种跨语言，跨平台的可扩展的序列化数据格式 相比XML的优势 更简单 更轻量（数据体积小3~10倍） 更快速（20～100倍） 自动化生成更易于编码方式使用的数据访问类 使用方法 graph TD; A[定义protobuf消息格式] --> B[编译protobuf]; B --> C[使用protobuf API进行读写]; 使用protobuf语法描述需要存储的数据结构（编写．proto文件） syntax = "proto3"; //默认为proto2,不能为空 package tutorial; //避免命名冲突 option java_package = "com.example.tutorial"; //生成类的包结构 option java_outer_classname = "AddressBookProtos"; //生成包括当前文件所有类的类名，默认是MyProto,生成my_proto.proto，不能与内部定义的类名称相同（不能设为AddressBook） message Person &#123; string name = 1; //用于二进制编码的唯一标识 int32 id = 2; string email = 3; enum PhoneType &#123; MOBILE = 0; //必须包含标识０，用于设置默认值和与proto2语义兼容 HOME = 1; WORK = 2; &#125; message PhoneNumber &#123; string number = 1; PhoneType type = 2 [packed = HOME]; &#125; PhoneNumber phones = 4; &#125; message AddressBook &#123; Person people = 1; &#125; 基本语法（proto3）： 消息是各种类型数据的集合， 可以包含bool,int32,float,double,string,枚举或者其他的消息 标识的范围为1 ~ 2^29^ - 1,1~15的标识比较高的数字少一个字节进行编码，适宜一些常用或者重复的字段;16以上的适用不太常使用的可选字段;19000 ~ 19999不可使用，为内置保留． 每个字段都必须标明注解： required:该字段必须设置值，否则该消息将被视为“未初始化”,构建未初始化的消息将抛出RuntimeException,解析未初始化的消息将抛出IOException;除此之外与optional一致 optional:该字段是可选字段，可以设置值也可以不设置值。如果不设置值，则使用默认值． repeated:该字段可以重复任意次数（包括零），重复值的顺序将保留在protobuf中。可将其视为动态大小的数组． Any字段： &gt; import "google/protobuf/any.proto"; &gt; &gt; message ErrorStatus &#123; &gt; string message = 1; &gt; google.protobuf.Any details = 2; &gt; &#125; &gt; Oneof字段： 一个.proto文件中可以定义多种消息 每个message类以及它的子类有自己的builder类 ，通过builder类来进行设置 数据类型 不能在proto3中直接导入proto2的枚举进行使用，要导入其消息． Map类型 &gt; map&lt;key_type, value_type&gt; map_field = N; &gt; map&lt;string, Project&gt; projects = 3; &gt; 1. `key_type` 可以是任何 int 或者 string 类型(任何的标量类型，具体可以见上面标量类型对应表格，但是要除去 float、double 和 bytes) 2. `value_type` 可以是除去 map 以外的任何类型。 定义service 如果要使用 RPC（远程过程调用）系统的消息类型，可以在 .proto 文件中定义 RPC 服务接口，protocol buffer 编译器将使用所选语言生成服务接口代码和 stubs &gt; //参数为SearchRequest,返回值为SearchResponse &gt; service SearchService &#123; &gt; rpc Search (SearchRequest) returns (SearchResponse); &gt; &#125; &gt; JSON Map 如果一个值在json编码的数据中丢失或者它的值是null, 在被解析成protocol buffer时它将设置为对应的默认值.如果一个字段的值正好是protocol buffer的默认值, 这个字段默认就不会出现在json编码的数据中以便节约空间. 通过protobuf编译器编译．proto文件（生成对应平台的文件） 使用命令 ##命令格式 protoc [option] PROTO_FILES ##Java protoc -I=$SRC_DIR --java_out=$DST_DIR $SRC_DIR/addressbook.proto ##Python protoc -I=$SRC_DIR --python_out=$DST_DIR $SRC_DIR/addressbook.proto SRC_DIR:源代码路径，默认为当前文件夹 DST_DIR:生成的代码路径，默认与SRC_DIR相同 –Java_out:生成不同语言对应的文件 对于Android使用Java Lite可以减小生成类的体积 1.安装java_lite环境 2.编译java_lite版文件 &gt; protoc --javalite_out=$DST_DIR PROTO_FILES &gt; 使用Android Studio 安装Protocol Support插件 配置gradle 编写．proto文件 编译项目 使用protobuf进行数据读写 除了访问器，生成的类中还有其它的方法： 消息构建接口 isInitialized():检测 所有required的字段是否有被设置 toString(): 生成可读的字符串 mergeFrom(Message other): (builder only)与另一个消息进行合并 clear(): (builder only) 将所有字段清除为空状态 解析接口 byte[] toByteArray();: 序列化数据 static Person parseFrom(byte[] data);: 反序列化数据 void writeTo(OutputStream output);: 序列化数据并写入OutputStream static Person parseFrom(InputStream input);: 从InputStream中解析读取消息 具体Demo 兼容处理 如果要让新版本向后兼容，旧版本向前兼容，需要遵守以下规则 不能修改已存在字段的标识（tag） 不能添加或删除required字段 可以删除optional或repeated字段 可以增加optional或repeated字段，但必须使用没有用过的标识，已经删除的也不能用]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo基本命令]]></title>
    <url>%2F2020%2F03%2F10%2FHexo%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[inithexo init [folder] 新建一个网站 hexo newhexo new [layout] &lt;title&gt; 新建一个title.md文档 hexo generate(hexo g) 选项 描述 -d, –deploy 文件生成后立即部署网站 -w, –watch 监视文件变动 -b, –bail 生成过程中如果发生任何未处理的异常则抛出异常 -f, –force 强制重新生成文件 Hexo 引入了差分机制，如果 public 目录存在，那么 hexo g 只会重新生成改动的文件。 使用该参数的效果接近 hexo clean &amp;&amp; hexo generate -c, –concurrency 最大同时生成文件的数量，默认无限制 生成网站静态文件到默认设置的 public 文件夹 publishhexo publish [layout] &lt;fileName&gt; 发表草稿 hexo server(hexo s) 启动服务器，默认网址为http://localhost:4000/ 项 描述 -p, –port 重设端口 -s, –static 只使用静态文件 -l, –log 启动日记记录，使用覆盖记录格式 hexo deploy(hexo d) 部署网站到服务器 参数 描述 -g, –generate 部署之前预先生成静态文件 hexo clean 清除缓存文件 (db.json) 和已生成的静态文件 (public)。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
