<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Markdown基本语法速查]]></title>
    <url>%2F2020%2F03%2F27%2FMarkdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E9%80%9F%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[MarkDown基本语法 简介 Markdown是一种轻量级标记语言，创始人为约翰·格鲁伯（英语：John Gruber）。它允许人们使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML（或者HTML）文档。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。 由于Markdown的轻量化、易读易写特性，并且对于图片，图表、数学式都有支持，当前许多网站都广泛使用Markdown来撰写帮助文档或是用于论坛上发表消息。如GitHub、Reddit、Diaspora、Stack Exchange、OpenStreetMap 、SourceForge、简书等，甚至还能被使用来撰写电子书。 ​ —WikiPedia 基本命令 标题 # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 字体 **加粗** *斜体* ~~删除线~~ &lt;u&gt;下划线&lt;/u&gt; `注释` ==高亮== 列表 ## 有序列表 1. 2. 3. ## 无序列表 - - - ## 任务列表 - [ ] 任务1 - [ ] 任务2 - [x] 任务3 引用 &gt; 这是引用部分内容 代码块 ​public static void main(String[] args) &#123; &#125; ​ 表格 | First Header | Second Header | | ------------- | ------------- | | Content Cell | Content Cell | | Content Cell | Content Cell | 目录 [TOC] 链接 超链接 [链接名称](链接地址) - 图片链接 ![图片名称](图片地址) 脚注 You can create footnotes like this[^footnote]. [^footnote]: Here is the *text* of the **footnote**. Emoji表情 :smile: :kissing_smiling_eyes::kissing_smiling_eyes: 视频 &lt;video src=&quot;xxx.mp4&quot; HTML &lt;span style=&quot;color:red&quot;&gt;红色的文本&lt;/span&gt; 绘制结构图 流程图 ## Flowchart.js ​st=&gt;start: Start op=&gt;operation: Your Operation cond=&gt;condition: Yes or No? e=&gt;end st-&gt;op-&gt;cond cond(yes)-&gt;e cond(no)-&gt;op ## Mermaid ​&lt;pre class=&quot;mermaid&quot;&gt; graph LR A[Hard edge] --&gt;B(Round edge) B --&gt; C&#123;Decision&#125; C --&gt;|One| D[Result one] C --&gt;|Two| E[Result two] ​&lt;/pre&gt; 时序图 ## js-sequence ​Alice-&gt;Bob: Hello Bob, how are you? Note right of Bob: Bob thinks Bob--&gt;Alice: I am good thanks! ​ ## Mermaid ​&lt;pre class=&quot;mermaid&quot;&gt; %% Example of sequence diagram sequenceDiagram Alice-&gt;&gt;Bob: Hello Bob, how are you? alt is sick Bob-&gt;&gt;Alice: Not so good :( else is well Bob-&gt;&gt;Alice: Feeling fresh like a daisy end opt Extra response Bob-&gt;&gt;Alice: Thanks for asking end ​&lt;/pre&gt; 甘特图 ## Mermaid ​&lt;pre class=&quot;mermaid&quot;&gt; %% Example with selection of syntaxes gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d ​&lt;/pre&gt; 类图 ## Mermaid ​&lt;pre class=&quot;mermaid&quot;&gt; classDiagram Animal &lt;|-- Duck Animal &lt;|-- Fish Animal &lt;|-- Zebra Animal : +int age Animal : +String gender Animal: +isMammal() Animal: +mate() class Duck{ +String beakColor +swim() +quack() } class Fish{ -int sizeInFeet -canEat() } class Zebra{ +bool is_wild +run() } ​&lt;/pre&gt; 状态图 ​&lt;pre class=&quot;mermaid&quot;&gt; stateDiagram [*] --&gt; Still Still --&gt; [*] Still --&gt; Moving Moving --&gt; Still Moving --&gt; Crash Crash --&gt; [*] ​&lt;/pre&gt; - 饼图 ​&lt;pre class=&quot;mermaid&quot;&gt; pie title Pie Chart &quot;Dogs&quot; : 386 &quot;Cats&quot; : 85 &quot;Rats&quot; : 150 ​&lt;/pre&gt; 4. 数学公式 ```markdown ## 行内公式 $ a^2 + b^2 = c^2 $ ## 行间公式 $$ y = x ^ &#123;2&#125; x_&#123;a + b&#125; x^&#123;a + b&#125; $$ 符号 代码 具体含义 $\sum$ $\sum$ 求和公式 $\sum_{i=0}^n$ $\sum_{i=0}^n$ 求和上下标 $\times$ $\times$ 乘号 $\pm$ $\pm$ 正负号 $\div$ $\div$ 除号 $\mid$ $\mid$ 竖线 $\cdot$ $\cdot$ 点 $\circ$ $\circ$ 圈 $\ast $ $\ast $ 星号 $\bigotimes$ $\bigotimes$ 克罗内克积 $\bigoplus$ $\bigoplus$ 异或 $\leq$ $\leq$ 小于等于 $\geq$ $\geq$ 大于等于 $\neq$ $\neq$ 不等于 $\approx$ $\approx$ 约等于 $\prod$ $\prod$ N元乘积 $\coprod$ $\coprod$ N元余积 $\cdots$ $\cdots$ 省略号 $\int$ $\int$ 积分 $\iint$ $\iint$ 双重积分 $\oint$ $\oint$ 曲线积分 $\infty$ $\infty$ 无穷 $\nabla$ $\nabla$ 梯度 $\because$ $\because$ 因为 $\therefore$ $\therefore$ 所以 $\forall$ $\forall$ 任意 $\exists$ $\exists$ 存在 $\not=$ $\not=$ 不等于 $\not&gt;$ $\not&gt;$ 不大于 $\leq$ $\leq$ 小于等于 $\geq$ $\geq$ 大于等于 $\not\subset$ $\not\subset$ 不属于 $\emptyset$ $\emptyset$ 空集 $\in$ $\in$ 属于 $\notin$ $\notin$ 不属于 $\subset$ $\subset$ 子集 $\subseteq$ $\subseteq$ 真子集 $\bigcup$ $\bigcup$ 并集 $\bigcap$ $\bigcap$ 交集 $\bigvee$ $\bigvee$ 逻辑或 $\bigwedge$ $\bigwedge$ 逻辑与 $\alpha$ $\alpha$ $\beta$ $\beta$ $\gamma$ $\gamma$ $\Gamma$ $\Gamma$ $\delta$ $\delta$ $\Delta$ $\Delta$ $\epsilon$ $\epsilon$ $\varepsilon$ $\varepsilon$ $\zeta$ $\zeta$ $\eta$ $\eta$ $\theta$ $\theta$ $\Theta$ $\Theta$ ϑ $\vartheta$ ι $\iota$ π $\pi$ ϕ $\phi$ Φ $\Phi$ ψ $\psi$ Ψ $\Psi$ ω $\omega$ Ω $\Omega$ χ \chi ρ $\rho$ ο $\omicron$ σ $\sigma$ Σ $\Sigma$ ν $\nu$ ξ $\xi$ τ $\tau$ λ $\lambda$ Λ $\Lambda$ μ \mu ∂ $\partial$ {} $\lbrace \rbrace$ a $\overline{a}$ ​]]></content>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ProtocolBuffers-基本使用]]></title>
    <url>%2F2020%2F03%2F12%2FProtocolBuffers-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Protocol Buffers​ 一种跨语言，跨平台的可扩展的序列化数据格式 相比XML的优势 更简单 更轻量（数据体积小3~10倍） 更快速（20～100倍） 自动化生成更易于编码方式使用的数据访问类 使用方法 graph TD; A[定义protobuf消息格式] --> B[编译protobuf]; B --> C[使用protobuf API进行读写]; 使用protobuf语法描述需要存储的数据结构（编写．proto文件） syntax = "proto3"; //默认为proto2,不能为空 package tutorial; //避免命名冲突 option java_package = "com.example.tutorial"; //生成类的包结构 option java_outer_classname = "AddressBookProtos"; //生成包括当前文件所有类的类名，默认是MyProto,生成my_proto.proto，不能与内部定义的类名称相同（不能设为AddressBook） message Person &#123; string name = 1; //用于二进制编码的唯一标识 int32 id = 2; string email = 3; enum PhoneType &#123; MOBILE = 0; //必须包含标识０，用于设置默认值和与proto2语义兼容 HOME = 1; WORK = 2; &#125; message PhoneNumber &#123; string number = 1; PhoneType type = 2 [packed = HOME]; &#125; PhoneNumber phones = 4; &#125; message AddressBook &#123; Person people = 1; &#125; 基本语法（proto3）： 消息是各种类型数据的集合， 可以包含bool,int32,float,double,string,枚举或者其他的消息 标识的范围为1 ~ 2^29^ - 1,1~15的标识比较高的数字少一个字节进行编码，适宜一些常用或者重复的字段;16以上的适用不太常使用的可选字段;19000 ~ 19999不可使用，为内置保留． 每个字段都必须标明注解： required:该字段必须设置值，否则该消息将被视为“未初始化”,构建未初始化的消息将抛出RuntimeException,解析未初始化的消息将抛出IOException;除此之外与optional一致 optional:该字段是可选字段，可以设置值也可以不设置值。如果不设置值，则使用默认值． repeated:该字段可以重复任意次数（包括零），重复值的顺序将保留在protobuf中。可将其视为动态大小的数组． Any字段： &gt; import "google/protobuf/any.proto"; &gt; &gt; message ErrorStatus &#123; &gt; string message = 1; &gt; google.protobuf.Any details = 2; &gt; &#125; &gt; Oneof字段： 一个.proto文件中可以定义多种消息 每个message类以及它的子类有自己的builder类 ，通过builder类来进行设置 数据类型 不能在proto3中直接导入proto2的枚举进行使用，要导入其消息． Map类型 &gt; map&lt;key_type, value_type&gt; map_field = N; &gt; map&lt;string, Project&gt; projects = 3; &gt; 1. `key_type` 可以是任何 int 或者 string 类型(任何的标量类型，具体可以见上面标量类型对应表格，但是要除去 float、double 和 bytes) 2. `value_type` 可以是除去 map 以外的任何类型。 定义service 如果要使用 RPC（远程过程调用）系统的消息类型，可以在 .proto 文件中定义 RPC 服务接口，protocol buffer 编译器将使用所选语言生成服务接口代码和 stubs &gt; //参数为SearchRequest,返回值为SearchResponse &gt; service SearchService &#123; &gt; rpc Search (SearchRequest) returns (SearchResponse); &gt; &#125; &gt; JSON Map 如果一个值在json编码的数据中丢失或者它的值是null, 在被解析成protocol buffer时它将设置为对应的默认值.如果一个字段的值正好是protocol buffer的默认值, 这个字段默认就不会出现在json编码的数据中以便节约空间. 通过protobuf编译器编译．proto文件（生成对应平台的文件） 使用命令 ##命令格式 protoc [option] PROTO_FILES ##Java protoc -I=$SRC_DIR --java_out=$DST_DIR $SRC_DIR/addressbook.proto ##Python protoc -I=$SRC_DIR --python_out=$DST_DIR $SRC_DIR/addressbook.proto SRC_DIR:源代码路径，默认为当前文件夹 DST_DIR:生成的代码路径，默认与SRC_DIR相同 –Java_out:生成不同语言对应的文件 对于Android使用Java Lite可以减小生成类的体积 1.安装java_lite环境 2.编译java_lite版文件 &gt; protoc --javalite_out=$DST_DIR PROTO_FILES &gt; 使用Android Studio 安装Protocol Support插件 配置gradle 编写．proto文件 编译项目 使用protobuf进行数据读写 除了访问器，生成的类中还有其它的方法： 消息构建接口 isInitialized():检测 所有required的字段是否有被设置 toString(): 生成可读的字符串 mergeFrom(Message other): (builder only)与另一个消息进行合并 clear(): (builder only) 将所有字段清除为空状态 解析接口 byte[] toByteArray();: 序列化数据 static Person parseFrom(byte[] data);: 反序列化数据 void writeTo(OutputStream output);: 序列化数据并写入OutputStream static Person parseFrom(InputStream input);: 从InputStream中解析读取消息 具体Demo 兼容处理 如果要让新版本向后兼容，旧版本向前兼容，需要遵守以下规则 不能修改已存在字段的标识（tag） 不能添加或删除required字段 可以删除optional或repeated字段 可以增加optional或repeated字段，但必须使用没有用过的标识，已经删除的也不能用]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo基本命令]]></title>
    <url>%2F2020%2F03%2F10%2FHexo%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[inithexo init [folder] 新建一个网站 hexo newhexo new [layout] &lt;title&gt; 新建一个title.md文档 hexo generate(hexo g) 选项 描述 -d, –deploy 文件生成后立即部署网站 -w, –watch 监视文件变动 -b, –bail 生成过程中如果发生任何未处理的异常则抛出异常 -f, –force 强制重新生成文件 Hexo 引入了差分机制，如果 public 目录存在，那么 hexo g 只会重新生成改动的文件。 使用该参数的效果接近 hexo clean &amp;&amp; hexo generate -c, –concurrency 最大同时生成文件的数量，默认无限制 生成网站静态文件到默认设置的 public 文件夹 publishhexo publish [layout] &lt;fileName&gt; 发表草稿 hexo server(hexo s) 启动服务器，默认网址为http://localhost:4000/ 项 描述 -p, –port 重设端口 -s, –static 只使用静态文件 -l, –log 启动日记记录，使用覆盖记录格式 hexo deploy(hexo d) 部署网站到服务器 参数 描述 -g, –generate 部署之前预先生成静态文件 hexo clean 清除缓存文件 (db.json) 和已生成的静态文件 (public)。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
