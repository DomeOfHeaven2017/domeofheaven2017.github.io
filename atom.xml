<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DomeOfHeaven</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-09-20T13:56:23.519Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>DomeOfHeaven</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android知识总结-BroadcastReceiver</title>
    <link href="http://yoursite.com/2020/09/20/Android%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93-BroadcastReceiver/"/>
    <id>http://yoursite.com/2020/09/20/Android知识总结-BroadcastReceiver/</id>
    <published>2020-09-20T13:55:45.000Z</published>
    <updated>2020-09-20T13:56:23.519Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h4 id="BroadcastReceiver知识总结"><a href="#BroadcastReceiver知识总结" class="headerlink" title="BroadcastReceiver知识总结"></a>BroadcastReceiver知识总结</h4><hr><h5 id="一-定义"><a href="#一-定义" class="headerlink" title="一.定义"></a>一.定义</h5><p>BroadcastReceiver是Android四大组件之一，是一种消息型组件，用于在不同的组件乃至不同的应用之间传递消息。其内部通信通过<code>binder</code>机制实现</p><h5 id="二-广播种类"><a href="#二-广播种类" class="headerlink" title="二. 广播种类"></a>二. 广播种类</h5><pre class="mermaid">graph LRa[广播] --> b[无序广播]a --> c[有序广播]a --> d[本地广播]a --> e[粘性广播]</pre><ul><li><p>无序广播</p><p>也称为标准广播，是一种异步执行的广播，在广播发出之后，所有的广播接收器都能接收到该广播，没有先后顺序且接收者无法修改发送的数据</p><pre><code class="hljs java">context.sendBroadcast(intent);</code></pre></li><li><p>有序广播</p><p>是一种同步执行的广播，同一时刻只有一个广播接收器能收到这条广播，高优先级的接收者可以修改其中要发送的内容，其处理完毕后才会继续传递给下一个接收者</p><pre><code class="hljs java"><span class="hljs-comment">//发送广播</span>context.sendOrderedBroadcast(intent);<span class="hljs-comment">//拦截广播</span>abortBroadcast();<span class="hljs-comment">//传递数据给下一个接收者</span>setResultData</code></pre><p>通过设置<code>android:property</code>属性来设置优先级，未设置时默认按照注册的顺序接收广播</p><p>优先级对无序广播也生效，动态注册的广播优先级按先后顺序。</p></li><li><p>本地广播(已被废弃，可以自行依赖或使用LiveData代替)</p><p>只在App内传递的广播，发送和注册都要使用<code>LocalBroadcastManager</code>类实现</p><pre><code class="hljs java"><span class="hljs-comment">//发送广播</span>LocalBroadcastManager.getInstance(context).sendBroadcast(intent);<span class="hljs-comment">//注册广播</span>LocalBroadcastManager.getInstance(context).registerReceiver(receiver, intentFiter);</code></pre><p>内部通过<code>Handler</code>进行实现，与其它广播相比它无需跨进程，内部保存了两个Map集合，<em>mReceivers</em>和<em>mActions</em>进行协作。</p><p>本地广播无法通过静态注册方式来接收。</p></li><li><p>粘性广播</p><p>在广播发送结束后会保存刚刚发送的广播(Intent),接收者在注册完之后可以继续使用刚才的广播。</p><pre><code class="hljs java"><span class="hljs-comment">//发送广播</span>context.sendStickyBroadcast(intent);<span class="hljs-comment">//移除广播</span>context.removeStickyBroadcast(intent);</code></pre><p>如果在接收者注册完成前发送了多条相同<code>action</code>的粘性广播，注册完成后只会收到最后一条该<code>action</code>的广播</p><p>发送粘性广播时需要添加</p><p><code>android:name=&quot;android.permission.BROADCAST_STICKY&quot;</code></p></li></ul><h5 id="三-注册方式"><a href="#三-注册方式" class="headerlink" title="三. 注册方式"></a>三. 注册方式</h5><ul><li><p>静态注册</p><ol><li><p>创建广播接收器类</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyReceiver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BroadcastReceiver</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onReceive</span><span class="hljs-params">(Context context, Intent intent)</span> </span>&#123;        ....    &#125;&#125;</code></pre></li><li><p>在AndroidManifest中注册</p><pre><code class="hljs xml">&lt;receiver android:name="&#123;创建接收器类路径&#125;"          android:exported="true"&gt;    &lt;intent-filter&gt;        &lt;action android:name="&#123;接收器类响应的action&#125;"    &lt;/intent-filter&gt;&lt;/receiver&gt;</code></pre><p><code>android:exported</code>表示是否接收其他App发送的广播，当为false时只能接收同一应用的组件或具有相同userId的应用发送的消息。有<code>intent-filter</code>默认为true，没有默认为false</p><p><code>android:permission</code>设置该属性后只有具有相应权限的广播发送方发送的广播才能被此接收者接收，没有设置默认赋予整个应用申请的权限</p></li></ol></li><li><p>动态注册</p><ol><li><p>创建广播接收器类,一般创建在内部</p></li><li><p>调用方法进行注册与注销</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyReceiver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BroadcastReceiver</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onReceive</span><span class="hljs-params">(Context context, Intent intent)</span> </span>&#123;        ....    &#125;&#125;<span class="hljs-comment">//注册</span>context.registerReceiver(receiver, intentFilter);<span class="hljs-comment">//注销</span>context.unregisterReceiver(receiver);</code></pre><p>动态广播可以自由控制注册与注销，但必须要在程序启动后才能接收到广播</p></li></ol></li></ul><h5 id="四-实现机制"><a href="#四-实现机制" class="headerlink" title="四. 实现机制"></a>四. 实现机制</h5><p>基于消息发布/订阅事件模型进行实现，使用了观察者模式。其中消息订阅者是广播接收者，消息发布者是发布方，消息中心是ActivityManagerService,具体流程如下</p><ol><li>广播接收者通过<code>binder</code>机制在<code>AMS</code>中进行注册</li><li>发送方通过<code>binder</code>向<code>AMS</code>发送广播</li><li><code>AMS</code>根据发送方要求(IntentFilter,Permission)在已注册列表中查找广播接收者</li><li><code>AMS</code>将广播发送到查找到的接收者相应的消息队列中</li><li>接收者通过消息循环获取到该广播，并回调<code>onReceive</code>方法</li></ol><h5 id="五-常用系统广播"><a href="#五-常用系统广播" class="headerlink" title="五. 常用系统广播"></a>五. 常用系统广播</h5><table><thead><tr><th>action</th><th>mean</th></tr></thead><tbody><tr><td>Intent.ACTION_PACKAGE_ADDED</td><td>成功安装Apk</td></tr><tr><td>Intent.ACTION_PACKAGE_REMOVED</td><td>成功删除Apk</td></tr><tr><td>Intent.ACTION_REBOOT</td><td>重启设备</td></tr><tr><td>Intent.ACTION_BOOT_COMPETED</td><td>系统启动完成(仅广播一次)</td></tr><tr><td>Intent.ACTION_BATIERY_LOW</td><td>电量过低</td></tr></tbody></table><h5 id="六-补充"><a href="#六-补充" class="headerlink" title="六. 补充"></a>六. 补充</h5><ul><li>BroadcastReceiver不能执行耗时操作，BroadcastReceiver一般处于主线程，会导致<code>ANR</code>.</li><li>广播中启动<code>Activity</code>需要添加<code>FLAG_ACTIVITY_NEW_TASK</code>标记</li><li>广播中弹出<code>Alertdialog</code>需要设置对话框类型为<code>TYPE_SYSTEM_ALERT</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h4 id=&quot;BroadcastReceiver知识总结&quot;&gt;&lt;a href=&quot;#BroadcastReceiver知识总结&quot; class=&quot;headerlink&quot; title=&quot;BroadcastReceiver知识总结&quot;&gt;&lt;/a&gt;BroadcastR
      
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android知识总结-Activity</title>
    <link href="http://yoursite.com/2020/09/19/Android%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93-Activity/"/>
    <id>http://yoursite.com/2020/09/19/Android知识总结-Activity/</id>
    <published>2020-09-19T14:15:28.000Z</published>
    <updated>2020-09-19T14:15:59.486Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h4 id="Activity知识总结"><a href="#Activity知识总结" class="headerlink" title="Activity知识总结"></a>Activity知识总结</h4><h5 id="一-定义"><a href="#一-定义" class="headerlink" title="一. 定义"></a>一. 定义</h5><ul><li><p>概念</p><p>Activity是应用与用户互动的接口，提供窗口供应用在其中绘制界面</p></li><li><p>使用</p><ol><li><p>创建继承Activity的自定义类，实现界面显示功能</p><pre><code class="hljs Kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span></span>() &#123;    ....&#125;</code></pre></li><li><p>配置清单</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 声明Activity --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">maniest</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">application</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">activity</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"&#123;自定义类类名&#125;"</span>                  <span class="hljs-attr">android:permission</span>=<span class="hljs-string">"&#123;自定义权限&#125;"</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 声明intent过滤器--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"&#123;自定义action&#125;"</span> /&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">category</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"xxx"</span> /&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">data</span> <span class="hljs-attr">android:mimeType</span>=<span class="hljs-string">"xxx"</span> /&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">activity</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">application</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">maniest</span>&gt;</span></code></pre><blockquote><p>借助Intent过滤器，既可以根据显式请求启动Activity,也可以通过隐式请求启动Activity</p></blockquote></li></ol></li></ul><h5 id="二-生命周期"><a href="#二-生命周期" class="headerlink" title="二. 生命周期"></a>二. 生命周期</h5><p><img src="https://gitee.com/domeofheaven2017/Image/raw/master/BlogImage/图1-1Activity生命周期切换过程.png" srcset="/img/loading.gif" alt></p><h6 id="Activity的四种状态"><a href="#Activity的四种状态" class="headerlink" title="Activity的四种状态"></a>Activity的四种状态</h6><blockquote><p>active:运行状态，当前Activity获取焦点</p><p>paused:暂停状态，当前Activity失去焦点，仍然可见</p><p>stopped:不可见但成员变量等依然存在</p><p>killed:被销毁，成员变量等被收回</p></blockquote><h6 id="Activity的生命周期"><a href="#Activity的生命周期" class="headerlink" title="Activity的生命周期"></a>Activity的生命周期</h6><ul><li><p>生命周期方法含义</p><ol><li>onRestart:Activity 正在重新启动。</li><li>onCreate:Activity 正在被创建。可以在这个方法中进行初始化工作，比如加载界面布局资源，初始化数据等。</li><li>onStart:Activity 正在被启动，此时 Activity 已经<strong><em>\</em>可见**</strong>，但是<strong><em>\</em>没有出现在前台**</strong>，无法和用户进行交互。</li><li>onResume:Activity 已经可见，且<strong><em>\</em>出现在前台开始活动**</strong>。</li><li>onPause:Activity 正在停止。</li><li>onStop:Activity 即将停止，可以做一些回收工作，但不能太耗时。</li><li>onDestroy:Activity 即将被销毁，生命周期最后一个回调，可以做一些回收工作和最终资源的释放。</li></ol></li><li><p>正常情况下的声明周期</p><ol><li>一个 Activity 第一次启动时的回调为:onCreate-&gt;onStart-&gt;onResume</li><li><em>打开新的 Activity 或切换到桌面时的回调为:onPause-&gt;onStop(如果新 Activity 采用了透明主题，则不会调用 onStop)</em></li><li>再次回到原 Activity 时的回调为:onRestart-&gt;onStart-&gt;onResume</li><li><em>使用 back 键回退时的回调:onPause-&gt;onStop-&gt;onDestroy</em></li></ol></li><li><p>Dialog弹出时</p><ol><li>如果是创建的dialog,由于依附的是当前的Activity,不会执行生命周期方法</li><li>跳转到一个不是全屏的Activity：<em>onPause -&gt; onStop</em></li></ol></li><li><p>横竖屏切换时</p><ol><li>不设置<code>android:configChanges</code>，切屏会重新调用各个生命周期，切横屏时执行一次，切竖屏时执行两次</li><li>设置<code>android:configChanges=“orientation&quot;</code>时，切屏还是会重新调用各个生命周期，横屏和竖屏只会执行一次</li><li>设置<code>android:configChanges=&quot;orientation|keyboardHidden&quot;</code>时，切屏不会调用各个生命周期，只会执行<code>onConfigurationChanged</code>方法</li></ol></li><li><p>锁屏与解锁时</p><p>锁屏时只会调用<em>onPause</em>，不会调用<em>onStop</em>方法，解锁后调用<em>onResume</em></p></li><li><p>异常退出</p><ul><li><p>Activity异常退出的生命周期：<em>onPause</em> –&gt; <em>onSaveInstanceState</em> –&gt; <em>onStop</em> –&gt; <em>onDestroy</em></p><blockquote><p><em>onPause</em>与<em>onSaveInstanceState</em>没有严格的先后关系，可能在<em>onPause</em>前，也可能在其后，但会在<em>onStop</em>之前调用</p></blockquote></li><li><p>异常退出又重新启动：<em>onCreate</em> –&gt; <em>onStart</em> –&gt; <em>onRestoreInstanceState</em> –&gt; <em>onResume</em></p></li><li><p>如果要恢复原有Activity,则在<em>onSaveInstanceState</em>中保存数据，在<em>onRestoreInstanceState</em>中进行恢复。</p></li></ul></li></ul><h5 id="三-任务栈与启动模式"><a href="#三-任务栈与启动模式" class="headerlink" title="三. 任务栈与启动模式"></a>三. 任务栈与启动模式</h5><h6 id="任务栈"><a href="#任务栈" class="headerlink" title="任务栈"></a>任务栈</h6><ul><li><p>任务：用户在执行某项工作时与之互动的一系列Activity集合</p><p>每个Activity都是相互独立的界面，通过任务这个概念多个Activity关联组成一个应用。应用中的入口Activity作为任务中的根Activity。</p></li><li><p>返回栈(任务栈)</p><p>返回栈是任务的实际载体，每个任务中所有的Activity都会按照各自的打开顺序保存在对应的返回栈中。由于是栈结构(先入后出)，外部只能访问栈顶的Activity,所以一个Activity要显示就必须在栈顶</p></li><li><p>进栈与出栈</p><p>从当前Activity启动另一个Activity时，新的Activity被推送至栈顶，获取到焦点显示在屏幕上，原来的Activity仍保留在栈中，处于停止状态</p><p>当用户退出当前Activity时，当前Activity从中弹出，前一个Activity恢复执行。当所有Activity均从栈中弹出后，没有任务，栈会被回收到</p></li></ul><h6 id="启动模式"><a href="#启动模式" class="headerlink" title="启动模式"></a>启动模式</h6><p>启动模式是指Activity的新实例如何与当前任务栈关联，以什么方式进入到任务栈中</p><ul><li><p>声明方式：</p><ol><li>在AndroidManifest.xml中指定启动模式，当前Activity在任何情况下都会执行该启动模式</li><li>使用Intent标志定义，可以控制Activity何时启动时才应用启动模式</li></ol><blockquote><p>如果一个Activity两种方式都声明了，使用Intent标志的优先级要比AndroidManifest的高，且两种方式的启动模式有些不一样，Intent标志中定义的有些Maniest中没有。所以通常所说的四种启动模式指的是AndroidManifest中声明的方式</p></blockquote></li><li><p>AndroidManifest中声明启动模式(四种启动模式)</p><ul><li><p><strong>standard</strong>:标准模式</p><p>默认启动模式，直接创建新的实例压入启动它的任务栈顶</p></li><li><p><strong>singleTop</strong>:栈顶复用模式</p><p>启动<code>singleTop</code>模式的Activity时，如果发现当前任务的栈顶已存在该Activity实例，就不会创建新的实例，而是调用该实例的<code>onNewIntent</code>方法，其他与标准模式一样</p></li><li><p><strong>singleTask</strong>:栈内复用模式</p><p>当启动该模式的Activity时，系统会判断当前是否有它想要的任务栈，如果没有系统会创建一个新的任务，并将该Activity实例作为该任务的根Activity;如果有且任务栈里只有它自己，那么会直接调用该实例的<code>onNewIntent</code>方法；如果任务栈中还有其它实例，会将该Activity上方的其它Activity全部出栈</p><blockquote><p>taskAffinity:任务相关性，如果你在<code>&lt;activity&gt;</code>标签没指定这个属性，那么它就用<code>&lt;application&gt;</code>标签的<code>taskAffinity</code>属性，如果<code>&lt;application&gt;</code>标签下也没指定，它就应用包名当做默认值。</p></blockquote></li><li><p><strong>singleInstance</strong>:单例模式</p><p>为Activity单独创建一个任务并能够复用</p></li></ul></li><li><p>使用Intent声明启动模式</p><ul><li><p>方法</p><pre><code class="hljs java">intent.addFlags(<span class="hljs-keyword">int</span> flags);intent.setFlags(<span class="hljs-keyword">int</span> flags);</code></pre></li><li><p>典型参数</p><ul><li><p><strong>Intent.FLAG_ACTIVITY_SINGLE_TOP</strong></p><p>与<code>singleTop</code>启动模式一致</p></li><li><p><strong>Intent.FLAG_ACTIVITY_NEW_TASK</strong></p><p>与<code>singleTask</code>启动模式一致</p></li><li><p><strong>Intent.FLAG_ACTIVITY_CLEAR_TOP</strong></p><p>如果将启动的Activity已存在于当前任务栈中，则会弹出销毁它上方的所有Activity,并调用该Activity实例的<code>onNewIntent</code>方法，而不是启动该Activity实例</p></li></ul></li></ul></li></ul><h5 id="四-启动流程"><a href="#四-启动流程" class="headerlink" title="四. 启动流程"></a>四. 启动流程</h5><h5 id="五-数据通信"><a href="#五-数据通信" class="headerlink" title="五. 数据通信"></a>五. 数据通信</h5><p>​        Activity之间通过Intent传递数据，Intent传递数据大小是有限制的，由于Intent底层使用了<code>binder</code>机制，所以这其实是Binder传递数据的大小。其机制中使用了一个共享内存-<code>Binder transaction buffer</code>其大小限制为<code>1MB</code>，是公用的。所以不管是一次传递大数据还是同时传递多个数据，都不能超过<code>1MB</code></p><h5 id="六-scheme跳转协议"><a href="#六-scheme跳转协议" class="headerlink" title="六. scheme跳转协议"></a>六. scheme跳转协议</h5><ul><li><p>定义</p><p>scheme是一种页面跳转协议，通过其可以跳转到App的各个页面。可以通过scheme跳转到另一个app的页面，也可以通过H5页面跳转原生App页面</p></li><li><p>格式</p><pre><code class="hljs undefined">协议名称 : <span class="hljs-comment">// 作用地址域 : 路径端口 / 指定页面路径 ？ 传递参数</span></code></pre></li><li><p>使用</p><ol><li>在Manifest中定义一个Scheme,进行配置</li><li>在代码中获取Scheme跳转参数</li><li>通过Intent或Html进行调用</li></ol></li></ul><h5 id="七-Activity的管理机制"><a href="#七-Activity的管理机制" class="headerlink" title="七. Activity的管理机制"></a>七. Activity的管理机制</h5><p><img src="https://upload-images.jianshu.io/upload_images/7508328-f8e1532b18ad6317.png?imageMogr2/auto-orient/strip|imageView2/2/w/494/format/webp" srcset="/img/loading.gif" alt><br>图片来自网络</p><ul><li>AMS提供了一个mHistory来管理所有的Activity,Activity在AMS中以ActivityRecord形式存在，所有的ActivityRecord会被存储在mHistory中管理</li><li>Task在AMS中以TaskRecord形式存在，每个ActivityRecord对应一个TaskRecord,有相同TaskRecord的ActivityRecord在mHistory中处于连续的位置</li><li>进程在AMS中的管理形式为ProcessRecord,同一个TaskRecord的Activity可能处于不同的进程中,每个Activity所处的进程和Task没有关系</li><li>Activity启动时ActivityManagerService会为其生成对应的ActivityRecord记录，并将其加入到回退栈(back stack)中，另外也会将ActivityRecord记录加入到某个Task中。</li></ul><h5 id="八-进程"><a href="#八-进程" class="headerlink" title="八. 进程"></a>八. 进程</h5><p>​        共有<code>前台进程</code>，<code>可见进程</code>，<code>服务进程</code>，<code>后台进程</code>，<code>空进程</code>五种，优先级依次降低</p><ul><li><p>前台进程</p><p>用户正在交互的Activity;主动调用的前台服务</p></li><li><p>可见进程</p><p>处于<em>onPause</em>没有进入<em>onStop</em>的Activity;绑定到前台Activity的Service</p></li><li><p>服务进程</p><p>普通的startService</p></li><li><p>后台进程</p><p>处于<em>onStop</em>的Activity</p></li><li><p>空进程</p><p>没有任何活动的组件的进程，出于缓存的目的</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h4 id=&quot;Activity知识总结&quot;&gt;&lt;a href=&quot;#Activity知识总结&quot; class=&quot;headerlink&quot; title=&quot;Activity知识总结&quot;&gt;&lt;/a&gt;Activity知识总结&lt;/h4&gt;&lt;h5 id=&quot;一-定义&quot;&gt;&lt;a hre
      
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>《Kotlin实战》学习笔记-注解与反射</title>
    <link href="http://yoursite.com/2020/09/13/%E3%80%8AKotlin%E5%AE%9E%E6%88%98%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%8F%8D%E5%B0%84/"/>
    <id>http://yoursite.com/2020/09/13/《Kotlin实战》学习笔记-注解与反射/</id>
    <published>2020-09-13T01:33:49.000Z</published>
    <updated>2020-09-13T01:34:16.480Z</updated>
    
    <content type="html"><![CDATA[<h4 id="注解与反射"><a href="#注解与反射" class="headerlink" title="注解与反射"></a>注解与反射</h4><hr><h5 id="声明并应用注解"><a href="#声明并应用注解" class="headerlink" title="声明并应用注解"></a>声明并应用注解</h5><p>​    一个注解会把额外的元数据关联到一个声明上，然后元数据就可以被相关的源代码工具访问。</p><ol><li><p>应用注解</p><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTest</span></span>&#123;    <span class="hljs-meta">@Test</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">testTrue</span><span class="hljs-params">()</span></span> &#123;        ...    &#125;&#125;</code></pre><p>应用一个注解，以<code>@</code>字符作为名字的前缀，并放在要注解的声明最前面</p><p>注解支持的参数类型：基本数据类型，字符串，枚举，类引用，其他的注解类以及前面类型的数组</p><ul><li>要把一个类指定为注解实参，在类名后加<code>::class:@Annotation</code></li><li>要把另一个注解指定为一个实参，去掉注解名称前面的<code>@</code></li><li>要把一个数组指定为一个实参，使用<code>arrayOf</code>函数</li></ul><p>注解实参需要在编译期就是已知的，要引用属性作为实参，需要用<code>const</code>修饰符标记为<strong>编译期常量</strong></p></li><li><p>注解目标</p><p><code>使用点目标</code>声明被用来说明要注解的元素</p><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HasTempFolder</span></span>&#123;    <span class="hljs-meta">@get:Rule</span>    <span class="hljs-keyword">val</span> folder = TemporaryFolder()      <span class="hljs-comment">//注解的是getter,不是属性</span>&#125;</code></pre><p><code>kotlin</code>支持的<code>使用点目标</code>列表如下：</p><p>| Name     | Mean                                 |<br>| ——– | ———————————— |<br>| property | Java的注解不能应用这种使用点目标     |<br>| field    | 为属性生成的字段                     |<br>| get      | 属性的getter                         |<br>| set      | 属性的setter                         |<br>| receiver | 扩展函数或扩展属性的接收者参数       |<br>| param    | 构造方法的参数                       |<br>| setparam | 属性setter的参数                     |<br>| delegate | 为委托属性存储委托实例的字段         |<br>| file     | 包含在文件中声明的顶层函数和属性的类 |</p><p>用注解控制Java API</p><ul><li>@JvmName : 改变由Kotlin生成的Java方法或字段的名称</li><li>@JvmStatic : 用在对象声明或伴生对象的方法上，暴露成Java的静态方法</li><li>@JvmOverloads:指导Kotlin编译器为带默认参数值的函数生成多个重载</li><li>@JvmField : 应用于一个属性，暴露成一个没有访问器的公有Java字段</li></ul></li><li><p>注解使用实践</p><ol><li><p>声明注解</p><pre><code class="hljs kotlin"><span class="hljs-comment">//无参注解</span><span class="hljs-keyword">annotation</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JsonExclude</span></span><span class="hljs-comment">//带参数注解</span><span class="hljs-keyword">annotation</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JsonName</span></span>(<span class="hljs-keyword">val</span> name: String)</code></pre></li><li><p>元注解：控制如何处理一个注解</p><p>应用到注解类上的注解被称为<code>元注解</code></p><pre><code class="hljs kotlin"><span class="hljs-meta">@Target(AnnotationTarget.PROPERTY)</span><span class="hljs-keyword">annotation</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JsonExclude</span></span></code></pre><blockquote><p>Java中的注解默认会在.class文件中保留注解但不会使其在运行时访问到</p><p>Kotlin中的注解默认拥有RUNTIME保留期</p></blockquote></li><li><p>使用类做注解参数</p><p>可以通过声明一个拥有类引用作为形参的注解类来引用类作为声明的元数据。</p><pre><code class="hljs kotlin"><span class="hljs-comment">//定义</span><span class="hljs-comment">//KClass是Java的java.lang.Class在Kotlin中的对应类型，用来保存Kotlin类的引用</span><span class="hljs-keyword">annotation</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeserializeInterface</span></span>(<span class="hljs-keyword">val</span> targetClass: KClass&lt;<span class="hljs-keyword">out</span> Any&gt;)<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Company</span> </span>&#123;&#125;<span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CompanyImpl</span></span>() : Company<span class="hljs-comment">//使用,使用类名称后面添加::class关键字来引用一个类</span><span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>( <span class="hljs-meta">@DeserializeInterface(CompanyImpl::class)</span> <span class="hljs-keyword">val</span> company: Company)</code></pre></li><li><p>使用泛型类做注解参数</p><pre><code class="hljs kotlin"><span class="hljs-comment">//定义</span><span class="hljs-keyword">annotation</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomSerializer</span></span>(    <span class="hljs-keyword">val</span> serializerClass: KClass&lt;<span class="hljs-keyword">out</span> ValueSerializer&lt;*&gt;&gt;)<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ValueSerializer</span>&lt;<span class="hljs-type">T</span>&gt; </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">toJsonValue</span><span class="hljs-params">(value: <span class="hljs-type">T</span>)</span></span>: Any?&#125;<span class="hljs-keyword">object</span> DateSerializer : ValueSerializer&lt;Date&gt; &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> dateFormat = SimpleDateFormat(<span class="hljs-string">"dd-mm-yyyy"</span>)    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">toJsonValue</span><span class="hljs-params">(value: <span class="hljs-type">Date</span>)</span></span>: Any? =            dateFormat.format(value)&#125;<span class="hljs-comment">//使用</span><span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>(<span class="hljs-meta">@CustomSerializer(DateSerializer::class)</span> <span class="hljs-keyword">val</span> birthDate: Date)</code></pre></li></ol></li></ol><h5 id="反射：在运行时对Kotlin对象进行自省"><a href="#反射：在运行时对Kotlin对象进行自省" class="headerlink" title="反射：在运行时对Kotlin对象进行自省"></a>反射：在运行时对Kotlin对象进行自省</h5><ol><li><p>Kotlin反射API</p><p><code>KClass</code>代表一个类，对应java.lang.class,可以用它列举和访问类中包含的所有声明。</p><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">KClass</span>&lt;<span class="hljs-type">T: Any</span>&gt; </span>&#123;    <span class="hljs-keyword">val</span> members: Collection&lt;KCallable&lt;*&gt;&gt;    <span class="hljs-keyword">val</span> constructors: Collection&lt;KFunction&lt;T&gt;&gt;    <span class="hljs-keyword">val</span> nestedClasses: Collection&lt;KClass&lt;*&gt;&gt;&#125;</code></pre><p><code>KCallable</code>是函数和属性的超接口，它声明了<strong>Call</strong>方法，允许调用对应的函数或者对应属性的getter</p><p><code>KFunction1</code>是合成的编译器生成类型，其表示为<code>KFunction1&lt;Int, Unit&gt;</code>,1表示该函数接收1个形参，Int为形参类型，Unit为返回类型</p><p><code>KProPerty</code>是一个泛型类，其表示为<code>KProperty&lt;XXX, Int&gt;</code>第一个类型参数表示接收者类型，第二个表示属性类型</p><blockquote><p>只能使用反射访问定义在最外层或者类中的属性，不能访问函数的局部变量</p></blockquote><pre class="mermaid">      classDiagramKAnnotatedElement <|-- kclass kannotatedelement <|-- kcallable kparameter kfunction kproperty kfunction0 kfunction1 kmutableproperty getter setter< pre></|--></pre></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;注解与反射&quot;&gt;&lt;a href=&quot;#注解与反射&quot; class=&quot;headerlink&quot; title=&quot;注解与反射&quot;&gt;&lt;/a&gt;注解与反射&lt;/h4&gt;&lt;hr&gt;
&lt;h5 id=&quot;声明并应用注解&quot;&gt;&lt;a href=&quot;#声明并应用注解&quot; class=&quot;headerlink&quot; t
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>《Kotlin实战》学习笔记-泛型</title>
    <link href="http://yoursite.com/2020/09/06/%E3%80%8AKotlin%E5%AE%9E%E6%88%98%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%B3%9B%E5%9E%8B/"/>
    <id>http://yoursite.com/2020/09/06/《Kotlin实战》学习笔记-泛型/</id>
    <published>2020-09-06T13:33:17.000Z</published>
    <updated>2020-09-06T13:39:24.197Z</updated>
    
    <content type="html"><![CDATA[<h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><hr><h5 id="泛型类型参数"><a href="#泛型类型参数" class="headerlink" title="泛型类型参数"></a>泛型类型参数</h5><p>​        泛型允许定义带<em>类型形参</em>的类型。当这种类型的实例被创建时，类型形参被替换成称为<em>类型实参</em>的具体类型。Kotlin中要求类型实参要么被显式地说明，要么能被编译器推导出来。</p><ol><li><p>泛型函数和属性</p><p>泛型函数有自己的类型形参，这些类型形参在每次函数调用时都必须替换成具体的类型实参。</p><pre class="mermaid">   graph LRA["fun < T >  List< T >.slice(indices: IntRange): List< T >"]</pre><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> letters = (<span class="hljs-string">'a'</span>..<span class="hljs-string">'z'</span>).toList()<span class="hljs-comment">//显式地指定类型实参</span>println(letters.slice&lt;<span class="hljs-built_in">Char</span>&gt;(<span class="hljs-number">0</span>..<span class="hljs-number">2</span>))<span class="hljs-comment">//编译器推导出T的类型</span>println(letters.slice(<span class="hljs-number">10</span>..<span class="hljs-number">13</span>))</code></pre><p>可以给类或接口的方法，顶层函数，以及扩展函数声明类型参数。</p><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> &lt;T&gt; List&lt;T&gt;.penutimate: T<span class="hljs-keyword">get</span>() = <span class="hljs-keyword">this</span>[size - <span class="hljs-number">2</span>]</code></pre></li><li><p>声明泛型类</p><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-type">T</span>&gt; </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(other: <span class="hljs-type">T</span>)</span></span>: <span class="hljs-built_in">Int</span>&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">String</span>: <span class="hljs-type">Comparable</span>&lt;<span class="hljs-type">String</span>&gt; </span>&#123;    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(other: <span class="hljs-type">String</span>)</span></span>: <span class="hljs-built_in">Int</span> = <span class="hljs-comment">/*****/</span>&#125;</code></pre></li><li><p>类型参数约束</p><p>类型参数约束可以限制作为(泛型)类和(泛型)函数的类型实参的类型。</p><ul><li><p>通过在类型参数后指定上界来定义约束</p><pre><code class="hljs kotlin"><span class="hljs-comment">//Java中的上界约束</span>&lt;T extends Number&gt; T sum(List&lt;T&gt; list)<span class="hljs-comment">//Kotlin中的上界约束</span><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T ：Number&gt;</span> List<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">sum</span><span class="hljs-params">()</span></span>: T<span class="hljs-comment">//Kotlin中指定多个约束</span><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">(seq: <span class="hljs-type">T</span>)</span></span> <span class="hljs-keyword">where</span> T: CharSequence, T: Appendable&#123;&#125;</code></pre></li><li><p>让类型形参非空</p><p>没有指定上界的类型形参默认使用<code>Any?</code>来作为上界，如果想保证替换类型形参的始终是非空类型，可以使用<code>Any</code>作为默认上界</p><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Processor</span>&lt;<span class="hljs-type">T: Any</span>&gt; </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">process</span><span class="hljs-params">(value: <span class="hljs-type">T</span>)</span></span>&#123;        value.hashCode()    &#125;&#125;</code></pre></li></ul></li></ol><h5 id="运行时的泛型：擦除和实化类型参数"><a href="#运行时的泛型：擦除和实化类型参数" class="headerlink" title="运行时的泛型：擦除和实化类型参数"></a>运行时的泛型：擦除和实化类型参数</h5><ol><li><p>类型检查和转换</p><p>JVM上的泛型一般是通过类型擦除实现的，泛型类实例的类型实参在运行时是不保留的。与Java一样，Kotlin的泛型在运行时也被擦除了，泛型类实例不会携带用于创建它的类型实参的信息。擦除泛型类型信息可以使应用程序使用的内存总量较少。</p><pre><code class="hljs kotlin"><span class="hljs-comment">//list1和list2在运行时都只是List，不会知道其中包含的是字符串还是整数</span><span class="hljs-keyword">val</span> list1: List&lt;String&gt; = listOf(<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>)<span class="hljs-keyword">val</span> list2: List&lt;<span class="hljs-built_in">Int</span>&gt; = listOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)</code></pre></li><li><p>声明带实化参数的函数</p><p>内联函数的类型形参能够被实化，可以在运行时引用实际的类型实参。使用<code>inline</code>标记一个函数，编译器会把每一次函数调用都换成函数实际的代码实现。</p><pre><code class="hljs kotlin"><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;<span class="hljs-keyword">reified</span> T&gt;</span> <span class="hljs-title">isA</span><span class="hljs-params">(value: <span class="hljs-type">Any</span>)</span></span> = value <span class="hljs-keyword">is</span> Tprintln(isA&lt;String&gt;(<span class="hljs-string">"abc"</span>))  <span class="hljs-comment">//true</span>println(isA&lt;String&gt;(<span class="hljs-number">123</span>))  <span class="hljs-comment">//false</span></code></pre><blockquote><p>带<code>refied</code>类型参数的inline函数不能在Java代码中调用。</p></blockquote></li><li><p>使用实化类型参数代替类引用</p><pre><code class="hljs kotlin"><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;<span class="hljs-keyword">reified</span> T: Activity&gt;</span> Context.<span class="hljs-title">startActivity</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">val</span> intent = Intent(<span class="hljs-keyword">this</span>, T::<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span>)</span>    startActivity(intent)&#125;<span class="hljs-comment">//调用</span>startActivity&lt;MainActivity&gt;()</code></pre></li><li><p>实化类型参数的限制</p><p>可以按下面方式使用实化类型参数</p><ul><li>用在类型检查和类型转换中(<code>is</code>, <code>!is</code>, <code>as</code>, <code>as?</code>)</li><li>使用Kotlin反射API</li><li>获取相应的java.lang.class</li><li>作为调用其他函数的类型实参</li></ul><p>不能做以下事情</p><ul><li>创建指定类型参数的类的实例</li><li>调用类型参数类的伴生对象的方法</li><li>调用带实化类型参数函数的时候使用非实化类型形参作为类型实参</li><li>把类，属性或者非内联函数的类型参数标记为<code>reified</code></li></ul></li></ol><h5 id="变型：泛型和子类型化"><a href="#变型：泛型和子类型化" class="headerlink" title="变型：泛型和子类型化"></a>变型：泛型和子类型化</h5><ol><li><p>类，类型和子类型</p><ul><li><p>对于非泛型类，类的名称可以直接当作类型使用；对于泛型类，要得到一个合法的类型，需要作为类型实参的具体类型替换类的类型形参。每一个泛型类都可能生成潜在无数数量的类型。例如<code>List</code>是一个类，<code>List&lt;String&gt;</code>,<code>List&lt;Int&gt;</code>等都是类型。</p></li><li><p>子类型：如果期望A的时候可以使用B,则B就是A的子类型</p></li><li><p>超类型：如果A是B的子类型，则B就是A的超类型</p></li></ul></li><li><p>协变：保留子类型化关系</p><p>如果<code>A</code>是<code>B</code>的子类型，那么<code>Product&lt;A&gt;</code>是<code>Product&lt;B&gt;</code>的子类型，则子类型化被保留了。在Kotlin中要声明类在某个类型参数上是可以协变的，需在该类型参数的名称前加<code>out</code>关键字</p><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Product</span>&lt;<span class="hljs-type">out T</span>&gt; </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">product</span><span class="hljs-params">()</span></span>: T&#125;</code></pre><p>将一个类的类型参数标记为协变的，在该类型实参没有精确匹配到函数中定义的类型形参时，可以让该类的值作为函数的实参传递，也可作为函数返回值。</p><p>在类成员的声明中类型参数的使用可以分为<code>in</code>位置和<code>out</code>位置</p><ul><li>in位置：函数参数的类型</li><li>out位置：函数的返回类型</li></ul><blockquote><p>构造方法的参数,私有方法的参数既不在in位置也不在out位置</p></blockquote><p>类型参数T上的关键字<code>out</code>有两层含义：</p><ol><li>子类型化会被保留</li><li>T只能用在out位置</li></ol></li><li><p>逆变：反转子类型化关系</p><p>如果<code>B</code>是<code>A</code>的子类型，那么<code>Comsumer&lt;A&gt;</code>就是<code>Comsumer&lt;B&gt;</code>的子类型,子类型化被反转了。逆变可以看作是协变的镜像：对一个逆变类来说，它的子类型化关系与用作类型实参的类的子类型化关系是相反的。</p><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-type">in T</span>&gt; </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">compare</span><span class="hljs-params">(e1: <span class="hljs-type">T</span>, e2: <span class="hljs-type">T</span>)</span></span>: <span class="hljs-built_in">Int</span>&#125;</code></pre><p>in关键字的意思是，对应类型的值是传递进来给这个类的方法的，并被这些方法消费。</p><p>| 协变               | 逆变           | 不变型          |<br>| :—————– | :————- | :————– |<br>| Product<out t>     | Consumer<in t> | MutableList<t>  |<br>| 类的子类型化保留了 | 子类型化反转了 | 没有子类型化    |<br>| T只能在out位置     | T只能在in位置  | T可以在任意位置 |</t></in></out></p><p>一个类可以在一个类型参数上协变，同时在另外一个类型参数上逆变</p><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Function1</span>&lt;<span class="hljs-type">in P, out R</span>&gt;</span>&#123;    <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">invoke</span><span class="hljs-params">(p: <span class="hljs-type">P</span>)</span></span>: R&#125;</code></pre></li><li><p>点变型：在类型出现的地方指定变型</p><p>声明点变型：在类声明的时候指定变型修饰符</p><p>使用点变型：每次使用带类型参数的类型时，指定这个类型参数是否可以用它的子类型或超类型。</p><blockquote><p>Kotlin的使用点变型对应Java的限界通配符</p><p>| Kotlin    | Java            |<br>| ——— | ————— |<br>| <code>&lt;out T&gt;</code> | <code>&lt;? extends T&gt;</code> |<br>| <code>&lt;in T&gt;</code>  | <code>&lt;? super T&gt;</code>   |</p></blockquote></li><li><p>星号投影：使用<code>*</code>代替类型参数</p><p>当类型参数的信息并不重要的时候，可以使用星号投影的语法：不需要使用任何在签名中引用类型参数的方法，或者只是读取数据而不关心它的具体类型</p><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printFirst</span><span class="hljs-params">(list: <span class="hljs-type">List</span>&lt;*&gt;)</span></span> &#123;    <span class="hljs-keyword">if</span> (list.isNotEmpty()) &#123;        println(list.first() )    &#125;&#125;</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;泛型&quot;&gt;&lt;a href=&quot;#泛型&quot; class=&quot;headerlink&quot; title=&quot;泛型&quot;&gt;&lt;/a&gt;泛型&lt;/h4&gt;&lt;hr&gt;
&lt;h5 id=&quot;泛型类型参数&quot;&gt;&lt;a href=&quot;#泛型类型参数&quot; class=&quot;headerlink&quot; title=&quot;泛型类型参数&quot;&gt;
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>《Kotlin实战》学习笔记-高阶函数Lambda</title>
    <link href="http://yoursite.com/2020/09/02/%E3%80%8AKotlin%E5%AE%9E%E6%88%98%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0Lambda/"/>
    <id>http://yoursite.com/2020/09/02/《Kotlin实战》学习笔记-高阶函数Lambda/</id>
    <published>2020-09-02T13:39:50.000Z</published>
    <updated>2020-09-02T13:41:40.745Z</updated>
    
    <content type="html"><![CDATA[<h4 id="高阶函数-Lambda作为形参和返回值"><a href="#高阶函数-Lambda作为形参和返回值" class="headerlink" title="高阶函数:Lambda作为形参和返回值"></a>高阶函数:Lambda作为形参和返回值</h4><hr><h6 id="声明高阶函数"><a href="#声明高阶函数" class="headerlink" title="声明高阶函数"></a>声明高阶函数</h6><blockquote><p>高阶函数即以另一个函数作为参数或返回值的函数.在Kotlin中,函数可以用lambda或者函数引用来表示.则任何以lambda或者函数引用作为参数或返回值的函数都是高阶函数.</p></blockquote><ul><li><p>函数类型</p><p>Kotlin中的函数类型语法:箭头左侧为参数类型,右侧为返回类型</p><pre class="mermaid">  graph LRA["(Int,String)"] --> B["Unit"]</pre><pre><code class="hljs kotlin"><span class="hljs-comment">//声明返回值可空的函数类型</span><span class="hljs-keyword">var</span> canReturnNull: (<span class="hljs-built_in">Int</span>,<span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Int</span>? = &#123; <span class="hljs-literal">null</span> &#125;<span class="hljs-comment">//声明可空的函数类型的变量</span><span class="hljs-keyword">var</span> funOrNull : ((<span class="hljs-built_in">Int</span>,<span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Int</span>)? = <span class="hljs-literal">null</span></code></pre></li><li><p>调用作为参数的函数</p><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">twoAndThree</span><span class="hljs-params">(operation : (<span class="hljs-type">Int</span>,<span class="hljs-built_in">Int</span>)</span></span> -&gt; <span class="hljs-built_in">Int</span>)&#123;    println(operation(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>))&#125;</code></pre></li><li><p>返回函数的函数</p><blockquote><p>声明一个返回另一个函数的函数,需要指定一个函数类型作为返回类型</p></blockquote><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getShippingCostCalutor</span><span class="hljs-params">(delivery:<span class="hljs-type">Delivery</span>)</span></span> : (Order) -&gt; <span class="hljs-built_in">Double</span>&#123;    .....    <span class="hljs-keyword">return</span> &#123;order -&gt; <span class="hljs-number">1.2</span>*itemcount&#125;&#125;</code></pre></li></ul><h6 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h6><ul><li>lambda表达式会被正常编译为匿名类，每调用一次lambda就会额外创建一个类，带来运行时的额外开销</li><li>使用<code>inline</code>修饰符标记一个函数,在函数被使用时编译器不会生成函数调用的代码,而是使用函数实现的真实代码替换每一次的函数调用</li><li>当一个函数被声明为<code>inline</code>时,函数体会被直接替换到函数被调用的地方,而不是正常调用</li><li>给内联函数传递一个函数类型的变量为参数而不是lambda时不会被内联.</li><li>如果在两个不同的位置使用同一个内联函数,但是用的是不同的lambda,那么内联函数会在每一个被调用的位置被分别内联.</li></ul><h6 id="高阶函数中控制流"><a href="#高阶函数中控制流" class="headerlink" title="高阶函数中控制流"></a>高阶函数中控制流</h6><ul><li><p>lambda中的返回语句-从封闭函数返回</p><ol><li>在lambda中使用<strong>return</strong>关键字,会从调用lambda的函数中返回,并不只是从lambda中返回</li><li>只有在以lambda作为参数的函数是内联函数的时候才能从更外层的函数返回</li></ol></li><li><p>从lambda返回-使用标签返回</p><p>从一个lambda表达式处返回需要在<strong>return</strong>关键字后面引用<strong>标签</strong></p><pre><code class="hljs kotlin">people.forEach <span class="hljs-symbol">label@</span>&#123;    <span class="hljs-keyword">if</span>(it.name == <span class="hljs-string">"Alice"</span>)    <span class="hljs-keyword">return</span><span class="hljs-symbol">@label</span>   <span class="hljs-comment">//返回表达式标签</span>&#125;</code></pre><p>可以自定义标签名或者使用函数名作为标签，但显式地指定了lambda表达式之后，再使用函数名作为标签会没有任何效果。一个lambda表达式的标签数量不能多于一个。</p></li><li><p>匿名函数-默认使用局部返回</p><pre><code class="hljs kotlin">people.forEach(<span class="hljs-function"><span class="hljs-title">fun</span> <span class="hljs-params">(person)</span></span>&#123;    <span class="hljs-keyword">if</span>(person.name == <span class="hljs-string">"Alice"</span>) <span class="hljs-keyword">return</span>     println(<span class="hljs-string">"<span class="hljs-subst">$&#123;person.name&#125;</span> is not Alice"</span>)&#125;)</code></pre><ul><li>在匿名函数中,不带标签的<strong>return</strong>表达式会从匿名函数返回,而不是从包含匿名函数的函数返回:<strong>return从最近的使用fun关键字声明的函数返回</strong></li><li>尽管匿名函数看起来和普通函数很相似，但它其实是lambda表达式的另一种语法形式</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;高阶函数-Lambda作为形参和返回值&quot;&gt;&lt;a href=&quot;#高阶函数-Lambda作为形参和返回值&quot; class=&quot;headerlink&quot; title=&quot;高阶函数:Lambda作为形参和返回值&quot;&gt;&lt;/a&gt;高阶函数:Lambda作为形参和返回值&lt;/h4&gt;&lt;hr&gt;

      
    
    </summary>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>《Kotlin实战》学习笔记-运算符重载及其他约定</title>
    <link href="http://yoursite.com/2020/09/01/%E3%80%8AKotlin%E5%AE%9E%E6%88%98%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E5%8F%8A%E5%85%B6%E4%BB%96%E7%BA%A6%E5%AE%9A/"/>
    <id>http://yoursite.com/2020/09/01/《Kotlin实战》学习笔记-运算符重载及其他约定/</id>
    <published>2020-09-01T13:37:33.000Z</published>
    <updated>2020-09-02T13:11:02.332Z</updated>
    
    <content type="html"><![CDATA[<h4 id="运算符重载及其他约定"><a href="#运算符重载及其他约定" class="headerlink" title="运算符重载及其他约定"></a>运算符重载及其他约定</h4><hr><h6 id="重载算术运算符"><a href="#重载算术运算符" class="headerlink" title="重载算术运算符"></a>重载算术运算符</h6><ul><li><p>重载二元算术运算</p><pre><code class="hljs kotlin"><span class="hljs-comment">//定义一个plus运算符</span><span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span></span>(<span class="hljs-keyword">val</span> x:<span class="hljs-built_in">Int</span>,<span class="hljs-keyword">val</span> y:<span class="hljs-built_in">Int</span>)&#123;    <span class="hljs-comment">//使用operator关键字来进行声明</span>    <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">plus</span><span class="hljs-params">(other:<span class="hljs-type">Point</span>)</span></span>:Point&#123;        <span class="hljs-keyword">return</span> Point(x+other.x,y+other.y)    &#125;&#125;<span class="hljs-comment">//val p1 = Point(10,20)</span><span class="hljs-comment">//val p2 = Point(30,40)</span><span class="hljs-comment">//println(p1+p2) 使用+号来调用"plus"方法</span><span class="hljs-comment">//把运算符定义为一个扩展函数</span><span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> Point.<span class="hljs-title">plus</span><span class="hljs-params">(other:<span class="hljs-type">Point</span>)</span></span>:Point&#123;    <span class="hljs-keyword">return</span> Point(x+other.x,y+other.y)&#125;</code></pre><p>可重载的二元算术运算符</p><p>| 表达式 | 函数名 |<br>| —— | —— |<br>| a * b  | times  |<br>| a / b  | div    |<br>| a % b  | mod    |<br>| a + b  | plus   |<br>| a - b  | minus  |</p><p>Kotlin运算符不会自动支持交换性(交换运算符的左右两边)</p><p>Kotlin中用于执行位运算的完整函数列表:</p><p>| 函数名 | 含义       |<br>| —— | ———- |<br>| shl    | 带符号左移 |<br>| shr    | 带符号右移 |<br>| ushr   | 无符号右移 |<br>| and    | 按位与     |<br>| or     | 按位或     |<br>| xor    | 按位异或   |<br>| inv    | 按位取反   |</p></li><li><p>重载复合赋值运算符</p><p><code>+=, -=</code>等这些运算符被称为复合赋值运算符</p></li><li><p>重载一元运算符</p><pre><code class="hljs kotlin"><span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> Point.<span class="hljs-title">unaryMinus</span><span class="hljs-params">()</span></span>:Point&#123;    <span class="hljs-keyword">return</span> Point(-x,-y)&#125;<span class="hljs-keyword">val</span> p = Point(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>)println(-p)</code></pre><p>可重载的一元运算符</p><p>| 表达式  | 函数名     |<br>| ——- | ———- |<br>| +a      | unaryPlus  |<br>| -a      | unaryMinus |<br>| !a      | not        |<br>| ++a,a++ | inc        |<br>| –a,a– | dec        |</p></li><li><p>重载比较运算符</p><ul><li><p>等号运算符:“equals”</p><pre class="mermaid">  graph LRA[a == b] --> B["a?.equals(b) ?: (b == null)"]</pre><blockquote><p>Kotlin中的<code>===</code>恒等运算符与Java中的<code>==</code>运算符一致:检查两个参数是否为同一对象的引用(如果是基本类型则检查值是否相等).<strong>===运算符不能被重载</strong></p></blockquote></li><li><p>排序运算符:compareTo</p><pre class="mermaid">    graph LRA[a >= b] --> B["a.compareTo(b) >= 0"]</pre></li></ul></li></ul><h6 id="集合与区间的约定"><a href="#集合与区间的约定" class="headerlink" title="集合与区间的约定"></a>集合与区间的约定</h6><ul><li><p>通过下标来访问元素:“get”和“set”</p><pre class="mermaid">  graph LRA["x[a,b]"]  -->  B["x.get(a,b)"]</pre><p>方括号的访问会被转换为<code>get</code>函数的调用</p><pre class="mermaid">  graph LRA["x[a,b] = c"] --> B["x.set(a,b,c)"]</pre><p>方括号的赋值操作会被转换为<code>set</code>函数的调用</p></li><li><p>“in”的约定</p><p>用于检查某个对象是否属于集合,对应函数为<code>contains</code></p><pre class="mermaid">  graph LRA["a in c"] --> B["c.contains(a)"]</pre></li><li><p>rangeTo的约定</p><pre class="mermaid">  graph LRA["start..end"] --> B["start.rangeTo(end)"]</pre></li></ul><h6 id="解构声明和组件函数"><a href="#解构声明和组件函数" class="headerlink" title="解构声明和组件函数"></a>解构声明和组件函数</h6><p>   一个解构声明看起来像一个普通的变量声明,但它在括号中有多个变量.可以使用其返回多个值.</p>   <pre class="mermaid">graph LRA["val (a,b) = p"] -->  B["val a = p.component1()"]A --> C["val b = p.component2()"]</pre><p>使用解构声明来遍历map</p><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printEntries</span><span class="hljs-params">(map:<span class="hljs-type">Map</span>&lt;<span class="hljs-type">String</span>,String)</span></span>&#123;    <span class="hljs-keyword">for</span>((key,value) <span class="hljs-keyword">in</span> map)&#123;        println(<span class="hljs-string">"<span class="hljs-variable">$key</span> -&gt; <span class="hljs-variable">$value</span>"</span>)  &#125;&#125;</code></pre><h6 id="委托属性"><a href="#委托属性" class="headerlink" title="委托属性"></a>委托属性</h6><ul><li><p>委托属性基本用法</p><pre><code class="hljs kotlin"><span class="hljs-comment">//属性p将它的访问器逻辑委托给了Delegate对象</span><span class="hljs-comment">//通过关键词by对其后的表达式求值来获取这个对象</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span></span>&#123;    <span class="hljs-keyword">var</span> p: Type <span class="hljs-keyword">by</span> Delegate()&#125;</code></pre></li><li><p>惰性初始化和“by lazy()”</p><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>(<span class="hljs-keyword">val</span> name : String)&#123;<span class="hljs-keyword">val</span> emails <span class="hljs-keyword">by</span> lazy &#123; loadEmails(<span class="hljs-keyword">this</span>) &#125;&#125;</code></pre><blockquote><p>lazy函数返回一个对象,该对象具有一个名为<code>getValue</code>的方法.</p></blockquote></li><li><p>实现委托属性</p><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ObservableProperty</span></span>(<span class="hljs-keyword">var</span> propValue: <span class="hljs-built_in">Int</span>, <span class="hljs-keyword">val</span> changeSupport: PropertyChangeSupport) &#123;    <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getValue</span><span class="hljs-params">(p: <span class="hljs-type">Person</span>, prop: <span class="hljs-type">KProperty</span>&lt;*&gt;)</span></span>: <span class="hljs-built_in">Int</span> = propValue    <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setValue</span><span class="hljs-params">(p: <span class="hljs-type">Person</span>, prop: <span class="hljs-type">KProperty</span>&lt;*&gt;, newValue: <span class="hljs-type">Int</span>)</span></span> &#123;        <span class="hljs-keyword">val</span> oldValue = propValue        propValue = newValue        changeSupport.firePropertyChange(prop.name, oldValue, newValue)    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>(<span class="hljs-keyword">val</span> name: String, age: <span class="hljs-built_in">Int</span>, salary: <span class="hljs-built_in">Int</span>) : PropertyChanggeAware&#123;    <span class="hljs-keyword">var</span> age: <span class="hljs-built_in">Int</span> <span class="hljs-keyword">by</span> ObservableProperty(age, changeSupport)    <span class="hljs-keyword">var</span> salary: <span class="hljs-built_in">Int</span> <span class="hljs-keyword">by</span> ObservableProperty(salary, changeSupport)&#125;</code></pre></li><li><p>委托属性的变换规则</p><p>当访问属性时，会调用<delegate>的getValue和setValue函数</delegate></p><pre class="mermaid">  graph LRa["val x = c.prop"] --> b["val x= < delegate>.getValue(c, < property>)"]c["c.prop = x"] --> d["< delegate>.setValue(c,< property>, x)"]</pre></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;运算符重载及其他约定&quot;&gt;&lt;a href=&quot;#运算符重载及其他约定&quot; class=&quot;headerlink&quot; title=&quot;运算符重载及其他约定&quot;&gt;&lt;/a&gt;运算符重载及其他约定&lt;/h4&gt;&lt;hr&gt;
&lt;h6 id=&quot;重载算术运算符&quot;&gt;&lt;a href=&quot;#重载算术运算符&quot; 
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>《Kotlin实战》学习笔记-Kotlin的类型系统</title>
    <link href="http://yoursite.com/2020/08/31/%E3%80%8AKotlin%E5%AE%9E%E6%88%98%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Kotlin%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2020/08/31/《Kotlin实战》学习笔记-Kotlin的类型系统/</id>
    <published>2020-08-31T13:20:22.000Z</published>
    <updated>2020-08-31T13:24:22.314Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Kotlin的类型系统"><a href="#Kotlin的类型系统" class="headerlink" title="Kotlin的类型系统"></a>Kotlin的类型系统</h4><hr><ol><li><h5 id="可空性"><a href="#可空性" class="headerlink" title="可空性"></a>可空性</h5><ul><li><p>可空类型</p><p><code>Kotlin</code>对<em>可空类型</em>显示的支持.问号<code>?</code>可以加在任何类型后面表示这个类型的变量是可空的。</p></li><li><p>类型的含义</p><p>类型:类型就是数据的分类,决定了该类型可能的值,以及在该类型的值上可以完成的操作.</p></li><li><p>安全调用运算符<code>?.</code></p><pre class="mermaid">     graph LRA[foo?.bar] --> B[foo.bar]A --> C[null]</pre><p>如图所示,使用安全调用运算符时,如果<code>foo</code>对象不为<code>null</code>则会调用;否则不会调用<code>bar</code>方法</p><pre><code class="hljs kotlin"><span class="hljs-comment">//使用安全调用处理可空属性</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span></span>(<span class="hljs-keyword">val</span> name:String,<span class="hljs-keyword">val</span> manager:Employee?)<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">managerName</span><span class="hljs-params">(employee:<span class="hljs-type">Employee</span>)</span></span>:String? = employee,manager?.name</code></pre></li><li><p>Elvis运算符(null合并运算符)<code>?:</code></p><pre class="mermaid">     graph LRA[foo?:bar] --> B[foo]A --> C[bar]</pre><p>如上图所示,当<code>foo</code>不为<code>null</code>时,结果为<code>foo</code>对象;否则为<code>bar</code>对象.</p><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">strLenSafe</span><span class="hljs-params">(s:<span class="hljs-type">String</span>?)</span></span>:<span class="hljs-built_in">Int</span> = s?.length?:<span class="hljs-number">0</span></code></pre></li><li><p>安全转换<code>as?</code></p><p>该运算符会尝试将值转换为指定的类型,如果值不是合适的类型就返回<code>null</code></p><pre class="mermaid">     graph LRA[foo as? Type] --> B[foo as Type]A --> C[null]</pre></li><li><p>非空断言<code>!!</code></p><pre class="mermaid">     graph LRA[foo!!] --> B[foo]A --> C[NullPointerException]</pre><p><code>!!</code>可以将任何值转换为非空类型,但如果对<code>null</code>做非空断言,则会抛出<code>NPE</code></p></li><li><p><code>let</code>函数</p><p><code>let</code>函数会把一个调用它的对象变成<code>lambda</code>表达式的参数</p><pre><code class="hljs kotlin"><span class="hljs-comment">//let函数只会在email的值非空时调用</span>email?.let&#123;    email -&gt; sendEmailTo(email)&#125;</code></pre></li><li><p>延迟初始化属性</p><p>使用<code>lateinit</code>修饰符来声明延迟初始化属性,因为需要在构造方法之外修改值,所以延迟初始化的属性都是<code>var</code>.</p><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> myService: MyService</code></pre></li></ul></li></ol><ul><li><p>可空类性的扩展</p><p>为可空类型定义扩展函数来接收和处理可能为<code>null</code>的情况.</p><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> String?.<span class="hljs-title">isNullOrBlank</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> = <span class="hljs-keyword">this</span> == <span class="hljs-literal">null</span> || <span class="hljs-keyword">this</span>.isBlank()</code></pre></li></ul><pre><code>&gt; 扩展函数中的`this`可能为`null`,所以必须显式地检查. </code></pre><ul><li><p>类型参数的可空性</p><ol><li><p>Kotlin中所有<strong>泛型类和泛型函数的类型参数</strong>默认都是可空的.</p><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">printHashCode</span><span class="hljs-params">(t:<span class="hljs-type">T</span>)</span></span>&#123;    println(t?.hashCode()) <span class="hljs-comment">//因为`t`可能为null,所以必须使用安全调用</span>&#125;<span class="hljs-comment">//为类型参数声明非空上界来拒绝可空值作为实参</span><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T:Any&gt;</span> <span class="hljs-title">printHashCode</span><span class="hljs-params">(t: <span class="hljs-type">T</span>)</span></span>&#123;    println(t.hashCode())&#125;</code></pre></li></ol></li></ul><ul><li><p>可空性和Java</p><blockquote><ul><li>Java中的@Nullable注解表达的参数被Kotlin当作可空类型,即Any?;而@NotNull注解表达的参数被Kotlin当作Any</li></ul></blockquote></li></ul><ol start="2"><li><p><strong>基本数据类型和其他基本类型</strong></p><ul><li><p>基本数据类型:Int,Boolean及其他</p><p>Java中分为<strong>基本数据类型</strong>和<strong>引用类型</strong>.基本数据类型的变量直接存储了值,可以高效的存储和传递,但是不能调用方法;引用类型的变量存储了指向包含该对象的内存地址的引用.因此Java中增加了包装类型</p></li><li><p>数字转换</p><p>Kotlin不会自动把数字从一种类型转换为另一种,必须显式的进行转换.</p><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> x = <span class="hljs-number">1</span>println(x.toLong() <span class="hljs-keyword">in</span> listOf(<span class="hljs-number">1L</span>,<span class="hljs-number">2L</span>,<span class="hljs-number">3L</span>))</code></pre></li><li><p>‘Any’和‘Any?’:根类型</p><p><code>Any</code>类型是Kotlin所有<strong>非空类型</strong>的超类型;<code>Any?</code>是可空类型的超类型</p></li><li><p>Unit类型:Kotlin中的‘Void’</p><ul><li><p>Unit可以作为类型参数,void不可以</p> <pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Processor</span>&lt;<span class="hljs-type">T</span>&gt;</span>&#123;    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">process</span><span class="hljs-params">()</span></span>:T&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NoResultProcessor</span> : <span class="hljs-type">Processor</span>&lt;<span class="hljs-type">Unit</span>&gt;</span>&#123;    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">process</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">//不需要显式的return</span>    &#125;&#125;</code></pre></li></ul></li><li><p>Nothing类型</p><p>Nothing类型没有任何值,只有被当作函数返回值使用,或被当作泛型函数返回值的类型使用才有意义.</p></li></ul></li><li><p>集合与数组</p><ul><li><p>可空性和集合</p><p>与变量一样,可以使用<code>?</code>标记是否可以为null</p><p><img src="https://gitee.com/domeofheaven2017/Image/raw/master/BlogImage/可空性与集合.png" srcset="/img/loading.gif" alt="可空性与集合"></p><blockquote><p>声明一个包含可空类型的可空列表:List&lt;Int?&gt;?</p></blockquote></li><li><p>只读集合与可变集合</p><ul><li><p>只读集合(Collection):只能对集合中的数据进行读取操作</p></li><li><p>可变集合(MutableCollection):可以修改集合中的数据</p></li><li><p>只读集合不一定是不可变的,不总是线程安全的.</p><p>| 集合类型 | 只读   | 可变                                           |<br>| ——– | —— | ———————————————- |<br>| List     | listOf | mutableListOf,arrayListOf                      |<br>| Set      | setOf  | mutableSetOf,hashSetOf,linkedSetOf,sortedSetOf |<br>| Map      | mapOf  | mutableMapOf,hashMapOf,linkedMapOf,sortedMapOf |</p></li></ul></li><li><p>对象和基本数据类型的数组</p><p>Kotlin中的一个数组是一个带有参数类型的类,其元素类型被指定为相应的类型参数;</p><p>数组类型的类型参数始终会变成对象类型.</p><p>创建数组: </p><ul><li><p>arrayOf:创建的数组包含的元素是指定为该函数的实参</p></li><li><p>arrayOfNulls:创建包含null元素的数组</p></li><li><p>Array构造方法:接收数组的大小和lambda表达式来创建数组</p><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> letters = Array&lt;String&gt;(<span class="hljs-number">26</span>)&#123; i -&gt; (<span class="hljs-string">'a'</span> + i).toString()&#125;</code></pre></li></ul></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Kotlin的类型系统&quot;&gt;&lt;a href=&quot;#Kotlin的类型系统&quot; class=&quot;headerlink&quot; title=&quot;Kotlin的类型系统&quot;&gt;&lt;/a&gt;Kotlin的类型系统&lt;/h4&gt;&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;&lt;h5 id=&quot;可空性&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>《Kotlin实战》学习笔记-Lambda编程</title>
    <link href="http://yoursite.com/2020/08/30/%E3%80%8AKotlin%E5%AE%9E%E6%88%98%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Lambda%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/08/30/《Kotlin实战》学习笔记-Lambda编程/</id>
    <published>2020-08-30T14:33:10.000Z</published>
    <updated>2020-08-30T14:37:32.762Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Lambda-编程"><a href="#Lambda-编程" class="headerlink" title="Lambda 编程"></a>Lambda 编程</h4><hr><ol><li><p>Lambda 简介</p><p>Lambda表达式(Lambda),本质上是<strong>可以传递给其他函数的一小段代码</strong></p></li><li><p>Lambda表达式语法</p><p><img src="https://gitee.com/domeofheaven2017/Image/raw/master/BlogImage/Lambda表达式语法.png" srcset="/img/loading.gif" alt="Lambda语法"></p><ul><li><p>可以把<code>Lambda</code>表达式存储在一个变量中,把这个变量当作<strong>普通函数</strong>对待.</p><pre><code class="hljs kotlin"><span class="hljs-comment">//定义</span><span class="hljs-keyword">val</span> sum = &#123;x:<span class="hljs-built_in">Int</span>,y:<span class="hljs-built_in">Int</span> -&gt; x + y &#125;<span class="hljs-comment">//调用</span>println(sum(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>))</code></pre></li><li><p><code>Kotlin</code>中当<code>Lambda</code>表达式是函数调用的最后一个实参时,可以将表达式放在括号外;且当<code>Lambda</code>式函数唯一的实参时,可以去掉调用代码中的空括号.</p><pre><code class="hljs kotlin"><span class="hljs-comment">//作用等价</span>people.maxBy(&#123; p:Person -&gt; p.age&#125;)people.maxBy()&#123; p:Person -&gt; p.age&#125;people.maxBy&#123; p:Person -&gt; p.age&#125;people.maxBy&#123; p -&gt; p.age&#125; <span class="hljs-comment">//编译器能推导出参数类型</span>people.maxBy&#123; it.age &#125;</code></pre></li><li><p><code>Lambda</code>也可以包含多条语句</p><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> sum = &#123;    x:<span class="hljs-built_in">Int</span>,y:<span class="hljs-built_in">Int</span> -&gt;    println(<span class="hljs-string">"Computing the sum of <span class="hljs-variable">$x</span> and <span class="hljs-variable">$y</span>"</span>)    x + y&#125;</code></pre></li></ul></li><li><p>成员引用</p><p>使用<code>::</code>运算符,将函数转换成一个值传递给函数</p><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> getAge = Person :: age<span class="hljs-comment">//引用顶层函数</span><span class="hljs-keyword">val</span> action = &#123; person : Person,message : String -&gt;              sendEmail(person,message)             &#125;<span class="hljs-keyword">val</span> nextAction = ::sendEmail</code></pre><blockquote><p>不管引用的是函数还是属性，都不要在成员引用的名称后面加括号 </p></blockquote></li><li><p>集合函数API</p><ul><li><p><code>filter</code>:过滤掉不满足给定lambda表达式的元素,结果是一个新集合</p><pre><code class="hljs kotlin"><span class="hljs-comment">//filter函数定义</span><span class="hljs-comment">/** * Returns a list containing only elements matching the given [predicate]. */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> Iterable<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">filter</span><span class="hljs-params">(predicate: (<span class="hljs-type">T</span>)</span></span> -&gt; <span class="hljs-built_in">Boolean</span>): List&lt;T&gt;&#123;    <span class="hljs-keyword">return</span> filterTo(ArrayList&lt;T&gt;(), predicate)&#125;<span class="hljs-comment">//filter函数使用</span><span class="hljs-keyword">val</span> list = listOf(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)println(list.filter &#123; it % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> &#125;)  <span class="hljs-comment">//[2,4]</span></code></pre></li><li><p><code>map</code>:对集合中的每个元素应用给定的函数,并把结果收集到一个新集合</p><pre><code class="hljs kotlin"><span class="hljs-comment">//map函数定义</span><span class="hljs-comment">/** * Returns a list containing the results of applying the given [transform] function * to each element in the original collection. */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T, R&gt;</span> Iterable<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">map</span><span class="hljs-params">(transform: (<span class="hljs-type">T</span>)</span></span> -&gt; R): List&lt;R&gt; &#123;    <span class="hljs-keyword">return</span> mapTo(ArrayList&lt;R&gt;(collectionSizeOrDefault(<span class="hljs-number">10</span>)), transform)&#125;<span class="hljs-comment">//map函数使用</span><span class="hljs-keyword">val</span> list = listOf(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)println(list.map&#123; it * <span class="hljs-number">2</span>&#125;) <span class="hljs-comment">//[2,4,6,8]</span></code></pre></li><li><p><code>all</code>:当所有元素都满足给定判别式时返回true</p><pre><code class="hljs kotlin"><span class="hljs-comment">//all函数定义</span><span class="hljs-comment">/** * Returns `true` if all elements match the given [predicate]. *  * <span class="hljs-doctag">@sample</span> samples.collections.Collections.Aggregates.all */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> Iterable<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">all</span><span class="hljs-params">(predicate: (<span class="hljs-type">T</span>)</span></span> -&gt; <span class="hljs-built_in">Boolean</span>): <span class="hljs-built_in">Boolean</span> &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> <span class="hljs-keyword">is</span> Collection &amp;&amp; isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>    <span class="hljs-keyword">for</span> (element <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>) <span class="hljs-keyword">if</span> (!predicate(element)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;<span class="hljs-comment">//all函数使用</span><span class="hljs-keyword">val</span> people = listOf(Person(<span class="hljs-string">"Stephanie"</span>,<span class="hljs-number">26</span>),Person(<span class="hljs-string">"Dome"</span>,<span class="hljs-number">24</span>))println(people.all&#123; it.age &lt; <span class="hljs-number">27</span> &#125;) <span class="hljs-comment">//true</span></code></pre></li><li><p><code>any</code>:检查集合所有元素中是否至少存在一个匹配的元素</p><pre><code class="hljs kotlin"><span class="hljs-comment">//any函数定义</span><span class="hljs-comment">/** * Returns `true` if collection has at least one element. *  * <span class="hljs-doctag">@sample</span> samples.collections.Collections.Aggregates.any */</span><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> Iterable<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">any</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> <span class="hljs-keyword">is</span> Collection) <span class="hljs-keyword">return</span> !isEmpty()    <span class="hljs-keyword">return</span> iterator().hasNext()&#125;<span class="hljs-comment">//any函数使用</span><span class="hljs-keyword">val</span> people = listOf(Person(<span class="hljs-string">"Stephanie"</span>,<span class="hljs-number">26</span>),Person(<span class="hljs-string">"Dome"</span>,<span class="hljs-number">24</span>))println(people.any&#123; it.age &lt; <span class="hljs-number">27</span> &#125;) <span class="hljs-comment">//true</span></code></pre></li><li><p><code>count</code>:返回集合中满足给定判断式的元素个数</p><pre><code class="hljs kotlin"><span class="hljs-comment">//count函数定义</span><span class="hljs-comment">/** * Returns the number of elements matching the given [predicate]. */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> Iterable<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">count</span><span class="hljs-params">(predicate: (<span class="hljs-type">T</span>)</span></span> -&gt; <span class="hljs-built_in">Boolean</span>): <span class="hljs-built_in">Int</span> &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> <span class="hljs-keyword">is</span> Collection &amp;&amp; isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>    <span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> (element <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>) <span class="hljs-keyword">if</span> (predicate(element)) count++    <span class="hljs-keyword">return</span> count&#125;<span class="hljs-comment">//count函数使用</span><span class="hljs-keyword">val</span> people = listOf(Person(<span class="hljs-string">"Stephanie"</span>,<span class="hljs-number">26</span>),Person(<span class="hljs-string">"Dome"</span>,<span class="hljs-number">24</span>))println(people.count&#123; it.age &gt; <span class="hljs-number">25</span> &#125;) <span class="hljs-comment">//1</span></code></pre></li><li><p><code>groupBy</code>:将集合按照给定的规则分成组,结果是一个<code>map</code></p><pre><code class="hljs kotlin"><span class="hljs-comment">/** * Groups elements of the original collection by the key returned by the given [keySelector] function * applied to each element and returns a map where each group key is associated with a list of corresponding elements. *  * The returned map preserves the entry iteration order of the keys produced from the original collection. *  * <span class="hljs-doctag">@sample</span> samples.collections.Collections.Transformations.groupBy */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T, K&gt;</span> Iterable<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">groupBy</span><span class="hljs-params">(keySelector: (<span class="hljs-type">T</span>)</span></span> -&gt; K): Map&lt;K, List&lt;T&gt;&gt; &#123;    <span class="hljs-keyword">return</span> groupByTo(LinkedHashMap&lt;K, MutableList&lt;T&gt;&gt;(), keySelector)&#125;<span class="hljs-comment">//groupBy使用</span><span class="hljs-keyword">val</span> list = listOf(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)println(list.groupBy &#123; it &gt; <span class="hljs-number">2</span> &#125;) <span class="hljs-comment">//&#123;false=[1, 2], true=[3, 4]&#125;</span></code></pre></li><li><p><code>flayMap</code>:对集合中的每个元素根据给定的函数作<strong>映射</strong>,然后将多个列表合并成一个</p><pre><code class="hljs kotlin"><span class="hljs-comment">/** * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original collection. */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T, R&gt;</span> Iterable<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">flatMap</span><span class="hljs-params">(transform: (<span class="hljs-type">T</span>)</span></span> -&gt; Iterable&lt;R&gt;): List&lt;R&gt; &#123;    <span class="hljs-keyword">return</span> flatMapTo(ArrayList&lt;R&gt;(), transform)&#125;<span class="hljs-comment">//flatMap函数使用 </span><span class="hljs-keyword">val</span> list = listOf(<span class="hljs-string">"Stephanie"</span>,<span class="hljs-string">"DomeOfHeaven"</span>)println(list.flatMap &#123; it.toList()&#125;)<span class="hljs-comment">//[S, t, e, p, h, a, n, i, e, D, o, m, e, O, f, H, e, a, v, e, n]</span></code></pre></li></ul></li><li><p>惰性集合操作:序列</p><p>链式集合函数会及早地创建中间集合，每一步的中间结果都被存储在一个临时列表。序列中的元素求值是惰性的，可以使用序列(Sequence)更高效地执行链式操作，不会创建中间结果。</p><ul><li><p>执行序列操作：中间和末端操作</p><ol><li><p>序列操作分为<code>中间的</code>和<code>末端的</code>两类，一次中间操作返回的是另一个序列；一个末端操作返回的是一个结果。</p></li><li><p>中间操作始终都是惰性的，末端操作触发执行了所有延期运算。</p></li><li><p>序列中所有操作都是按顺序应用在每一个元素上，处理完第一个(先映射再过滤),然后完成下面的元素，依次类推。</p></li></ol></li><li><p>创建序列</p><ol><li><p>在集合上调用<code>asSequence</code>方法</p><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> people = listOf(Person(<span class="hljs-string">"mym"</span>, <span class="hljs-number">26</span>), Person(<span class="hljs-string">"zzc"</span>, <span class="hljs-number">28</span>))people.asSequence().map(Person.age).filter&#123;it &gt;= <span class="hljs-number">27</span>&#125;.toList()</code></pre></li><li><p>使用<code>generateSequence</code>函数</p><pre><code class="hljs kotlin"><span class="hljs-comment">//给定序列的前一个元素，该函数会计算出下一个元素</span><span class="hljs-keyword">val</span> naturalNum = generateSequence(<span class="hljs-number">0</span>)&#123;it + <span class="hljs-number">1</span>&#125;</code></pre></li></ol></li></ul></li><li><p>使用Java函数式接口</p><ul><li><p>把lambda当作参数传递给Java方法</p></li><li><p>SAM构造方法：显式地把lambda转换成函数式接口</p><p>SAM代表单抽象方法，SAM构造方法是编译器生成的函数。</p><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createAllDone</span><span class="hljs-params">()</span></span>: Runnable &#123;    <span class="hljs-keyword">return</span> Runnable &#123;println(<span class="hljs-string">"All Done"</span>)&#125;&#125;</code></pre></li></ul></li><li><p><code>with</code>函数</p><pre><code class="hljs kotlin"><span class="hljs-comment">/** * Calls the specified function [block] with the given [receiver] as its receiver and returns its result. */</span><span class="hljs-meta">@kotlin</span>.<span class="hljs-keyword">internal</span>.InlineOnly<span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T, R&gt;</span> <span class="hljs-title">with</span><span class="hljs-params">(receiver: <span class="hljs-type">T</span>, block: <span class="hljs-type">T</span>.()</span></span> -&gt; R): R &#123;    contract &#123;        callsInPlace(block, InvocationKind.EXACTLY_ONCE)    &#125;    <span class="hljs-keyword">return</span> receiver.block()&#125;<span class="hljs-comment">//with函数使用</span>with(obj)&#123; <span class="hljs-comment">//this:obj</span>    ...&#125;</code></pre></li><li><p><code>apply</code>函数</p><pre><code class="hljs kotlin"><span class="hljs-comment">/** * Calls the specified function [block] with `this` value as its receiver and returns `this` value. */</span><span class="hljs-meta">@kotlin</span>.<span class="hljs-keyword">internal</span>.InlineOnly<span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> T.<span class="hljs-title">apply</span><span class="hljs-params">(block: <span class="hljs-type">T</span>.()</span></span> -&gt; <span class="hljs-built_in">Unit</span>): T &#123;    contract &#123;        callsInPlace(block, InvocationKind.EXACTLY_ONCE)    &#125;    block()    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>&#125;<span class="hljs-comment">//apply函数使用</span>obj.apply&#123; <span class="hljs-comment">//this:obj</span>    ...&#125;</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Lambda-编程&quot;&gt;&lt;a href=&quot;#Lambda-编程&quot; class=&quot;headerlink&quot; title=&quot;Lambda 编程&quot;&gt;&lt;/a&gt;Lambda 编程&lt;/h4&gt;&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Lambda 简介&lt;/p&gt;
&lt;p&gt;Lambda表达式(L
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>《Kotlin实战》学习笔记-类，对象和接口</title>
    <link href="http://yoursite.com/2020/08/23/%E3%80%8AKotlin%E5%AE%9E%E6%88%98%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%B1%BB%EF%BC%8C%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%8E%A5%E5%8F%A3/"/>
    <id>http://yoursite.com/2020/08/23/《Kotlin实战》学习笔记-类，对象和接口/</id>
    <published>2020-08-23T14:53:24.000Z</published>
    <updated>2020-08-23T14:53:50.024Z</updated>
    
    <content type="html"><![CDATA[<h4 id="类，对象和接口"><a href="#类，对象和接口" class="headerlink" title="类，对象和接口"></a>类，对象和接口</h4><ol><li><p>接口</p><pre><code class="hljs kotlin"><span class="hljs-comment">//声明</span><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Clickable</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">click</span><span class="hljs-params">()</span></span>      <span class="hljs-function"><span class="hljs-keyword">fun</span> showOff = <span class="hljs-title">println</span><span class="hljs-params">(<span class="hljs-string">"click show off"</span>)</span></span>　<span class="hljs-comment">//带默认实现的方法</span>&#125;<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Focusable</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">fun</span> showOff = <span class="hljs-title">println</span><span class="hljs-params">(<span class="hljs-string">"focus show off"</span>)</span></span>&#125;<span class="hljs-comment">//实现</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Button</span> : <span class="hljs-type">Clickable</span>,<span class="hljs-type">Focusable&#123;</span></span>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">click</span><span class="hljs-params">()</span></span> = println(<span class="hljs-string">"button clicked"</span>)        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">showOff</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">//使用尖括号加父类型名字的＂super＂表明调用哪一个父类的方法</span>        <span class="hljs-keyword">super</span>&lt;Clickable&gt;.showOff()        <span class="hljs-keyword">super</span>&lt;Focusable&gt;.showOff()    &#125;&#125;</code></pre><blockquote><ol><li>接口中可以包含抽象方法的定义和非抽象方法的实现，但不能包含任何状态．</li><li>使用<code>:</code>代替了Java中的<code>extends</code>和<code>implements</code>．</li><li>使用<code>override</code>修饰符来标注被重写的父类或者接口的方法和属性，是<strong>强制要求</strong>的．</li><li>如果实现多个接口中有相同带默认实现的方法，不会使用任何一个，必须显式实现该方法．</li></ol></blockquote></li><li><p>open,final和abstrace修饰符</p><pre><code class="hljs kotlin"><span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RichButton</span> : <span class="hljs-type">Clickable&#123;</span></span>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">disable</span><span class="hljs-params">()</span></span> &#123;&#125;    <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">animate</span><span class="hljs-params">()</span></span> &#123;&#125;    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">click</span><span class="hljs-params">()</span></span> &#123;&#125;    <span class="hljs-keyword">final</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">showOff</span><span class="hljs-params">()</span></span> &#123;&#125;&#125;<span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animated</span></span>&#123;    <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">animate</span><span class="hljs-params">()</span></span> <span class="hljs-comment">//抽象函数，子类必须重写</span>    <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">stopAnimating</span><span class="hljs-params">()</span></span> &#123;&#125;　    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">animateTwice</span><span class="hljs-params">()</span></span> &#123;&#125;&#125;</code></pre><blockquote><ol><li>Java中的类和方法默认是<code>open</code>的，而Kotlin中默认是<code>final</code>的，想继承或重写必须使用<code>open</code>修饰符</li><li>重写了的基类或者接口的成员默认是<code>open</code>的，可以使用<code>final</code>阻止重写</li><li>抽象类中抽象方法，子类必须实现，且抽象成员始终<code>open</code>的</li></ol></blockquote><p>| 修饰符   | 相关成员               | 备注                                        |<br>| ——– | ———————- | ——————————————- |<br>| final    | 不能被重写             | 类中成员默认使用                            |<br>| open     | 可以被重写             | 需要明确表明                                |<br>| abstract | 必须被重写             | 只能在抽象类中使用抽象成员不能有实现        |<br>| override | 重写父类或接口中的成员 | 没有使用<code>final</code>表明，重写的成员默认是开放的 |</p></li><li><p>可见性修饰符</p><p>| 修饰符         | 类成员       | 顶层声明     |<br>| ————– | ———— | ———— |<br>| public（默认） | 所有地方可见 | 所有地方可见 |<br>| internal       | 模块中可见   | 模块中可见   |<br>| protected      | 子类中可见   | －           |<br>| private        | 类中可见     | 文件中可见   |</p><blockquote><ol><li>类的基础类型和类型参数列表中用到的所有类，或者函数的签名都有与这个类或者函数本身相同的可见性</li><li>Kotlin中一个外部类不能看到其内部（或者嵌套）类中的<code>private</code>成员</li></ol></blockquote></li><li><p>内部类和嵌套类：默认是嵌套类</p><p>Java中在一个类中声明另一个类时，会默认变成其内部类。使用<code>static</code>修饰则会从这个类中删除包围它的类的隐式引用。</p><p>Kotlin中没有显示修饰符的嵌套类与Java中的static嵌套类是一样的。要把它变成一个内部类来持有一个外部类的引用的话需要使用<code>inner</code>修饰符。</p><p>|        类A在类B中声明        |    在Java中    |  在Kotlin中   |<br>| :————————–: | :————: | :———–: |<br>| 嵌套类（不存储外部类的引用） | static class A |    class A    |<br>|  内部类（存储外部类的引用）  |    class A     | inner class A |</p><pre><code class="hljs kotlin"><span class="hljs-comment">//引用外部类实例      </span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Outer</span></span>&#123;    <span class="hljs-keyword">inner</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span></span>&#123;        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getOutReference</span><span class="hljs-params">()</span></span>: Outer = <span class="hljs-keyword">this</span><span class="hljs-symbol">@Outer</span>    &#125;&#125;</code></pre></li><li><p>密封类：定义受限的类继承结构</p><p><code>sealed</code>类：为父类添加一个<code>sealed</code>修饰符，对可能创建的子类做出严格的限制．所有的子类必须嵌套在父类中．</p><blockquote><p><code>sealed</code>修饰符隐含的表示这个类是一个<code>open</code>类，不需要显式地添加<code>open</code>修饰符</p></blockquote><pre><code class="hljs kotlin"><span class="hljs-comment">//将基类标记为密封的，将所有可能的类作为嵌套类列出</span><span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Expr</span></span>&#123;    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Num</span></span>(<span class="hljs-keyword">val</span> value:<span class="hljs-built_in">Int</span>) : Expr()    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sum</span></span>(<span class="hljs-keyword">val</span> left:Expr,<span class="hljs-keyword">val</span> right:Expr) : Expr()&#125;<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">eval</span><span class="hljs-params">(e:<span class="hljs-type">Expr</span>)</span></span> : <span class="hljs-built_in">Int</span> =     <span class="hljs-keyword">when</span>(e)&#123;        <span class="hljs-keyword">is</span> Expr.Num -&gt; e.value        <span class="hljs-keyword">is</span> Expr.Sum -&gt; eval(e.right) + eval(e.left)         <span class="hljs-comment">//when　表达式涵盖了所有可能的情况，不需要　else 分支</span>    &#125;</code></pre><p><img src="https://gitee.com/domeofheaven2017/Image/raw/master/BlogImage/密封类不能在类外部拥有子类.png" srcset="/img/loading.gif" alt="密封类不能在类外部拥有子类"></p><center>密封类不能在类外部拥有子类</center></li><li><p>初始化类：主构造方法和初始化语句块</p><p>主构造方法：　表明构造方法的参数</p><p>　　　　　　　定义使用这些参数初始化的属性</p><blockquote><p>主构造方法不能包含初始化代码，相关初始化操作放在初始化语句块中执行</p></blockquote><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">constructor</span> </span>(_nickname : String) &#123; <span class="hljs-comment">//带一个参数的主构造方法</span>    <span class="hljs-keyword">val</span> nickname : String        <span class="hljs-comment">//初始化语句块</span>    <span class="hljs-keyword">init</span>&#123;        nickname = _nickname    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span></span>(<span class="hljs-keyword">val</span> nickname: String) <span class="hljs-comment">//val表示相应的属性会用构造方法的参数来初始化</span></code></pre><blockquote><p><code>constructor</code> : 用来开始一个主构造方法或从从构造方法的声明</p><p><code>init</code>: 引入一个初始语句块</p></blockquote></li><li><p>数据类和类委托</p><pre><code class="hljs kotlin"><span class="hljs-comment">//数据类</span><span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span></span>(<span class="hljs-keyword">val</span> name: String, <span class="hljs-keyword">val</span> postalCode: <span class="hljs-built_in">Int</span>)</code></pre><blockquote><p>定义了数据类之后，Kotlin会自动生成<code>equals</code>, <code>hashCode</code>, <code>toString</code>, <code>copy</code>方法</p><p>equals : 用来比较实例</p><p>hashCode : 用来作为例如<code>HashMap</code>这种基于哈希容器的键</p><p>toString : 用来为类生成按顺序排列的所有字段的字符串表达形式</p><p>copy : 拷贝类的实例，并可以在拷贝的同时修改某些属性的值</p></blockquote><pre><code class="hljs kotlin"><span class="hljs-comment">//类委托</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CountingSet</span>&lt;<span class="hljs-type">T</span>&gt; : <span class="hljs-type">MutableCollection</span>&lt;<span class="hljs-type">T</span>&gt; <span class="hljs-title">by</span> <span class="hljs-title">innerSet</span></span>&#123;&#125;</code></pre><blockquote><p>在实现一个接口时，可以使用<code>by</code>关键字将接口的实现委托到另一个对象。</p></blockquote></li><li><p><code>object</code>关键字:定义一个类并同时创建一个实例</p><ul><li><p>应用场景:</p><ol><li><p>定义单例:</p><pre><code class="hljs kotlin"><span class="hljs-comment">//定义</span><span class="hljs-keyword">object</span> Payroll&#123;    <span class="hljs-keyword">val</span> allEmployees = arrayListOf&lt;Person&gt;()    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">calculateSalary</span><span class="hljs-params">()</span></span>&#123;        ...    &#125;&#125;<span class="hljs-comment">//调用</span>Payroll.allEmployees.add(Person())Payroll.calculateSalary()</code></pre></li><li><p>伴生对象</p><blockquote><p><code>Kotlin</code>中的类不能拥有静态成员(没有<code>Java</code>中的<em>static</em>关键字),为了能在外部访问类中的私有成员,可以使用<strong>伴生对象</strong>.</p><p><strong>伴生对象</strong>是一个声明在类中的普通对象,可以实现接口或者有扩展函数或属性</p><p><strong>伴生对象成员</strong>在子类中不能被<em>重写</em></p></blockquote><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>&#123;    <span class="hljs-comment">//可以省略名称,默认名称为 Companion</span>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> Example&#123;        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span></span>&#123;            println(<span class="hljs-string">"Companion object called"</span>)        &#125;    &#125;&#125;<span class="hljs-comment">//调用</span>A.bar()A.Example.bar()</code></pre></li><li><p>匿名对象</p><blockquote><ul><li>替代了<code>Java</code>中的匿名内部类的用法.</li><li><code>Java</code>中匿名内部类只能扩展一个类或者实现一个接口;<code>Kotlin</code>中的匿名对象可以实现多个接口</li><li>匿名对象不是单例的,每次执行都会创建一个新的对象实例</li></ul></blockquote><pre><code class="hljs kotlin">windwo.addMouseListener(    <span class="hljs-keyword">object</span> : MouseAdapter()&#123;        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">mouseClicked</span><span class="hljs-params">(...)</span></span>&#123;            ...        &#125;        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">mouseEntered</span><span class="hljs-params">(...)</span></span>&#123;            ...        &#125;    &#125;)</code></pre></li></ol></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;类，对象和接口&quot;&gt;&lt;a href=&quot;#类，对象和接口&quot; class=&quot;headerlink&quot; title=&quot;类，对象和接口&quot;&gt;&lt;/a&gt;类，对象和接口&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;接口&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs kotlin&quot;&gt;&lt;sp
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>《Kotlin实战》学习笔记-函数的定义与调用</title>
    <link href="http://yoursite.com/2020/08/19/%E3%80%8AKotlin%E5%AE%9E%E6%88%98%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E8%B0%83%E7%94%A8/"/>
    <id>http://yoursite.com/2020/08/19/《Kotlin实战》学习笔记-函数的定义与调用/</id>
    <published>2020-08-19T13:17:40.000Z</published>
    <updated>2020-08-19T13:20:20.090Z</updated>
    
    <content type="html"><![CDATA[<h4 id="函数的定义与调用"><a href="#函数的定义与调用" class="headerlink" title="函数的定义与调用"></a>函数的定义与调用</h4><ol><li><p>让函数更好调用</p><ul><li><p>命名参数：当调用一个Kotlin定义的函数时，可以显式地标明一些参数的名称，如果在调用一个函数时，指明了一个参数的名称，在它之后的<strong>所有参数都要标明名称</strong>．</p><pre><code class="hljs kotlin">joinToString(collection,separator = <span class="hljs-string">""</span>,prefix = <span class="hljs-string">""</span>,postfix = <span class="hljs-string">""</span>)</code></pre></li><li><p>默认参数值：在Kotlin中，可以在声明函数的时候，指定参数的默认值，避免创建重载的函数．</p><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">joinToString</span><span class="hljs-params">(collection : <span class="hljs-type">Collection</span>&lt;<span class="hljs-type">T</span>&gt;,                    separator: <span class="hljs-type">String</span> = <span class="hljs-string">","</span>,                    prefix : <span class="hljs-type">String</span> = <span class="hljs-string">","</span>,                    postfix : <span class="hljs-type">String</span> = <span class="hljs-string">""</span>)</span></span>: String&#123;&#125;</code></pre></li><li><p>顶层函数与属性：Kotlin中函数不依托于类而存在，可以把函数放到代码文件的顶层，使用时<strong>import</strong>;</p><p>属性也可以放到文件的顶层．</p><blockquote><p>要改变包含Kotlin顶层函数的生成类的名称，需要为这个文件添加@JvmName的注解，将其放于文件开头，包名前面</p><pre><code class="hljs kotlin">&gt; <span class="hljs-meta">@file:JvmName</span>(<span class="hljs-string">"StringFunctions"</span>)&gt; <span class="hljs-keyword">package</span> strings&gt; <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">joinToString</span><span class="hljs-params">(...)</span></span>:String&#123;...&#125;&gt; <span class="hljs-comment">//调用</span>&gt; <span class="hljs-keyword">import</span> strings.StringFunctions;&gt;</code></pre></blockquote></li></ul></li><li><p>扩展函数和属性</p><ul><li><p>扩展函数：定义在类外部的<strong>静态成员函数</strong>．</p><blockquote><ol><li><p>在扩展函数中，可以直接访问被扩展的类的其他属性和方法，但<strong>不能访问私有的或者是受保护的成员</strong>．</p></li><li><p>扩展函数不能被<strong>重写</strong>，扩展函数并不是类的一部分，是声明在类外的，如果父类和子类分别定义一个同名的扩展函数，当函数被调用时，结果由<strong>该变量的静态类型</strong>所决定．</p><pre><code class="hljs kotlin">&gt;    <span class="hljs-function"><span class="hljs-keyword">fun</span> View.<span class="hljs-title">showOff</span><span class="hljs-params">()</span></span> = println(<span class="hljs-string">"I'm a view"</span>)  <span class="hljs-comment">//父类定义扩展函数</span>&gt;    <span class="hljs-function"><span class="hljs-keyword">fun</span> Button.<span class="hljs-title">showOff</span><span class="hljs-params">()</span></span> = println(<span class="hljs-string">"I'm a button"</span>)　<span class="hljs-comment">//子类定义同名扩展函数</span>&gt;    &gt;    <span class="hljs-keyword">val</span> view : View = Button()&gt;    view.showOff()　　<span class="hljs-comment">//输出：　I'm a view</span>&gt;</code></pre></li></ol></blockquote><blockquote><ol start="3"><li>如果一个类的成员函数和扩展函数有相同的签名，<strong>成员函数往往被优先使用</strong>．</li></ol></blockquote></li><li><p>扩展属性</p><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> StringBuilder.lastChar:<span class="hljs-built_in">Char</span>    <span class="hljs-keyword">get</span>() = <span class="hljs-keyword">get</span>(length - <span class="hljs-number">1</span>)    <span class="hljs-keyword">set</span>(value : <span class="hljs-built_in">Char</span>)&#123;        <span class="hljs-keyword">this</span>.setCharAt(length - <span class="hljs-number">1</span>,value)&#125;</code></pre><blockquote><ol><li>不能初始化</li><li>必须定义<strong>getter</strong>函数</li></ol></blockquote></li><li><p>Java中调用和访问</p><ol><li><p>调用扩展函数</p><pre><code class="hljs java"><span class="hljs-comment">//函数定义在　StringUtil.kt 中</span><span class="hljs-keyword">char</span> c = StringUtilKt.lastChar(<span class="hljs-string">"Java"</span>)</code></pre></li><li><p>访问扩展属性</p><pre><code class="hljs java">StringUtilKt.getLastChar(<span class="hljs-string">"Java"</span>)</code></pre></li></ol></li></ul></li><li><p>集合</p><ul><li><p>可变参数：可以传递任意个数的参数</p><pre><code class="hljs kotlin"><span class="hljs-comment">//使用　vararg 进行修饰</span><span class="hljs-function"><span class="hljs-keyword">fun</span> listOf<span class="hljs-type">&lt;T&gt;</span><span class="hljs-params">(<span class="hljs-keyword">vararg</span> values:<span class="hljs-type">T</span>)</span></span> : List&lt;T&gt; &#123;...&#125;</code></pre><blockquote><p>＊为展开运算符，可以解包数组</p><pre><code class="hljs kotlin">&gt; <span class="hljs-keyword">val</span> list = listOf(*args)&gt; println(list)&gt;</code></pre></blockquote></li><li><p>中缀调用</p><pre><code class="hljs kotlin"><span class="hljs-comment">//声明，使用infix修饰符 </span><span class="hljs-keyword">infix</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> Any.<span class="hljs-title">to</span><span class="hljs-params">(other : <span class="hljs-type">Any</span>)</span></span> = Pair(<span class="hljs-keyword">this</span>,other)<span class="hljs-comment">//调用</span><span class="hljs-number">1</span> to <span class="hljs-string">"one"</span><span class="hljs-keyword">var</span> (number, name) = <span class="hljs-number">1</span> to <span class="hljs-string">"one"</span> <span class="hljs-comment">//解构声明</span></code></pre></li><li><p>三重引号</p><p>三重引号中的任何字符都不需要进行转义．</p><pre><code class="hljs kotlin"><span class="hljs-string">"""(.+)/(.+)\.(.+)"""</span></code></pre></li></ul></li><li><p>局部函数：嵌套函数</p><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span></span>(<span class="hljs-keyword">val</span> id:<span class="hljs-built_in">Int</span>,<span class="hljs-keyword">val</span> name:String,<span class="hljs-keyword">val</span> address:String)<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">saveUser</span><span class="hljs-params">(user:<span class="hljs-type">User</span>)</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">validate</span><span class="hljs-params">(value:<span class="hljs-type">String</span>,fieldName:<span class="hljs-type">String</span>)</span></span>&#123;        <span class="hljs-keyword">if</span>(value.isEmpty())&#123;            <span class="hljs-keyword">throw</span> IllegalArgumentException(<span class="hljs-string">"..."</span>)        &#125;    &#125;    validate(user.name,<span class="hljs-string">"Name"</span>)    validate(user.address,<span class="hljs-string">"Address"</span>)&#125;</code></pre><blockquote><p>局部函数可以访问所在函数中的所有参数和变量</p></blockquote><pre><code class="hljs kotlin"><span class="hljs-comment">//提取到扩展函数</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span></span>(<span class="hljs-keyword">val</span> id:<span class="hljs-built_in">Int</span>,<span class="hljs-keyword">val</span> name:String,<span class="hljs-keyword">val</span> address:String)<span class="hljs-function"><span class="hljs-keyword">fun</span> User.<span class="hljs-title">validateBeforeSave</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">validate</span><span class="hljs-params">(value:<span class="hljs-type">String</span>,fieldName:<span class="hljs-type">String</span>)</span></span>&#123;        <span class="hljs-keyword">if</span>(value.isEmpty)&#123;            <span class="hljs-keyword">throw</span> IllegalArgumentException(<span class="hljs-string">"..."</span>)        &#125;    &#125;    validate(user.name,<span class="hljs-string">"Name"</span>)    validate(user.address,<span class="hljs-string">"Address"</span>)&#125;<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">saveUser</span><span class="hljs-params">(user:<span class="hljs-type">User</span>)</span></span>&#123;    user.validateBeforeSave()&#125;</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;函数的定义与调用&quot;&gt;&lt;a href=&quot;#函数的定义与调用&quot; class=&quot;headerlink&quot; title=&quot;函数的定义与调用&quot;&gt;&lt;/a&gt;函数的定义与调用&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;让函数更好调用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;命名参数：当调用一个Kot
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法-链表</title>
    <link href="http://yoursite.com/2020/08/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2020/08/19/数据结构与算法-链表/</id>
    <published>2020-08-19T12:40:19.000Z</published>
    <updated>2020-08-19T12:41:59.573Z</updated>
    
    <content type="html"><![CDATA[<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><hr><h4 id="一-定义"><a href="#一-定义" class="headerlink" title="一. 定义"></a>一. 定义</h4><p>链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。</p><h4 id="二-性质"><a href="#二-性质" class="headerlink" title="二. 性质"></a>二. 性质</h4><p>链表通常由一连串节点组成，每个节点包含任意的实例数据和一或两个用来指向上一个/或下一个节点的位置的链接，不必须按顺序存储，链表在插入的时候可以达到<strong>O(1)</strong>的复杂度，但是查找一个节点或者访问特定编号的节点则需要<strong>O(n)</strong>的时间。</p><ul><li>优点<ol><li>不需要预先知道数据大小</li><li>不必须顺序存储，可以充分利用内存空间</li><li>插入删除操作简单快速</li></ol></li><li>缺点<ol><li>增加了结点的指针域，空间开销较数组大</li><li>不能随机读取。</li></ol></li></ul><h4 id="三-类型"><a href="#三-类型" class="headerlink" title="三. 类型"></a>三. 类型</h4><pre class="mermaid">graph LRa[链表] --> b[单向链表]a --> c[双向链表]a --> e[循环链表]</pre><ol><li><p>单向链表</p><p><img src="https://gitee.com/domeofheaven2017/Image/raw/master/BlogImage/Singly linked list.PNG" srcset="/img/loading.gif" alt></p><p>一个单向链表的节点被分成两个部分。第一个部分保存或者显示关于节点的信息，第二个部分存储下一个节点的地址。单向链表只可向一个方向遍历。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> val;    <span class="hljs-keyword">public</span> ListNode next;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ListNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123; val = x; &#125;&#125;</code></pre><ul><li><p>插入</p><p>根据插入位置分为插入头结点，插入中间节点，插入尾节点（例如需要将p结点插入单链表head中）</p><ol><li><p>插入到头结点</p><p>直接将p结点的next指向头结点即可,p为新头结点</p><pre><code class="hljs java">p.next = head</code></pre></li><li><p>插入中间结点m后</p><p>遍历找到m结点，然后先将p的next指向m的next，再将m的next指向p</p><pre><code class="hljs java">ListNode tmp = head;<span class="hljs-keyword">while</span>(tmp != <span class="hljs-keyword">null</span>) &#123;    <span class="hljs-keyword">if</span>(tmp == m) &#123;        p.next = m.next;        m.next = p;        <span class="hljs-keyword">break</span>;    &#125;    tmp = tmp.next;&#125;</code></pre></li><li><p>插入到尾结点</p><p>除了尾结点的判断条件，整体流程与插入到中间结点一致</p><pre><code class="hljs java">ListNode tmp = head;<span class="hljs-keyword">while</span>(tmp.next != <span class="hljs-keyword">null</span>) &#123;    tmp = tmp.next;&#125;tmp.next = p;</code></pre></li></ol></li><li><p>删除</p><p>与插入一致，删除也分为三种情况：删除头结点，删除中间结点，删除尾结点</p><ol><li><p>删除头结点</p><p>将头结点自身设为null即可</p><pre><code class="hljs java">ListNode newHead = head.next;head = <span class="hljs-keyword">null</span>;</code></pre></li><li><p>删除中间结点</p><p>只需要将目标结点的前一个结点的next指向目标结点的下一个结点，再进行自身删除即可</p><pre><code class="hljs java">ListNode tmp = head;<span class="hljs-keyword">while</span>(tmp.next != <span class="hljs-keyword">null</span>) &#123;    <span class="hljs-keyword">if</span>(tmp.next == target) &#123;        tmp.next = target.next;        target = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">break</span>;    &#125;    tmp = tmp.next;&#125;</code></pre></li><li><p>删除尾结点</p><pre><code class="hljs java">ListNode tmp = head;<span class="hljs-keyword">while</span>(tmp.next != <span class="hljs-keyword">null</span>) &#123;    tmp = tmp.next;&#125;tmp = <span class="hljs-keyword">null</span>;</code></pre></li></ol></li></ul></li><li><p>双向链表</p><p><img src="https://gitee.com/domeofheaven2017/Image/raw/master/BlogImage/Doubly linked list.PNG" srcset="/img/loading.gif" alt></p><p>双向链表也叫双链表。双向链表中不仅有指向后一个节点的指针，还有指向前一个节点的指针。这样可以从任何一个节点访问前一个节点，当然也可以访问后一个节点，以至整个链表。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DoubleListNode</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> index;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> val;    <span class="hljs-keyword">public</span> DoubleListNode prev;    <span class="hljs-keyword">public</span> DoubleListNode next;&#125;</code></pre><ul><li><p>插入 : 在值索引<code>i</code>后添加结点<code>node</code></p><pre><code class="hljs java"><span class="hljs-comment">//1.找到索引i的结点</span>DoubleListNode tmp = head;<span class="hljs-keyword">while</span> (<span class="hljs-keyword">null</span> != tmp.next) &#123;    <span class="hljs-comment">//2.在i后插入结点，先处理后续结点关系</span>    <span class="hljs-keyword">if</span> (tmp.index == i) &#123;        node.next = tmp.next;        tmp.next.prev = node;        node.prev = tmp;        tmp.next = node;        <span class="hljs-keyword">break</span>;    &#125;    tmp = tmp.next;&#125;</code></pre></li><li><p>删除 ：删除索引为<code>i</code>的结点</p><pre><code class="hljs java"><span class="hljs-comment">//1.找到索引i的结点</span>DoubleListNode tmp = head;<span class="hljs-keyword">while</span> (<span class="hljs-keyword">null</span> != tmp) &#123;    <span class="hljs-keyword">if</span> (tmp.index = i) &#123;        <span class="hljs-comment">//2.将目标结点的前一个结点指向目标结点的后一个结点</span>        tmp.prev.next = tmp.next;        <span class="hljs-comment">//3.判断是否为最后一个结点，最后一个结点不需要进行处理</span>        <span class="hljs-keyword">if</span> (tmp.next != <span class="hljs-keyword">null</span>) &#123;            tmp.next.prev = tmp.prev;        &#125;        <span class="hljs-keyword">break</span>;    &#125;    tmp = tmp.next;&#125;</code></pre></li></ul></li><li><p>循环链表</p><p><img src="https://gitee.com/domeofheaven2017/Image/raw/master/BlogImage/circular linked list.PNG" srcset="/img/loading.gif" alt></p><p>在一个 循环链表中, 首节点和末节点被连接在一起。这种方式在单向和双向链表中皆可实现。(图中以单链表为例)</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CircleList</span></span>&#123;    <span class="hljs-comment">//头结点</span>    <span class="hljs-keyword">public</span> ListNode head;    <span class="hljs-comment">//尾结点</span>    <span class="hljs-keyword">public</span> ListNode tail;    <span class="hljs-comment">//链表长度</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> length;&#125;</code></pre></li></ol><ul><li><p>插入 ：循环链表末尾插入，新插入的结点需要指向头结点</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">insert</span><span class="hljs-params">(ListNode node)</span> </span>&#123;    <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-comment">//空链表</span>        head = node;        tail = node;    &#125; <span class="hljs-keyword">else</span> &#123;        node.next = head;        tail.next = node;        tail = node;    &#125;    length ++;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;</code></pre></li></ul><ul><li><p>删除 : 从循环链表中删除值为<code>i</code>的结点</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">delete</span><span class="hljs-params">(ListNode node)</span> </span>&#123;    ListNode tmp = head;    <span class="hljs-comment">//所找结点为头结点</span>    <span class="hljs-keyword">if</span> (node.equals(tmp)) &#123;        head = head.next;        tail.next = head;        length -- ;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">//遍历找该结点</span>        <span class="hljs-keyword">while</span> (tmp.next != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">if</span> (node.equals(tmp.next)) &#123;                ListNode n = tmp.next.next;                tmp.next = n;                length --;                <span class="hljs-keyword">break</span>;            &#125;            tmp = tmp.next;        &#125;    &#125;    <span class="hljs-keyword">return</span> tmp;&#125;</code></pre></li></ul><h4 id="四-常见应用"><a href="#四-常见应用" class="headerlink" title="四. 常见应用"></a>四. 常见应用</h4><p>​        链表用来构建许多其它数据结构，如堆栈，队列和他们的派生。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;链表&quot;&gt;&lt;a href=&quot;#链表&quot; class=&quot;headerlink&quot; title=&quot;链表&quot;&gt;&lt;/a&gt;链表&lt;/h3&gt;&lt;hr&gt;
&lt;h4 id=&quot;一-定义&quot;&gt;&lt;a href=&quot;#一-定义&quot; class=&quot;headerlink&quot; title=&quot;一. 定义&quot;&gt;&lt;/a&gt;一
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin基础</title>
    <link href="http://yoursite.com/2020/08/16/Kotlin%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2020/08/16/Kotlin基础/</id>
    <published>2020-08-16T02:59:44.000Z</published>
    <updated>2020-08-16T03:21:37.554Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Kotlin基础知识"><a href="#Kotlin基础知识" class="headerlink" title="Kotlin基础知识"></a>Kotlin基础知识</h3><ol><li><h5 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h5><ol><li><p>函数的基本构成</p><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> 函数名称 <span class="hljs-params">(参数列表)</span></span>: 返回类型 &#123;  函数体&#125;<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">max</span><span class="hljs-params">(a:<span class="hljs-type">Int</span>,b:<span class="hljs-type">Int</span>)</span></span>:<span class="hljs-built_in">Int</span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span>(a&gt;b) a <span class="hljs-keyword">else</span> b&#125;</code></pre></li><li><p>表达式和语句</p><p>表达式：有值，并且能作为另一个表达式的一部分使用</p><p>语   句：总是包含着它的代码块中的顶层元素，并且没有自己的值</p><blockquote><p>在Java中所有的控制结构都是语句；</p><p>在Kotlin中除了循环(for,do和do/while)以外大多数控制结构都是表达式</p></blockquote></li><li><p>省略返回值类型</p><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">max</span> <span class="hljs-params">( a:<span class="hljs-type">Int</span>,b:<span class="hljs-type">Int</span>)</span></span> = <span class="hljs-keyword">if</span>(a&gt;b) a <span class="hljs-keyword">else</span> b</code></pre><blockquote><p>如果函数体写在花括号中，则这个函数有代码块体，如果直接返回一个表达式，则它有表达式体</p></blockquote></li></ol></li><li><h5 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h5><ul><li><p>如果指定了初始化器，那么在不指定类型的情况下，编译器会分析初始化器表达式的值，并把它的类型作为变量的类型，</p><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>:<span class="hljs-built_in">Int</span>=&#123;  <span class="hljs-keyword">val</span> xValue = <span class="hljs-number">2.5</span>  <span class="hljs-keyword">val</span> yValue = <span class="hljs-number">3</span>  <span class="hljs-keyword">return</span> xValue + yValue&#125;</code></pre></li><li><p>如果没有指定初始化器，需要显示地指定它的类型，因为此时编译器无法推断出它的类型。</p><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;  <span class="hljs-keyword">val</span> eValue : <span class="hljs-built_in">Int</span>  println(<span class="hljs-string">"eValue = <span class="hljs-variable">$eValue</span>"</span>)&#125;</code></pre></li></ul><ol><li><p>可变变量和不可变变量</p><ul><li><p>Val(Value)-不可变引用：使用该关键字声明的变量不能在初始化后再次赋值．</p><ol><li><p>对应<strong>JAVA</strong>中的final变量</p></li><li><p>如果编译器确保只有唯一一条语句会被执行，可以根据条件使用不同的值来初始化</p><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> message:String<span class="hljs-keyword">if</span>(canPerformOperation())&#123;    message = <span class="hljs-string">"Success"</span>&#125;<span class="hljs-keyword">else</span>&#123;    message = <span class="hljs-string">"Failed"</span>&#125;</code></pre></li><li><p>虽然val引用自身不可变，但指向的对象是可变的</p><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> language = arrayListOf(<span class="hljs-string">"Java"</span>)language.add(<span class="hljs-string">"Kotlin"</span>)</code></pre></li></ol></li><li><p>Var(Variable)-可变引用：该关键字声明的变量的值可以改变．</p><ol><li>对应<strong>JAVA</strong>中的普通变量</li><li>var变量的类型是不可变的,编译器只会根据初始化器来推断变量的类型，如果需要则必须<strong>手动转换</strong>或者<strong>强制转换</strong></li></ol></li></ul></li></ol></li><li><h5 id="字符串模板"><a href="#字符串模板" class="headerlink" title="字符串模板"></a>字符串模板</h5><p>声明一个变量后，在变量名称前添加字符<code>$</code>,就可以在字符串字面值中引用该变量．</p><ol><li><p>打印字符串变量</p><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args:<span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span>&#123;    <span class="hljs-keyword">val</span> name = <span class="hljs-string">"Kotlin"</span>    printlin(<span class="hljs-string">"Hello,<span class="hljs-variable">$name</span>!"</span>)&#125;</code></pre></li><li><p>复杂表达式</p><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args:<span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span>&#123;    <span class="hljs-keyword">if</span>(args.size &gt; <span class="hljs-number">0</span>)&#123;        println(<span class="hljs-string">"Hello,<span class="hljs-subst">$&#123;args[<span class="hljs-number">0</span>]!&#125;</span>"</span>)    &#125;&#125;</code></pre></li><li><p>双引号嵌套</p><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args:<span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span>&#123;    println(<span class="hljs-string">"Hello,<span class="hljs-subst">$&#123;if(args.size &gt; <span class="hljs-number">0</span> args[<span class="hljs-number">0</span>] else "Kotln")&#125;</span>"</span>)&#125;</code></pre></li></ol></li><li><h5 id="类和属性"><a href="#类和属性" class="headerlink" title="类和属性"></a>类和属性</h5><pre><code class="hljs java"><span class="hljs-comment">//Java中的类</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;    <span class="hljs-keyword">private</span> String mName;        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span></span>&#123;        mName = name;    &#125;        <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> mName;    &#125;&#125;</code></pre><blockquote><p>字段和其访问器的组合为属性</p></blockquote><pre><code class="hljs kotlin"><span class="hljs-comment">//Kotlin中的类</span><span class="hljs-comment">//Kotlin中属性默认为public</span>Class Person(<span class="hljs-keyword">val</span> name:String)</code></pre><ol><li>Kotlin中属性默认为<strong>public</strong></li><li>声明属性时默认生成访问器，只读属性只生成<strong>getter</strong>,可写属性生成<strong>getter</strong>和<strong>setter</strong><pre><code class="hljs kotlin"><span class="hljs-comment">//自定义访问器</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span></span>(<span class="hljs-keyword">val</span> height:<span class="hljs-built_in">Int</span>,<span class="hljs-keyword">val</span> width:<span class="hljs-built_in">Int</span>)&#123;    <span class="hljs-keyword">val</span> isSquare:<span class="hljs-built_in">Boolean</span>    <span class="hljs-keyword">get</span>()&#123;        <span class="hljs-keyword">return</span> height == width    &#125;&#125;</code></pre></li></ol></li><li><h5 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h5><pre><code class="hljs kotlin"><span class="hljs-comment">//声明枚举类</span><span class="hljs-keyword">enum</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Color</span></span>&#123;    RED,ORANGE,YELLOW,GREEN,BLUE,INDIGO,VIOLET&#125;</code></pre><p>Kotlin中，<em>enum</em>是<strong>软关键字</strong>,在class前面才有特殊意义，其他地方只是普通名称</p><p>和Java一样，枚举不是值的列表，可以给枚举类声明属性和方法</p><pre><code class="hljs kotlin"><span class="hljs-keyword">enum</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Color</span> </span>( <span class="hljs-keyword">val</span> r : <span class="hljs-built_in">Int</span>, <span class="hljs-keyword">val</span> g : <span class="hljs-built_in">Int</span>, <span class="hljs-keyword">val</span> b : <span class="hljs-built_in">Int</span>  <span class="hljs-comment">//声明常量属性</span>) &#123;    RED(<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), ORANGE(<span class="hljs-number">255</span>, <span class="hljs-number">165</span>, <span class="hljs-number">0</span>);  <span class="hljs-comment">//必须添加分号结束</span>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">rgb</span><span class="hljs-params">()</span></span> = (r * <span class="hljs-number">256</span> + g) * <span class="hljs-number">256</span> + b  <span class="hljs-comment">//定义方法</span>&#125;</code></pre><blockquote><p>如果要在枚举类中定义任何方法，就要使用<strong>分号</strong>把枚举常量列表和方法定义分开。</p></blockquote></li><li><h5 id="When表达式"><a href="#When表达式" class="headerlink" title="When表达式"></a><strong>When</strong>表达式</h5><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getWarmth</span><span class="hljs-params">(color:<span class="hljs-type">Color</span>)</span></span> = <span class="hljs-keyword">when</span>(color)&#123;    Color.RED,Color.ORANGE,Color.YELLOW -&gt; <span class="hljs-string">"warm"</span>    Color.GREEN -&gt; <span class="hljs-string">"neutral"</span>    Color.BLUE,Color.INDIGO,Color.VIOLET -&gt; <span class="hljs-string">"cold"</span>&#125;</code></pre><blockquote><p><code>when</code>表达式的实参可以是任何对象</p></blockquote><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">mix</span><span class="hljs-params">(c1:<span class="hljs-type">Color</span>,c2:<span class="hljs-type">Color</span>)</span></span> = <span class="hljs-keyword">when</span>(setOf(c1,c2))&#123;    setOf(Color.RED,Color.YELLOW) -&gt; Color.ORANGE    setOf(Color.YELLOW,Color.BLUE) -&gt; Color.GREEN    setOf(Color.BLUE,Color.VIOLET) -&gt; Color.INDIGO    <span class="hljs-keyword">else</span> -&gt; <span class="hljs-keyword">throw</span> Exception(<span class="hljs-string">"Dirty Color"</span>)&#125;</code></pre><p>计算<code>(1+2)+4</code></p><pre><code class="hljs kotlin"><span class="hljs-comment">//类结构</span><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Expr</span></span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Num</span></span>(<span class="hljs-keyword">val</span> value:<span class="hljs-built_in">Int</span>) : Expr<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sum</span></span>(<span class="hljs-keyword">val</span> left:Expr,<span class="hljs-keyword">val</span> right:Expr) : Expr</code></pre><pre class="mermaid">   graph TB;A[Sum] --> B[Sum]A[Sum] --> C["Num(4)"]B[Sum] --> D["Num(1)"]B[Sum] --> E["Num(2)"]</pre><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">eval</span><span class="hljs-params">(e:<span class="hljs-type">Expr</span>)</span></span> : <span class="hljs-built_in">Int</span> = <span class="hljs-keyword">when</span>(e)&#123;    <span class="hljs-keyword">is</span> Num -&gt; e.value    <span class="hljs-keyword">is</span> Sum -&gt; eval(e.right)+eval(e.left)    <span class="hljs-keyword">else</span> -&gt; <span class="hljs-keyword">throw</span> IllegalArgumentException(<span class="hljs-string">"Unknown expression"</span>)&#125;</code></pre></li><li><p><strong>While</strong>循环</p><ol><li><p><code>while</code>循环</p><pre><code class="hljs kotlin"><span class="hljs-comment">//当codition为true时执行循环</span><span class="hljs-keyword">while</span>(codition)&#123;    <span class="hljs-comment">//循环体</span>&#125;</code></pre></li><li><p><code>do-while</code>循环</p><pre><code class="hljs kotlin"><span class="hljs-comment">//循环体第一次无条件执行，此后，当codition为true时才执行</span><span class="hljs-keyword">do</span>&#123;    <span class="hljs-comment">//循环体</span>&#125; <span class="hljs-keyword">while</span>(codition)</code></pre></li></ol></li><li><p><strong>for</strong>循环</p><p>kotlin使用<strong>区间</strong>的概念：［起始值．．结束值］</p><pre><code class="hljs kotlin"><span class="hljs-keyword">for</span>(i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span> until <span class="hljs-number">100</span> step <span class="hljs-number">2</span>)&#123;    &#125;<span class="hljs-keyword">for</span>(i <span class="hljs-keyword">in</span> <span class="hljs-number">100</span> downTo <span class="hljs-number">1</span> step <span class="hljs-number">2</span>)&#123;&#125;</code></pre></li><li><p>迭代<strong>map</strong></p><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> binaryReps = TreeMap&lt;<span class="hljs-built_in">Char</span>,String&gt;()<span class="hljs-keyword">for</span>(c <span class="hljs-keyword">in</span> <span class="hljs-string">'A'</span>..<span class="hljs-string">'F'</span>)&#123;    <span class="hljs-keyword">val</span> binary = Integer.toBinaryString(c.toInt())    binaryReps[c] = binary&#125;<span class="hljs-keyword">for</span>((letter,binary) <span class="hljs-keyword">in</span> binaryReps)&#123;    println(<span class="hljs-string">"<span class="hljs-variable">$letter</span> = <span class="hljs-variable">$binary</span>"</span>)&#125;</code></pre></li><li><p>Ktolin中的异常</p><ol><li><p>捕获异常</p><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">readNumber</span><span class="hljs-params">(reader:<span class="hljs-type">BufferedReader</span>)</span></span> : <span class="hljs-built_in">Int</span>?&#123;    <span class="hljs-keyword">try</span>&#123;        <span class="hljs-keyword">val</span> line = reader.readLine()        <span class="hljs-keyword">return</span> Interger.parseInt(line)    &#125;<span class="hljs-keyword">catch</span>(e:NumberFormatException)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>    &#125;<span class="hljs-keyword">finally</span>&#123;        reader.close()    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">readNumber</span><span class="hljs-params">(reader:<span class="hljs-type">BufferedReader</span>)</span></span>&#123;    <span class="hljs-keyword">val</span> number = <span class="hljs-keyword">try</span>&#123;        Integer.parseInt(reader.readLine())    &#125;<span class="hljs-keyword">catch</span>(e:NumberFormatException)&#123;        <span class="hljs-literal">null</span>    &#125;    println(number)&#125;</code></pre><blockquote><p><strong>try</strong>结构也可以作为表达式</p></blockquote></li><li><p>抛出异常</p><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> percentage = <span class="hljs-keyword">if</span>(number <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">100</span>)&#123;    number&#125;<span class="hljs-keyword">else</span>&#123;    <span class="hljs-keyword">throw</span> IllegalArgumentException(<span class="hljs-string">"...."</span>)&#125;</code></pre><blockquote><p>与<em>Java</em>中不同的是，<em>kotlin</em>中<strong>throw</strong>结构是一个表达式．</p></blockquote></li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Kotlin基础知识&quot;&gt;&lt;a href=&quot;#Kotlin基础知识&quot; class=&quot;headerlink&quot; title=&quot;Kotlin基础知识&quot;&gt;&lt;/a&gt;Kotlin基础知识&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;h5 id=&quot;函数&quot;&gt;&lt;a href=&quot;#函数&quot; class=
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法-二叉树</title>
    <link href="http://yoursite.com/2020/08/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2020/08/09/数据结构与算法-二叉树/</id>
    <published>2020-08-09T14:50:42.000Z</published>
    <updated>2020-08-09T15:02:31.078Z</updated>
    
    <content type="html"><![CDATA[<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><hr><h4 id="一-定义"><a href="#一-定义" class="headerlink" title="一. 定义"></a>一. 定义</h4><p>每个节点最多只有两个分支（即不存在分支度大于 2 的节点）的树结构。左子树和右子树是有顺序的，不能任意颠倒。</p><h4 id="二-性质"><a href="#二-性质" class="headerlink" title="二. 性质"></a>二. 性质</h4><ol><li>非空的二叉树，若树叶总数为<code>n0</code>,分支度为<code>n2</code>,则$n0 = n2 + 1$</li></ol><h4 id="三-类型"><a href="#三-类型" class="headerlink" title="三. 类型"></a>三. 类型</h4><pre class="mermaid">graph LRD[二叉树] --> G[完全二叉树]D --> H[平衡二叉树]D --> I[排序二叉树]G --> J[满二叉树]</pre><ul><li><p>满二叉树(Full Binary Tree)：一棵深度为<code>k</code>，且有<strong>2^k^ - 1</strong>个节点的二叉树。</p></li><li><p>完全二叉树(Complete Tree)：除最后一层外，如其余层都是满的，并且最后一层是满的或者是在右边缺少连续若干节点的二叉树</p><blockquote><p>具有<code>n</code>个节点的完全二叉树的深度为$\log_2{n} + 1$</p><p>深度为<code>k</code>的完全二叉树，至少有<strong>2^k-1^</strong>个节点，至多有<strong>2^k^ -1</strong>个节点</p></blockquote></li><li><p>平衡二叉树</p></li><li><p>排序二叉树</p></li></ul><h4 id="四-存储结构"><a href="#四-存储结构" class="headerlink" title="四. 存储结构"></a>四. 存储结构</h4><ul><li><p>顺序存储表示</p><p>二叉树可以用数组或链接串列来存储，若是满二叉树就能紧凑排列而不浪费空间。如果某个节点的索引为<em>i</em>，（假设根节点的索引为0）则在它左子节点的索引会是$2i + 1$，以及右子节点会是$2i + 2$；而它的父节点（如果有）索引则为$ \lfloor \frac{i-1}{2} \rfloor$这种方法更有利于紧凑存储和更好的访问的局部性，特别是在前序遍历中。然而，它需要连续的存储空间，这样在存储高度为<em>h</em>的<em>n</em>个节点所组成的一般树时，将浪费很多空间。在最糟糕的情况下，如果深度为<em>h</em>的二叉树其每个节点都只有右孩子，则该存储结构需要占用<strong>2^h^ - 1</strong>的空间，实际上却有h个节点，浪费了不少空间，是顺序存储结构的一大缺点。</p></li><li><p>链表存储表示</p><p>二叉树通常用树结点结构来存储。有时也包含指向唯一的父节点的指针。如果一个结点的子结点个数小于2，一些子结点指针可能为空值，或者为特殊的哨兵结点。 使用链表能避免顺序存储浪费空间的问题，算法和结构相对简单，但使用二叉链表，由于缺乏父链的指引，在找回父节点时需要重新扫描树得知父节点的节点地址。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> val;    <span class="hljs-keyword">public</span> TreeNode left;    <span class="hljs-keyword">public</span> TreeNode right;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TreeNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;        val = x;    &#125;&#125;</code></pre></li></ul><h4 id="五-遍历方法"><a href="#五-遍历方法" class="headerlink" title="五. 遍历方法"></a>五. 遍历方法</h4><ul><li><p>前序遍历：先访问根节点，再访问根的左节点和右节点</p><pre><code class="hljs java"><span class="hljs-comment">//递归方式</span><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    treeNodeTraversal(list, root);    <span class="hljs-keyword">return</span> list;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">treeNodeTraversal</span><span class="hljs-params">(List&lt;Integer&gt; list, TreeNode root)</span></span>&#123;    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span>;    &#125;;    <span class="hljs-comment">//访问根节点</span>    list.add(root.val);    <span class="hljs-comment">//遍历左子树</span>    treeNodeTraversal(list, root.left, <span class="hljs-number">0</span>);    <span class="hljs-comment">//遍历右子树</span>    treeNodeTraversal(list, root.right, <span class="hljs-number">0</span>);&#125;<span class="hljs-comment">//迭代方式</span><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> list;    &#125;    Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();    <span class="hljs-comment">//将根节点压入栈中</span>    stack.push(root);    <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;        TreeNode node = stack.pop();        <span class="hljs-comment">//访问根节点</span>        list.add(node.val);        <span class="hljs-comment">//由于栈是先入后出，所以右子节点先入栈，左子节点后入栈</span>        <span class="hljs-keyword">if</span> (node.right != <span class="hljs-keyword">null</span>) &#123;            stack.push(node.right);        &#125;        <span class="hljs-keyword">if</span> (node.left != <span class="hljs-keyword">null</span>) &#123;            stack.push(node.left);        &#125;    &#125;    <span class="hljs-keyword">return</span> list;&#125;</code></pre></li><li><p>中序遍历：先遍历左子节点，再遍历根节点，最后遍历右子节点</p><pre><code class="hljs java"><span class="hljs-comment">//递归方式</span><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    treeNodeTraversal(list, root);    <span class="hljs-keyword">return</span> list;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">treeNodeTraversal</span><span class="hljs-params">(List&lt;Integer&gt; list, TreeNode root)</span></span>&#123;    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span>;    &#125;;    <span class="hljs-comment">//先遍历左子节点</span>    treeNodeTraversal(list, root.left, <span class="hljs-number">0</span>);    <span class="hljs-comment">//访问</span>    list.add(root.val);    treeNodeTraversal(list, root.right, <span class="hljs-number">0</span>);&#125;<span class="hljs-comment">//非递归方式</span><span class="hljs-comment">//先将左节点全部入栈，遍历到叶子节点后一层层向上遍历根节点和右节点</span><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> list;    &#125;    Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();    TreeNode node = root;    <span class="hljs-comment">//判断条件 1. 栈为空，即遍历完毕或开始遍历；</span>    <span class="hljs-comment">//  2. node不为空则开始遍历</span>    <span class="hljs-keyword">while</span> (!stack.isEmpty() || node != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">if</span> (node != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">//将左节点入栈</span>            stack.push(node);            node = node.left;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">//左节点不存在，则访问该节点，再遍历右节点</span>            node = stack.pop();            list.add(node.val);            node = node.right;        &#125;    &#125;    <span class="hljs-keyword">return</span> list;&#125;</code></pre></li><li><p>后序遍历：先遍历左子节点，再遍历右子节点，最后遍历根节点</p><pre><code class="hljs java"><span class="hljs-comment">//递归方式</span><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    treeNodeTraversal(list, root);    <span class="hljs-keyword">return</span> list;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">treeNodeTraversal</span><span class="hljs-params">(List&lt;Integer&gt; list, TreeNode root)</span></span>&#123;    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span>;    &#125;;    <span class="hljs-comment">//遍历左子树</span>    treeNodeTraversal(list, root.left, <span class="hljs-number">0</span>);    <span class="hljs-comment">//遍历右子树</span>    treeNodeTraversal(list, root.right, <span class="hljs-number">0</span>);    <span class="hljs-comment">//访问根节点</span>    list.add(root.val);&#125;<span class="hljs-comment">//非递归方式</span><span class="hljs-comment">//前序遍历结果为“根左右”，如果修改遍历次序则为“根右左”，在进行倒序则为后序遍历“左右根”</span><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> list;    &#125;    <span class="hljs-comment">//遍历栈,遍历树节点</span>    Stack&lt;TreeNode&gt;  stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();    <span class="hljs-comment">//记录“根右左”遍历的值</span>    Stack&lt;Integer&gt; temp = <span class="hljs-keyword">new</span> Stack&lt;&gt;();    stack.push(root);    <span class="hljs-comment">//根据前序遍历修改遍历次序，使结果输出"根右左"</span>    <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;        TreeNode node = stack.pop();        temp.push(node.val);        <span class="hljs-keyword">if</span> (node.left != <span class="hljs-keyword">null</span>) &#123;            stack.push(node.left);        &#125;        <span class="hljs-keyword">if</span> (node.right != <span class="hljs-keyword">null</span>) &#123;            stack.push(node.right);        &#125;    &#125;    <span class="hljs-comment">//将“根右左”的结果倒序输出为"左右根"</span>    <span class="hljs-keyword">while</span> (!temp.isEmpty()) &#123;        list.add(temp.pop());    &#125;    <span class="hljs-keyword">return</span> list;&#125;</code></pre></li><li><p>层次遍历：每一层按照从左到右的顺序打印节点</p><pre><code class="hljs java"><span class="hljs-comment">//非递归方式</span><span class="hljs-comment">//使用一个队列，依次将节点子节点入队列，再依次出队列即可</span><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;    List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();  <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> result;    &#125;    <span class="hljs-comment">//遍历队列</span>    Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();    <span class="hljs-comment">//先将根节点入队列</span>    queue.add(root);    <span class="hljs-keyword">while</span> ( !queue.isEmpty()) &#123;        <span class="hljs-comment">//每层的数据放在一个数组中</span>        List&lt;Integer&gt; temp = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-comment">//当前队列里元素的数量就是当前层数的总节点数量</span>        <span class="hljs-keyword">int</span> size = queue.size();        <span class="hljs-comment">//使用一个循环遍历当前层数所有的节点</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; size ; i ++) &#123;            TreeNode node = queue.poll();            <span class="hljs-keyword">if</span> (node !=<span class="hljs-keyword">null</span>) &#123;                <span class="hljs-comment">//访问当前节点，并将其子节点入队列</span>                temp.add(node.val);                <span class="hljs-keyword">if</span> (node.left != <span class="hljs-keyword">null</span>) &#123;                    queue.add(node.left);                &#125;                <span class="hljs-keyword">if</span> (node.right != <span class="hljs-keyword">null</span>) &#123;                    queue.add(node.right);                &#125;            &#125;        &#125;        <span class="hljs-comment">//一层遍历完成，将数据添加到结果中</span>        result.add(temp);    &#125;    <span class="hljs-keyword">return</span> result;&#125;<span class="hljs-comment">//递归方式</span><span class="hljs-comment">//增加level表示层级，根据节点的层级，将节点的数据添加到想要数组中</span><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;    List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> result;    &#125;    <span class="hljs-comment">//加入根节点，开始递归遍历</span>    levelOrderDfs(<span class="hljs-number">1</span>, root, result);    <span class="hljs-keyword">return</span> result;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">levelOrderDfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> level, TreeNode node, List&lt;List&lt;Integer&gt;&gt; lists)</span> </span>&#123;    <span class="hljs-comment">//当前层级无相应数组时，添加一个空数组</span>    <span class="hljs-keyword">if</span> (lists.size() &lt; level) &#123;        lists.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;());    &#125;    <span class="hljs-comment">//访问节点值，并将其添加到对应层级的数组里</span>    lists.get(level - <span class="hljs-number">1</span>).add(node.val);    <span class="hljs-comment">//层级递增，遍历下一层，递归遍历左子节点和右子节点</span>    <span class="hljs-keyword">if</span> (node.left != <span class="hljs-keyword">null</span>) &#123;        levelOrderDfs(level + <span class="hljs-number">1</span>, node.left, lists);    &#125;    <span class="hljs-keyword">if</span> (node.right != <span class="hljs-keyword">null</span>) &#123;        levelOrderDfs(level + <span class="hljs-number">1</span>, node.right, lists);    &#125;&#125;</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;二叉树&quot;&gt;&lt;a href=&quot;#二叉树&quot; class=&quot;headerlink&quot; title=&quot;二叉树&quot;&gt;&lt;/a&gt;二叉树&lt;/h3&gt;&lt;hr&gt;
&lt;h4 id=&quot;一-定义&quot;&gt;&lt;a href=&quot;#一-定义&quot; class=&quot;headerlink&quot; title=&quot;一. 定义&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="树" scheme="http://yoursite.com/categories/%E6%A0%91/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法-树</title>
    <link href="http://yoursite.com/2020/08/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%A0%91/"/>
    <id>http://yoursite.com/2020/08/09/数据结构与算法-树/</id>
    <published>2020-08-09T14:50:08.000Z</published>
    <updated>2020-08-09T15:01:46.990Z</updated>
    
    <content type="html"><![CDATA[<h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><hr><h4 id="一-定义"><a href="#一-定义" class="headerlink" title="一. 定义"></a>一. 定义</h4><p>树是一种 <code>抽象数据类型(ADT)</code> 或是实现这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由 n 个有限节点组成的一个具有层次关系的集合。</p><blockquote><p>抽象数据类型(<strong>A</strong>bstract <strong>D</strong>ata <strong>T</strong>ype，<strong>ADT</strong>),是计算机科学中具有类似行为的特定类别的数据结构的数学模型</p></blockquote><h4 id="二-特点"><a href="#二-特点" class="headerlink" title="二. 特点"></a>二. 特点</h4><ul><li>每个节点只有有限个子节点或无子节点</li><li>没有父节点的节点称为根节点</li><li>每一个非根节点有且只有一个父节点</li><li>树里面没有环路</li></ul><h4 id="三-术语"><a href="#三-术语" class="headerlink" title="三. 术语"></a>三. 术语</h4><ol><li><strong>节点的度</strong>：一个节点含有的子树的个数称为该节点的度</li><li><strong>树的度</strong>：一棵树中，最大的节点度称为树的度</li><li><strong>叶节点</strong>或<strong>终端节点</strong>：度为零的节点</li><li><strong>非终端节点</strong>或<strong>分支节点</strong>：度不为零的节点</li><li><strong>父亲节点</strong>或<strong>父节点</strong>：若一个节点含有子节点，则这个节点称为其子节点的父节点</li><li><strong>孩子节点</strong>或<strong>子节点</strong>：一个节点含有的子树的根节点称为该节点的子节点</li><li><strong>兄弟节点</strong>：具有相同父节点的节点互称为兄弟节点</li><li>节点的<strong>层次</strong>：从根开始定义起，根为第 1 层，根的子节点为第 2 层，以此类推</li><li><strong>深度</strong>：对于任意节点 n,n 的深度为从根到 n 的唯一路径长，根的深度为 0</li><li><strong>高度</strong>：对于任意节点 n,n 的高度为从 n 到一片树叶的最长路径长，所有树叶的高度为 0</li><li><strong>堂兄弟节点</strong>：父节点在同一层的节点互为堂兄弟</li><li><strong>节点的祖先</strong>：从根到该节点所经分支上的所有节点</li><li><strong>子孙</strong>：以某节点为根的子树中任一节点都称为该节点的子孙</li><li><strong>森林</strong>：由 m（m&gt;=0）棵互不相交的树的集合称为森林</li></ol><h4 id="四-树的分类"><a href="#四-树的分类" class="headerlink" title="四. 树的分类"></a>四. 树的分类</h4><pre class="mermaid">graph LRA[树] --> B[无序树]A --> C[有序树]C --> D[二叉树]C --> E[霍夫曼树]C --> F[B树]D --> G[完全二叉树]D --> H[平衡二叉树]D --> I[排序二叉树]G --> J[满二叉树]</pre><ul><li>无序树：树中任意节点的子节点之间没有顺序关系</li><li>有序树：树中任意节点的子节点之间有顺序关系<ol><li>二叉树：每个节点最多含有两个子树的树</li><li>霍夫曼树：带权路径最短的二叉树称为哈夫曼树或最优二叉树</li><li>B 树：一种对读写操作进行优化的自平衡的二叉查找树，能够保持数据有序，拥有多于两个子树</li></ol></li></ul><h4 id="五-树的遍历"><a href="#五-树的遍历" class="headerlink" title="五. 树的遍历"></a>五. 树的遍历</h4><pre class="mermaid">graph LRa[树的遍历] --> bb[深度优先遍历] --> c[前序遍历]b --> e[中序遍历]b --> f[后序遍历]a --> d[广度优先遍历]</pre><ul><li><p>深度优先遍历：先访问子节点，再访问父节点，最后是第二个子节点</p><ol><li><p>前序遍历：先访问根，然后访问子树的遍历方式<br><img src="https://gitee.com/domeofheaven2017/Image/raw/master/BlogImage/Sorted_binary_tree_preorder.svg" srcset="/img/loading.gif" alt></p><p>前序遍历：<strong>F, B, A, D, C, E, G, I, H</strong>.</p></li><li><p>中序遍历：先访问左（右）子树，然后访问根，最后访问右（左）子树的遍历方式<br><img src="https://gitee.com/domeofheaven2017/Image/raw/master/BlogImage/Sorted_binary_tree_inorder.svg" srcset="/img/loading.gif" alt></p><p>中序遍历：<strong>A, B, C, D, E, F, G, H, I</strong>.</p></li><li><p>后序遍历:先访问子树，然后访问根的遍历方式</p><p><img src="https://gitee.com/domeofheaven2017/Image/raw/master/BlogImage/Sorted_binary_tree_postorder.svg" srcset="/img/loading.gif" alt></p><p>后序遍历：<strong>A, C, E, D, B, H, I, G, F</strong>.</p></li></ol></li><li>广度优先遍历<br><img src="https://gitee.com/domeofheaven2017/Image/raw/master/BlogImage/Sorted_binary_tree_breadth-first_traversal.svg" srcset="/img/loading.gif" alt><br>层次遍历：<strong>F, B, G, A, D, I, C, E, H</strong>.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;树&quot;&gt;&lt;a href=&quot;#树&quot; class=&quot;headerlink&quot; title=&quot;树&quot;&gt;&lt;/a&gt;树&lt;/h3&gt;&lt;hr&gt;
&lt;h4 id=&quot;一-定义&quot;&gt;&lt;a href=&quot;#一-定义&quot; class=&quot;headerlink&quot; title=&quot;一. 定义&quot;&gt;&lt;/a&gt;一. 定义
      
    
    </summary>
    
      <category term="树" scheme="http://yoursite.com/categories/%E6%A0%91/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Android开发艺术探索-Android中的线程和线程池</title>
    <link href="http://yoursite.com/2020/08/04/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-Android%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://yoursite.com/2020/08/04/Android开发艺术探索-Android中的线程和线程池/</id>
    <published>2020-08-04T13:29:14.000Z</published>
    <updated>2020-08-16T03:09:11.065Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Android中的线程和线程池"><a href="#Android中的线程和线程池" class="headerlink" title="Android中的线程和线程池"></a>Android中的线程和线程池</h3><hr><p>在操作系统中，线程是调度的最小单元，同时线程不能无限制的产生，线程的创建和销毁都需要开销，通过线程池可以避免因为频繁创建和销毁线程而导致的开销。</p><h6 id="一-主线程和子线程"><a href="#一-主线程和子线程" class="headerlink" title="一. 主线程和子线程"></a>一. 主线程和子线程</h6><ul><li><p>主线程:指<strong>进程</strong>所拥有的线程,主要处理和界面相关的事情,也称<code>UI线程</code>.</p><blockquote><p>为了避免界面卡顿,主线程中不能执行耗时的任务,会引起ANR</p></blockquote></li><li><p>子线程:也称<code>工作线程</code>,除主线程以外的线程都是子线程.主要执行耗时任务，如网络请求，I/O操作等</p></li></ul><h6 id="二-Android中的线程形态"><a href="#二-Android中的线程形态" class="headerlink" title="二. Android中的线程形态"></a>二. Android中的线程形态</h6><ul><li><p>AsyncTask</p><p>内部封装了<code>Thread</code>和<code>Handler</code>,在线程池中执行后台任务,把执行进度和结果返回给主线程.</p><blockquote><p>AsyncTask不适合执行特别耗时的后台任务</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncTask</span>&lt;<span class="hljs-title">Params</span>,<span class="hljs-title">Progress</span>,<span class="hljs-title">Result</span>&gt;</span>&#123;    <span class="hljs-comment">//AsyncTask参数</span>    <span class="hljs-comment">//Params:表示参数的类型</span>    <span class="hljs-comment">//Progress:后台任务的执行进度的类型</span>    <span class="hljs-comment">//Result:任务的返回结果的类型</span>    <span class="hljs-comment">/**    * 在主线程中执行,异步任务执行&#123;#doInBackground&#125;之前会被调用    **/</span>    <span class="hljs-meta">@MainThread</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onPreExecute</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-comment">/**    * 用于执行异步任务,在此方法中可以通过publishProgress方法更新进度    **/</span>    <span class="hljs-meta">@WorkerThread</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> Result <span class="hljs-title">doInBackground</span><span class="hljs-params">(Params... params)</span></span>;    <span class="hljs-comment">/**    * 在主线程中执行,用于更新任务进度    **/</span>    <span class="hljs-meta">@MainThread</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onProgressUpdate</span><span class="hljs-params">(Progress... values)</span> </span>&#123;    &#125;    <span class="hljs-comment">/**    * 在主线程中执行,在异步任务执行之后调用,用于返回结果    **/</span>    <span class="hljs-meta">@MainThread</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onPostExecute</span><span class="hljs-params">(Result result)</span> </span>&#123;    &#125;    <span class="hljs-comment">/**    * 执行在主线程,异步任务取消时调用,默认实现中直接调用了onCancelled()方法,所以    * 忽略了结果值,注意在覆写时不要使用super.onCancelled(result)    **/</span>    <span class="hljs-meta">@MainThread</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCancelled</span><span class="hljs-params">(Result result)</span> </span>&#123;        onCancelled();    &#125;   &#125;</code></pre><p>AsyncTask使用限制：</p><ol><li>AsyncTask的类必须在主线程加载</li><li>AsyncTask的对象必须在主线程创建</li><li>execute方法必须在UI线程调用</li><li>不要在程序中直接调用onPreExecute, onPostExecute, doInBackground, onProgressUpdate</li><li>一个AsyncTask对象只能执行一次，即只能调用一次execute方法</li></ol><p>工作原理:</p><pre class="mermaid">  graph TBA["excute(Params... params)"] --> B["executeOnExecutor(sDefaultExecutor,param)"]B --> C["SERIAL_EXECUTOR#execute(Runnable r)"]C --> D["SERIAL_EXECUTOR#scheduleNext()"]D --> E["THREAD_POOL_EXECUTOR#execute(Runnable r)"]</pre><blockquote><p>AsyncTask中有两个线程池(SERIAL_EXECUTOR,THREAD_POOL_EXECUTOR)和一个线程Handler(InternalHandler)</p><p>SERIAL_EXECUTOR:内部实现的<code>SerialExecutor</code>,用于任务的排队,接收到传递过来的<strong>FutureTask</strong>对象后将其插入到任务队列中,如果此时没有任务在执行则调用<em>scheduleNext</em>方法执行下一个任务.可以看出AsyncTask是<strong>串行执行</strong>的</p><p>THREAD_POOL_EXECUTOR:用于执行任务</p><p>InternalHandler:用于子线程切换到主线程</p></blockquote></li><li><p>HandlerThread</p><p>HandlerThread继承自Thread,其内部构建了一个消息处理循环</p><ul><li><p>用法</p><pre><code class="hljs java"><span class="hljs-comment">//创建HandlerThread实例</span>HandlerThread mMsgThread = <span class="hljs-keyword">new</span> HandlerThread(<span class="hljs-string">"msg-handler"</span>);<span class="hljs-comment">//启动</span>mMsgThread.start();<span class="hljs-comment">//关联Handler处理消息</span>Handler mMsgHandler = <span class="hljs-keyword">new</span> Handler(mMsgThread.getLooper())&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(Message msg)</span></span>&#123;        <span class="hljs-comment">//消息处理</span>    &#125;&#125;</code></pre></li></ul></li><li><p>IntentService</p><p>IntentService是继承了<em>Service</em>的一个<strong>抽象类</strong>.可用于执行后台耗时的任务,<strong>当任务执行完成后自动停止</strong>.</p><p>工作原理:</p><pre><code class="hljs java"><span class="hljs-comment">//onCreate</span><span class="hljs-comment">//创建一个HandlerThread,并通过其再创建mServiceHandler</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">super</span>.onCreate();    HandlerThread thread = <span class="hljs-keyword">new</span> HandlerThread(<span class="hljs-string">"IntentService["</span> + mName + <span class="hljs-string">"]"</span>);    thread.start();    mServiceLooper = thread.getLooper();    mServiceHandler = <span class="hljs-keyword">new</span> ServiceHandler(mServiceLooper);&#125;<span class="hljs-comment">//onStart中通过mServiceHandler发送消息,然后在ServiceHandler中调用onHandleIntent</span><span class="hljs-comment">//方法处理消息,并随后调用Service#stopSelt(startId)停止服务</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServiceHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Handler</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ServiceHandler</span><span class="hljs-params">(Looper looper)</span> </span>&#123;        <span class="hljs-keyword">super</span>(looper);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(Message msg)</span> </span>&#123;        onHandleIntent((Intent)msg.obj);        stopSelf(msg.arg1);    &#125;&#125;</code></pre><blockquote><ul><li>Service中的<code>stopSelf()</code>和<code>stopSelf(int startId)</code>都能停止服务,但<code>stopSelf()</code>会立刻停止服务,而<code>stopSelf(int startId)</code>会等待所有消息都处理完成后停止服务.</li><li><code>onHandleIntent</code>方法需要在子类中实现,根据Intent参数区分不同的任务并执行.</li><li><code>onHandleIntent</code>中的任务是排队执行的,执行顺序为发起请求的顺序.</li></ul></blockquote></li></ul><h6 id="三-Android中的线程池"><a href="#三-Android中的线程池" class="headerlink" title="三. Android中的线程池"></a>三. Android中的线程池</h6><ul><li><p>线程池的优点</p><ol><li>线程复用,避免线程重复创建和销毁带来的开销</li><li>有效控制线程池的最大并发数,避免大量的线程之间因资源抢占而阻塞</li><li>统一管理线程</li></ol></li><li><p>ThreadPoolExecutor</p><pre><code class="hljs java"><span class="hljs-comment">//构造方法</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize,                          <span class="hljs-keyword">int</span> maximumPoolSize,                          <span class="hljs-keyword">long</span> keepAliveTime,                          TimeUnit unit,                          BlockingQueue&lt;Runnable&gt; workQueue,                          ThreadFactory threadFactory,                          RejectedExecutionHandler handler)</span></span></code></pre><ol><li><p>构造参数</p><ul><li><p>corePoolSize:线程池的核心线程数,默认会一直存活.</p></li><li><p>maximumPoolSize:线程池能容纳的<strong>最大线程数</strong>,达到这个数值后,后续任务会被<strong>阻塞</strong></p></li><li><p>keepAliveTime:<strong>非核心线程</strong>闲置时的超时时长,超过这个时间后会被回收.</p><blockquote><p>如果设置<code>allowCoreThreadTimeOut</code>为<strong>True</strong>,可作用于核心线程</p></blockquote></li><li><p>unit:<code>keepAliveTime</code>参数时间单位</p></li><li><p>workQueue:线程池中的任务队列,通过线程池的<code>execute</code>方法提交的<em>Runnable</em>对象会存储在该参数中</p></li><li><p>threadFactory:线程工厂,为线程池提供创建新线程的功能</p></li><li><p>handler:当线程池无法执行新任务时,<code>ThreadPoolExecutor</code>会调用该handler的<strong>rejectedExecution</strong>方法,默认直接抛出<code>RejectedExecutionException</code></p></li></ul></li><li><p>执行规则</p><ul><li>如果线程池中的线程数未达到核心线程数,则直接启动核心线程执行任务</li><li>如果线程数量大于或等于核心线程数,任务会被插入到任务队列中排队等待</li><li>如果线程数量大于或等于核心线程数且任务队列也已满,此时如果线程数量未达到线程能容纳的最大值,则立刻启动一个非核心线程执行任务;如果达到了最大值则拒绝执行任务调用<code>rejectedExecution</code>方法</li></ul></li><li><p>线程池的分类</p><ul><li><p>FixedThreadPool</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nThreads)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,                                  <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,                                  <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;                                  ());&#125;</code></pre><p>通过<code>Executors</code>的<code>newFixedThreadPool</code>方法创建.一种线程数量固定的线程池,只有核心线程,没有超时机制和任务队列大小限制.</p></li><li><p>CachedThreadPool</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newCachedThreadPool</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">0</span>, Integer.MAX_VALUE,                                  <span class="hljs-number">60L</span>, TimeUnit.SECONDS,                                  <span class="hljs-keyword">new</span> SynchronousQueue&lt;Runnable&gt;());&#125;</code></pre><p>通过<code>Executors</code>的<code>newCachedThreadPool</code>方法来创建.一种线程数量不定的线程池,只有非核心线程,且最大线程数为<em>Interger.MAX_VALUE</em>.线程池中的空闲线程都有超时机制,超时时间为60s</p></li><li><p>ScheduledThreadPool</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ScheduledExecutorService <span class="hljs-title">newScheduledThreadPool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ScheduledThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize)</span> </span>&#123;    <span class="hljs-keyword">super</span>(corePoolSize, Integer.MAX_VALUE,          DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,          <span class="hljs-keyword">new</span> DelayedWorkQueue());&#125;</code></pre><p>通过<code>Executors</code>的<code>newSingleThreadScheduledExecutor</code>创建.核心线程数固定,非核心线程数最大为<em>Interger.MAX_VALUE</em>,非核心线程闲置时会被回收.用于执行定时任务和具有固定周期的重复任务.</p></li><li><p>SingleThreadExecutor</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newSingleThreadExecutor</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FinalizableDelegatedExecutorService        (<span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,                                <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,                                <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));&#125;</code></pre><p>通过<code>Executors</code>的<code>newSingleThreadExecutor</code>方法创建.线程池中只有一个核心线程,确保所有的任务都在同一个线程中按顺序执行.</p></li></ul></li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Android中的线程和线程池&quot;&gt;&lt;a href=&quot;#Android中的线程和线程池&quot; class=&quot;headerlink&quot; title=&quot;Android中的线程和线程池&quot;&gt;&lt;/a&gt;Android中的线程和线程池&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;在操作系统中，线程是调度的
      
    
    </summary>
    
      <category term="Android开发艺术探索" scheme="http://yoursite.com/categories/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Android开发艺术探索-Android的消息机制</title>
    <link href="http://yoursite.com/2020/08/03/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-Android%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2020/08/03/Android开发艺术探索-Android的消息机制/</id>
    <published>2020-08-03T14:49:27.000Z</published>
    <updated>2020-08-16T03:08:47.812Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Android的消息机制"><a href="#Android的消息机制" class="headerlink" title="Android的消息机制"></a>Android的消息机制</h3><hr><ol><li><h4 id="Android的消息机制概述"><a href="#Android的消息机制概述" class="headerlink" title="Android的消息机制概述"></a>Android的消息机制概述</h4><p>Android的消息机制主要指<strong>Handler</strong>的运行机制以及<strong>Handler</strong>所附带的<strong>MessageQueue</strong>和<strong>Looper</strong>的工作过程，Handler的主要作用是将一个任务切换到某个指定的线程中去执行。Handler创建时会采用当前线程的Looper来构建内部的消息循环系统，如果没有Looper会报错。线程中默认是没有Looper的，主线程（UI线程，即ActivityThread）被创建时会初始化Looper，所以主线程默认可以使用Handler</p><p><img src="https://gitee.com/domeofheaven2017/Image/raw/master/BlogImage/图10-1Handler的工作过程.png" srcset="/img/loading.gif" alt="图10-1Handler的工作过程"></p></li><li><h4 id="Android的消息机制分析"><a href="#Android的消息机制分析" class="headerlink" title="Android的消息机制分析"></a>Android的消息机制分析</h4><ul><li><p>ThreadLocal的工作原理</p><p>ThreadLocal:是一个线程内部的数据存储类，可以通过它在指定的线程存储和获取数据（其他线程无法获取）</p><pre><code class="hljs java"><span class="hljs-comment">//定义</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLocal</span>&lt;<span class="hljs-title">T</span>&gt;//<span class="hljs-title">set</span>方法<span class="hljs-title">public</span> <span class="hljs-title">void</span> <span class="hljs-title">set</span>(<span class="hljs-title">T</span> <span class="hljs-title">value</span>) </span>&#123;        Thread t = Thread.currentThread();        ThreadLocalMap map = getMap(t);        <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>)            map.set(<span class="hljs-keyword">this</span>, value);        <span class="hljs-keyword">else</span>            createMap(t, value);  &#125;  <span class="hljs-comment">//get方法</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;        Thread t = Thread.currentThread();        ThreadLocalMap map = getMap(t);        <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>) &#123;            ThreadLocalMap.Entry e = map.getEntry(<span class="hljs-keyword">this</span>);            <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)                T result = (T)e.value;                <span class="hljs-keyword">return</span> result;            &#125;        &#125;        <span class="hljs-keyword">return</span> setInitialValue();    &#125;</code></pre></li></ul></li></ol><ul><li><p>消息队列的工作原理</p><p>MessageQueue主要包含两个操作：<strong>插入</strong>和<strong>读取</strong>，对应<em>enqueueMessage</em>和<em>next</em>，MessageQueue是通过一个单链表的数据结构来维护消息列表的，不是队列。</p><blockquote><p>enqueueMessage方法的主要操作是单链表的插入操作</p><p>next方法的主要操作是构建一个无限循环，有消息时返回这条消息并移除；无消息时则进行阻塞。</p></blockquote></li><li><p>Looper的工作原理</p><p>Looper是消息循环，会不停的查看MessageQueue中是否有新消息，有则立即处理；无则进行阻塞。</p><p>重要方法：</p><p><code>prepare</code> : 为当前线程创建一个Looper</p><p><code>prepareMainLooper</code> : ActivityThread创建Looper使用</p><p><code>getMainLooper</code> : 获取主线程的Looper</p><p><code>quit</code> : 直接退出Looper</p><p><code>quitSafely</code> : 设定退出标记，在把消息队列中已有消息处理完后安全退出</p><p><code>loop</code> : 调用MessageQueue的next方法来获取新消息</p></li><li><p>Handler的工作原理</p><p><strong>Handler</strong>的工作主要包含消息的发送和接收过程。</p><p>发送消息的过程为向消息队列中插入一条消息，随后<strong>MessageQueue</strong>返回消息给<strong>Looper</strong>，<strong>Looper</strong>在交由<strong>Handler</strong>处理，即调用<strong>Handler</strong>的<em>dispatchMessage</em>方法</p><p><img src="https://gitee.com/domeofheaven2017/Image/raw/master/BlogImage/图10-2Handler消息处理流程.png" srcset="/img/loading.gif" alt="image-20200803223746136"></p></li></ul><ol start="3"><li><h4 id="主线程的消息循环"><a href="#主线程的消息循环" class="headerlink" title="主线程的消息循环"></a>主线程的消息循环</h4><p>主线程即ActivityThread,其入口方法为main，在main方法中通过Looper.prepareMainLooper来创建主线程的Looper以及MessageQueue，并通过Looper.loop方法来开启主线程的消息循环</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="hljs-string">"ActivityThreadMain"</span>);       <span class="hljs-comment">// Install selective syscall interception</span>    AndroidOs.install();       <span class="hljs-comment">// CloseGuard defaults to true and can be quite spammy.  We</span>    <span class="hljs-comment">// disable it here, but selectively enable it later (via</span>    <span class="hljs-comment">// StrictMode) on debug builds, but using DropBox, not logs.</span>    CloseGuard.setEnabled(<span class="hljs-keyword">false</span>);       Environment.initForCurrentUser();       <span class="hljs-comment">// Make sure TrustedCertificateStore looks in the right place for CA certificates</span>    <span class="hljs-keyword">final</span> File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());    TrustedCertificateStore.setDefaultUserDirectory(configDir);       Process.setArgV0(<span class="hljs-string">"&lt;pre-initialized&gt;"</span>);       Looper.prepareMainLooper();       <span class="hljs-comment">// Find the value for &#123;@link #PROC_START_SEQ_IDENT&#125; if provided on the command line.</span>    <span class="hljs-comment">// It will be in the format "seq=114"</span>    <span class="hljs-keyword">long</span> startSeq = <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span> (args != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = args.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;            <span class="hljs-keyword">if</span> (args[i] != <span class="hljs-keyword">null</span> &amp;&amp; args[i].startsWith(PROC_START_SEQ_IDENT)) &#123;                startSeq = Long.parseLong(                        args[i].substring(PROC_START_SEQ_IDENT.length()));            &#125;        &#125;    &#125;    ActivityThread thread = <span class="hljs-keyword">new</span> ActivityThread();    thread.attach(<span class="hljs-keyword">false</span>, startSeq);       <span class="hljs-keyword">if</span> (sMainThreadHandler == <span class="hljs-keyword">null</span>) &#123;        sMainThreadHandler = thread.getHandler();    &#125;       <span class="hljs-keyword">if</span> (<span class="hljs-keyword">false</span>) &#123;        Looper.myLooper().setMessageLogging(<span class="hljs-keyword">new</span>                LogPrinter(Log.DEBUG, <span class="hljs-string">"ActivityThread"</span>));    &#125;       <span class="hljs-comment">// End of event ActivityThreadMain.</span>    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);    Looper.loop();       <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"Main thread loop unexpectedly exited"</span>);&#125;</code></pre><p>ActivityThread通过ActivityThread.H来和消息队列进行交互。具体流程为：ActivityThread通过ApplicationThread和ActivityManagerService进行进程间通信，AMS以进程间通信的方式完成ActivityTread的请求后会回调ApplicationThread中的Binder方法，然后ApplicationThread会向H发送消息，H收到消息后将ApplicationThread中的逻辑切换到ActivityThread中去执行，即切换到主线程执行。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Android的消息机制&quot;&gt;&lt;a href=&quot;#Android的消息机制&quot; class=&quot;headerlink&quot; title=&quot;Android的消息机制&quot;&gt;&lt;/a&gt;Android的消息机制&lt;/h3&gt;&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;&lt;h4 id=&quot;Android的消息机
      
    
    </summary>
    
      <category term="Android开发艺术探索" scheme="http://yoursite.com/categories/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Android开发艺术探索-四大组件的工作过程</title>
    <link href="http://yoursite.com/2020/08/02/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/08/02/Android开发艺术探索-四大组件的工作过程/</id>
    <published>2020-08-02T12:13:21.000Z</published>
    <updated>2020-08-16T03:08:29.325Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第九章-四大组件的工作过程"><a href="#第九章-四大组件的工作过程" class="headerlink" title="第九章　四大组件的工作过程"></a>第九章　四大组件的工作过程</h3><ol><li><h4 id="四大组件的运行状态"><a href="#四大组件的运行状态" class="headerlink" title="四大组件的运行状态"></a>四大组件的运行状态</h4><ul><li><p>Activity</p><p>展示一个界面并和用户进行交互．由<strong>Intent</strong>触发启动 ，分为显示Intent和隐式Intent，显示Intent可以明确指向一个Activity组件，隐式Intent可以指向<strong>一个或多个</strong>Activity组件</p></li><li><p>Service</p><p>一种计算型组件，用于在后台执行一系列计算．与Activity只有一种启动状态不同，Service有两种状态：启动状态（startService）和绑定状态（bindService）．Service是运行在主线程中的．</p></li><li><p>BroadcastReceiver</p><p>一种消息型组件，用于在不同的组件，不同的应用之间传递消息．</p><p>广播有两种注册方式：</p><ol><li>静态注册：在AndroidManifest中注册广播，在应用安装时被系统解析，无须应用启动就可以收到相应的广播．</li><li>动态注册：通过<strong>Context.registerReceiver()</strong>和<strong>Context.unRegisterReceiver()</strong>来注册和注销广播，需要应用启动才能注册并接收广播．</li></ol></li><li><p>ContentProvider</p><p>一种数据共享型组件，用于向其它组件和应用共享数据．</p></li></ul></li><li><h4 id="Activity的工作过程"><a href="#Activity的工作过程" class="headerlink" title="Activity的工作过程"></a>Activity的工作过程</h4><ul><li><p>显示调用，启动Activity</p><pre><code class="hljs java">Intent intent = <span class="hljs-keyword">new</span> Intent(<span class="hljs-keyword">this</span>, TestActivity.Class);startActivity(intent);</code></pre></li><li><p>启动流程</p><pre class="mermaid">     sequenceDiagramActivity ->> Activity : startActvityActivity ->> Activity : startActivityForResultActivity ->> Instrumentation : execStartActivityInstrumentation ->> ActivityManagerService : ActivityManagerNative.getDefault().startActivityActivityManagerService ->> ActivityManagerService : startActivityActivityManagerService ->> ActivityStackSupervisor : startActivityLockedActivityStackSupervisor ->> ActivityStack : resumeTopActivitiesLockedActivityStack ->> ActivityStackSupervisor : startSpecificActivityLockedActivityStackSupervisor ->> ActivityStackSupervisor : realStartActivityLockedActivityStackSupervisor ->> ApplicationThread : sceduleLaunchActivityApplicationThread ->> ActivityThread : handleLaunchActivityActivityThread ->> ActivityThread : performLaunchActivity</pre><p><code>performLaunchActivity</code>方法具体内容：</p><ol><li>从<strong>ActivityClientRecord</strong>中获取待启动的Activity的组件信息</li><li>通过<strong>Instrumentation</strong>的<em>newActivity</em>方法使用类加载器创建Activity对象</li><li>通过<strong>LoadedApk</strong>的<em>makeApplication</em>方法来尝试创建Application对象</li><li>创建<strong>ContextImpl</strong>对象并通过Activity的<em>attach</em>方法完成h重要数据初始化</li><li>调用Activity的<em>onCreate</em>方法</li></ol></li></ul></li><li><h4 id="Service的工作过程"><a href="#Service的工作过程" class="headerlink" title="Service的工作过程"></a>Service的工作过程</h4><ul><li><p>启动状态：主要用于执行后台计算</p><pre><code class="hljs java"><span class="hljs-comment">//启动Service</span>Intent intentService = <span class="hljs-keyword">new</span> Intent(<span class="hljs-keyword">this</span>,TmpService.class);startService(intentService);</code></pre></li><li><p>绑定状态：用于其他组件和Service的交互</p><pre><code class="hljs java"><span class="hljs-comment">//绑定Service</span>Intent intentService = <span class="hljs-keyword">new</span> Intent(<span class="hljs-keyword">this</span>,TmpService.class);bindService(intentService,mServiceConn,BIND_AUTO_CREATE);</code></pre></li></ul><blockquote><p>两种状态可以共存，一个Service既可以处于启动状态，也可以同时处于绑定状态</p></blockquote><ol><li><p>Service的启动过程</p><pre class="mermaid">      sequenceDiagramActivity ->> ContextWrapper : startServiceContextWrapper ->> ContextImpl : startServiceContextImpl ->> ContextImpl : startServiceCommonContextImpl ->> ActivityManagerService : startServiceActivityManagerService ->> ActiveServices : startServiceLockedActiveServices ->> ActiveServices : startServiceInnerLockedActiveServices ->> ActiveServices : bringUpServiceLockedActiveServices ->> ApplicationThread : realStartServiceLockedApplicationThread ->> ApplicationThread : scheduleCreateServiceApplicationThread ->> ActivityThread : handleCreateService</pre><p><code>handleCreateService</code>方法具体内容：</p><ol><li>通过类加载器创建<strong>Service</strong>的实例</li><li>创建<strong>Application</strong>对象并调用其<em>onCreate</em></li><li>创建<strong>ContextImpl</strong>对象并通过<strong>Service</strong>的<em>attach</em>方法建立联系</li><li>调用<strong>Service</strong>的<em>onCreate</em>方法并将<strong>Service</strong>对象存到<strong>ActivityThread</strong>的列表中</li></ol></li><li><p>Service的绑定过程</p><pre class="mermaid">      sequenceDiagramContextWrapper ->> ContextImpl : bindServiceContextImpl ->> ContextImpl : bindServiceCommonContextImpl ->> LoadedApk : getServiceDispatcherLoadedApk -->> ContextImpl : ServiceDispatcher.InnerConnectionContextImpl ->> ActivityManagerService : bindServiceActivityManagerService ->> ActiveServices : bindServiceLockedActiveServices ->> ActiveServices : bringUpServiceLockedActiveServices ->> ApplicationThread : realStartServiceLockedApplicationThread ->> ActivityManagerService : handleBindServiceActivityManagerService ->> ActivityManagerService : publishServiceActivityManagerService ->> ActiveServices : publishServiceLocked</pre></li></ol></li><li><h4 id="BroadcastReceiver的工作过程"><a href="#BroadcastReceiver的工作过程" class="headerlink" title="BroadcastReceiver的工作过程"></a>BroadcastReceiver的工作过程</h4><ol><li><p>广播的注册过程</p><ul><li><p>静态注册</p><p>静态注册的广播在应用安装时由<code>PackageManagerService</code>来完成整个注册过程(其它三大组件亦是如此)</p></li><li><p>动态注册</p><pre class="mermaid">        sequenceDiagramContextWrapper ->> ContextImpl : registerReceiverContextImpl ->> ContextImpl : registerReceiverInternalContextImpl ->> LoadedApk : getReceiverDispatcherLoadedApk -->> ContextImpl : IIntentReceiverContextImpl ->> ActivityManagerService : registerReceiver</pre></li></ul></li><li><p>广播的发送和接收过程</p><ul><li><p>广播的发送过程</p><pre class="mermaid">        sequenceDiagramContextWrapper ->> ContextImpl : sendBroadcastContextImpl ->> ActivityManagerService : broadcastIntentActivityManagerService ->> ActivityManagerService : broadcastIntentLockedActivityManagerService ->> ActivityManagerService : scheduleBroadcastsLockedActivityManagerService ->> ActivityManagerService : processNextBroadcastActivityManagerService ->> ActivityManagerService : performReceiveLockedActivityManagerService ->> ApplicationThread : scheduleRegisteredReceiverApplicationThread ->> InnerReceiver : performReceiverInnerReceiver ->> LoadedApk.ReceiverDispatcher : performReceive</pre><blockquote><p>应用处于停止状态的两种情形：</p><ol><li>应用安装后未运行</li><li>应用被手动或其他应用强制停止</li></ol></blockquote></li></ul></li></ol></li><li><h4 id="ContentProvider的工作过程"><a href="#ContentProvider的工作过程" class="headerlink" title="ContentProvider的工作过程"></a>ContentProvider的工作过程</h4><p><strong>ContentProvider</strong>是一种内容共享型组件，它通过<em>Binder</em>向其他组件乃至其他应用提供数据。当<strong>ContentProvider</strong>所在的进程启动时，<strong>ContentProvider</strong>会同时启动并被发布到<strong>AMS</strong>中。这时候<strong>ContentProvider</strong>的<em>onCreate</em>要先于<strong>Application</strong>的<em>onCreate</em>而执行<br><img src="D:\Downloads\图片\图9-1 ContentProvider的启动过程.png" srcset="/img/loading.gif" alt="image-20200802104139887"></p><p>ContentProvider启动后，外界可以提供它所提供的<strong>增删改查</strong>四个接口来操作数据源，这四个方法都是通过Binder来调用的，外界无法直接访问ContentProvider，只能通过ActivityManagerService根据Uri来获取对应的ContentProvider的Binder接口IContentProvider，再通过IContentProvider访问ContentProvider中的数据源</p><ul><li><p>ContentProvider的启动过程(以query为例)</p><pre class="mermaid">     sequenceDiagramActivityThread ->> ActivityManagerService : startProcessLockedActivityManagerService ->> ActivityThread : mainActivityThread ->> ActivityThread : attachActivityThread ->> ActivityManagerService : attachApplicationActivityManagerService ->> ActivityManagerService : attachApplicationLockedActivityManagerService ->> ApplicationThread : bindApplicationApplicationThread ->> ActivityThread : handleBindApplication</pre><p><code>handleBindApplication</code>具体内容：</p><ol><li>创建<strong>ContextImpl</strong>和<strong>Instrumentation</strong></li><li>创建<strong>Application</strong>对象</li><li>启动当前进程的<strong>ContentProvider</strong>并调用其<em>onCreate</em>f方法</li><li>调用<strong>Application</strong>的<em>onCreate</em>方法</li></ol></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;第九章-四大组件的工作过程&quot;&gt;&lt;a href=&quot;#第九章-四大组件的工作过程&quot; class=&quot;headerlink&quot; title=&quot;第九章　四大组件的工作过程&quot;&gt;&lt;/a&gt;第九章　四大组件的工作过程&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;h4 id=&quot;四大组件的运行状态&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="Android开发艺术探索" scheme="http://yoursite.com/categories/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Android开发艺术探索-理解Window和WindowManager</title>
    <link href="http://yoursite.com/2020/07/26/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%90%86%E8%A7%A3Window%E5%92%8CWindowManager/"/>
    <id>http://yoursite.com/2020/07/26/Android开发艺术探索-理解Window和WindowManager/</id>
    <published>2020-07-26T12:11:07.000Z</published>
    <updated>2020-08-16T03:08:05.920Z</updated>
    
    <content type="html"><![CDATA[<h3 id="理解Window和WindowManager"><a href="#理解Window和WindowManager" class="headerlink" title="理解Window和WindowManager"></a>理解Window和WindowManager</h3><hr><p><strong>Window</strong>表示一个窗口的概念，是一个抽象类，它的具体实现是<code>PhoneWindow</code>。创建一个<strong>Window</strong>需要通过<strong>WindowManage</strong>来完成，<strong>WindowManager</strong>是外界访问<strong>Window</strong>的入口，<strong>Window</strong>的具体实现在<code>WindowManagerService</code>中，<strong>WindowManager</strong>和<code>WindwManagerService</code>的交互是一个<strong>IPC</strong>过程。Android中所有的视图都是通过<strong>Window</strong>来呈现的，<strong>Window</strong>是<strong>View</strong>的直接管理者。</p><h4 id="1-Window和WindowManager"><a href="#1-Window和WindowManager" class="headerlink" title="1. Window和WindowManager"></a>1. Window和WindowManager</h4><p>​    WindowManager常用的有三个方法：添加View, 更新View, 删除View</p><pre><code class="hljs java"><span class="hljs-comment">//添加View</span>mButton = <span class="hljs-keyword">new</span> Button(<span class="hljs-keyword">this</span>);mLayoutParams = <span class="hljs-keyword">new</span> WindowManager.LayoutParams(....);mLayoutParams.flags = LayoutParams.FLAG_NOT_TOUCH_MODAL...;mLayoutParams.gravity = Gravity.LEFT;mLayoutParams.x = <span class="hljs-number">100</span>;mLayoutParams.y = <span class="hljs-number">300</span>;mWindowManager.addView(mButton, mLayoutParams);</code></pre><blockquote><ul><li><p><code>flags</code>参数表示Window的属性：</p><p>FLAG_NOT_FOCUSABLE:Window不需要获取焦点，也不需要接收各种输入事件</p><p>FLAG_NOT_TOUCH_MODAL: 系统会将当前Window区域以外的单击事件传递给底层的Window,区域内View处理<br>FLAG_SHOW_WHEN_LOCKED: 可以让Window显示在锁屏的界面上</p></li><li><p>Window是分层的，每个Window都有对应的<code>z-ordered</code>，层级大的会覆盖在层级小的上面。</p></li><li><p><code>type</code>参数表示Window的类型，Window有三种类型，分别为</p><p><code>应用Window</code> : 对应着一个Activity.层级范围是==1~99==</p><p><code>子Window</code> : 不能单独存在，需要附属在特定的父Window中，比如dialog等，层级范围是==1000~1999==</p><p><code>系统Window</code> ：需要声明权限才能创建的Window，比如Toast和系统状态栏，层级范围是==2000~2999==</p></li></ul></blockquote><h4 id="2-Window的内部机制"><a href="#2-Window的内部机制" class="headerlink" title="2. Window的内部机制"></a>2. Window的内部机制</h4><p>​    每个Window都对应着一个View和一个ViewRootImpl,Window和View通过ViewRootImpl来建立联系。</p><ol><li><p>Window的添加过程</p><pre class="mermaid">   sequenceDiagramActor ->>+ Window : addViewWindow ->>+ WindowManager : addViewWindowManager ->>+ WindowManagerImpl : addViewWindowManagerImpl ->>+ WindowManagerGlobal : addViewWindowManagerGlobal ->> WindowManagerGlobal : 检查参数是否合法WindowManagerGlobal ->> WindowManagerGlobal : 创建ViewRootImpl,添加View列表WindowManagerGlobal ->> ViewRootImpl : 更新界面ViewRootImpl ->> WindowSession : 添加WindowWindowSession ->> WindowManagerService : 添加Window</pre></li><li><p>Window的删除过程</p><pre class="mermaid">   sequenceDiagramWindow... ->> WindowManagerImpl :removeViewWindowManagerImpl ->> WindowManagerImpl : 查找待删除的View索引WindowManagerImpl ->> WindowManagerImpl : 调用removeViewLocked完成删除</pre><blockquote><p>真正删除的逻辑在<code>dispatchDetachedFromWindow</code>方法中实现</p><ol><li>垃圾回收</li><li>通过Session的remove方法删除Window</li><li>调用View的dispatchDetachedFromWindow方法</li><li>调用WindowManagerGlobal的doRemoveView方法刷新数据</li></ol></blockquote></li><li><p>Window的更新过程</p><p>更新逻辑在<strong>WindowManagerGlobal</strong>的<code>updateViewLayout</code>中</p><ol><li>更新View的LayoutParams并替换掉原有的</li><li>更新ViewRootImpl中的LayoutParams</li></ol></li></ol><h4 id="3-Window的创建过程"><a href="#3-Window的创建过程" class="headerlink" title="3. Window的创建过程"></a>3. Window的创建过程</h4><ol><li><p>Activity的Window创建过程</p><pre class="mermaid">   sequenceDiagramActor ->> ActivityThread : startActivityActivityThread ->> ActivityThread : performLaunchActivityActivityThread ->> PolicyManager : attachPolicyManager ->> PolicyManager : makeNewWindowPolicyManager ->> Policy : makeNewWindow</pre><p>Activity将具体实现交给了Window，所以其逻辑在<code>PhoneWindow</code>中,大致步骤如下：</p><ol><li>如果没有DecorView，就创建它</li><li>将View添加到DecorView的mContentParent中</li><li>回调Activity的onContentChanged方法通知视图改变</li><li>调用Activity的makeVisible方法，完成DecorView的添加和显示</li></ol></li><li><p>Dialog的Window创建过程</p><ol><li>创建Window</li><li>初始化DecorView并将Dialog的视图添加到DecorView中</li><li>将DecorView添加到Window中并显示</li></ol><blockquote><p>普通的Dialog必须采用Activity的Context，否则会报缺失token的错误，应用token一般只有Activity拥有，但系统Window可以不需要token</p></blockquote></li><li><p>Toast的Window创建过程</p><p>在Toast内部有两类IPC过程，第一类是Toast访问<code>NotificationManagerService</code>,第二类是<code>NotificationManagerService</code>回调Toast中的TN接口。Toast属于系统Window。</p><pre class="mermaid">   sequenceDiagramToast ->> NotificationManagerService : showNotificationManagerService ->> NotificationManagerService : enqueueToastNotificationManagerService ->> NotificationManagerService : showNextToastoLockedNotificationManagerService ->>NotificationManagerService : scheduleTimeoutLocked</pre></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;理解Window和WindowManager&quot;&gt;&lt;a href=&quot;#理解Window和WindowManager&quot; class=&quot;headerlink&quot; title=&quot;理解Window和WindowManager&quot;&gt;&lt;/a&gt;理解Window和WindowManag
      
    
    </summary>
    
      <category term="Android开发艺术探索" scheme="http://yoursite.com/categories/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Android开发艺术探索-Android动画深入分析</title>
    <link href="http://yoursite.com/2020/07/22/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-Android%E5%8A%A8%E7%94%BB%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2020/07/22/Android开发艺术探索-Android动画深入分析/</id>
    <published>2020-07-22T13:26:37.000Z</published>
    <updated>2020-08-16T03:07:45.588Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Android动画深入分析"><a href="#Android动画深入分析" class="headerlink" title="Android动画深入分析"></a>Android动画深入分析</h3><hr><h4 id="1-View动画"><a href="#1-View动画" class="headerlink" title="1. View动画"></a>1. View动画</h4><p>​    View动画的作用对象是View,支持<code>平移动画</code>,<code>缩放动画</code>,<code>旋转动画</code>,<code>透明度动画</code>四种动画效果</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">标签</th><th style="text-align:center">子类</th><th style="text-align:center">效果</th></tr></thead><tbody><tr><td style="text-align:center">平移动画</td><td style="text-align:center">&lt;translate&#62;</td><td style="text-align:center">TransateAnimation</td><td style="text-align:center">移动View</td></tr><tr><td style="text-align:center">缩放动画</td><td style="text-align:center">&lt;scale&#62;</td><td style="text-align:center">ScaleAnimation</td><td style="text-align:center">放大或缩小View</td></tr><tr><td style="text-align:center">旋转动画</td><td style="text-align:center">&lt;rotate&#62;</td><td style="text-align:center">RotateAnimation</td><td style="text-align:center">旋转View</td></tr><tr><td style="text-align:center">透明度动画</td><td style="text-align:center">&lt;alpha&#62;</td><td style="text-align:center">AlphaAnimation</td><td style="text-align:center">改变View透明度</td></tr></tbody></table><h5 id="1-使用步骤"><a href="#1-使用步骤" class="headerlink" title="1.使用步骤"></a>1.使用步骤</h5><ol><li><p>在res/anim/路径下创建动画的xml文件</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">set</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://scemas.android.com/apk/res/android"</span>     <span class="hljs-attr">android:fillAfter</span>=<span class="hljs-string">"true"</span>     <span class="hljs-attr">android:zAdjustment</span>=<span class="hljs-string">"normal"</span> &gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">rotate</span>            <span class="hljs-attr">android:duration</span>=<span class="hljs-string">"400"</span>            <span class="hljs-attr">android:fromDegress</span>=<span class="hljs-string">"0"</span>            <span class="hljs-attr">android:toDegress</span>=<span class="hljs-string">"90"</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span></code></pre></li><li><p>在代码中调用</p><pre><code class="hljs java">Animation animation = AnimationUtils.loadAnimation(<span class="hljs-keyword">this</span>, R.anim.animation_file);mButton.startAnimation(animation)</code></pre><p>也可直接在代码中进行设置和调用</p><pre><code class="hljs java">AlphaAnimation alphaAnim = <span class="hljs-keyword">new</span> AlphaAnimation(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);alphaAnim.setDuration(<span class="hljs-number">300</span>);mButton.startAnimation(animation)</code></pre></li></ol><h5 id="2-自定义View动画"><a href="#2-自定义View动画" class="headerlink" title="2.自定义View动画"></a>2.自定义View动画</h5><ol><li>继承Animation</li><li><p>重写<code>initialize</code>和<code>applyTransformation</code>方法</p><blockquote><p>initialize : 初始化</p><p>applyTransformation : 进行相应的矩阵变换</p></blockquote></li></ol><h4 id="2-帧动画"><a href="#2-帧动画" class="headerlink" title="2. 帧动画"></a>2. 帧动画</h4><p>​    帧动画是顺序播放一组预先定义好的图片。</p><h5 id="1-使用步骤-1"><a href="#1-使用步骤-1" class="headerlink" title="1. 使用步骤"></a>1. 使用步骤</h5><ol><li><p>通过XML定义AnimationDrawable</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- res/drawable/frame_anim.xml --&gt;</span><span class="hljs-meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">animation-list</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://scemas.android.com/apk/res/android"</span>                <span class="hljs-attr">android:oneshot</span>=<span class="hljs-string">"false"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">andrid:drawable</span>=<span class="hljs-string">"@drawable/image1"</span> <span class="hljs-attr">android:duration</span>=<span class="hljs-string">"500"</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">andrid:drawable</span>=<span class="hljs-string">"@drawable/image2"</span> <span class="hljs-attr">android:duration</span>=<span class="hljs-string">"500"</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">andrid:drawable</span>=<span class="hljs-string">"@drawable/image3"</span> <span class="hljs-attr">android:duration</span>=<span class="hljs-string">"500"</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">animation-list</span>&gt;</span></code></pre><ol start="2"><li>代码中调用</li></ol><pre><code class="hljs java">mButton.setBackroundResource(R.drawable.frame_anim);AnimationDrawable drawable = (AnimationDrawable) mButton.getBackground();drawable.start();</code></pre></li></ol><h4 id="3-View动画的特殊使用场景"><a href="#3-View动画的特殊使用场景" class="headerlink" title="3. View动画的特殊使用场景"></a>3. View动画的特殊使用场景</h4><ol><li><p>LayoutAnimation</p><p>LayoutAnimation作用于ViewGroup,为ViewGroup指定一个动画，子元素都会具有该动画效果</p></li><li><p>Activity的切换效果</p><p>主要用到<code>overridePendingTransition(int enterAnim, int exitAnim)</code>方法，这个方法必须在<strong>startActivity</strong>或者<strong>finish</strong>方法之后调用才能生效</p><p>enterAnim ： Activity被打开时的动画资源</p><p>exitAnim ： Activity被暂停时的动画资源</p></li></ol><h4 id="4-属性动画"><a href="#4-属性动画" class="headerlink" title="4. 属性动画"></a>4. 属性动画</h4><p>​        属性动画可以对任意对象的属性进行动画而不仅仅是View,动画的默认时间间隔是300ms,默认帧率是10ms/帧，其可以达到的效果是：在一个时间间隔内完成对象从一个属性值到另一个属性值的改变。</p><blockquote><p>插值器(TimeInterpolator)：根据时间流逝的百分比来计算当前属性值改变的百分比</p><p>估值器(TypeEvaluator)：根据当前属性改变的百分比来计算改变后的属性值</p></blockquote><p>属性动画的监听器：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AnimatorListener</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onAnimationStart</span><span class="hljs-params">(Animator animation)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onAnimationEnd</span><span class="hljs-params">(Animator animation)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onAnimationCancel</span><span class="hljs-params">(Animator animation)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onAnimationRepeat</span><span class="hljs-params">(Animator animation)</span></span>;&#125;</code></pre><p>属性动画的工作原理：</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Android动画深入分析&quot;&gt;&lt;a href=&quot;#Android动画深入分析&quot; class=&quot;headerlink&quot; title=&quot;Android动画深入分析&quot;&gt;&lt;/a&gt;Android动画深入分析&lt;/h3&gt;&lt;hr&gt;
&lt;h4 id=&quot;1-View动画&quot;&gt;&lt;a hre
      
    
    </summary>
    
      <category term="Android开发艺术探索" scheme="http://yoursite.com/categories/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Android开发艺术探索-理解RemoteViews</title>
    <link href="http://yoursite.com/2020/07/19/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%90%86%E8%A7%A3RemoteViews/"/>
    <id>http://yoursite.com/2020/07/19/Android开发艺术探索-理解RemoteViews/</id>
    <published>2020-07-19T12:46:27.000Z</published>
    <updated>2020-08-16T03:07:22.001Z</updated>
    
    <content type="html"><![CDATA[<h3 id="理解RemoteViews"><a href="#理解RemoteViews" class="headerlink" title="理解RemoteViews"></a>理解RemoteViews</h3><h4 id="1-RemoteViews的应用"><a href="#1-RemoteViews的应用" class="headerlink" title="1. RemoteViews的应用"></a>1. RemoteViews的应用</h4><p>RemoteViews在实际开发中主要用在通知栏和桌面小部件的开发中。通知栏主要通过<code>NotificationManager</code>的<strong>notify</strong>方法实现，桌面小部件则通过<code>AppWidgetProvider</code>实现。这两个的界面都运行在系统的<strong>SystemServer</strong>进程中，无法直接更新View.</p><h5 id="1-RemoteViews在通知栏上的应用"><a href="#1-RemoteViews在通知栏上的应用" class="headerlink" title="1.RemoteViews在通知栏上的应用"></a>1.RemoteViews在通知栏上的应用</h5><ul><li><p>使用系统默认样式</p><pre><code class="hljs java"><span class="hljs-comment">// Build the notification and add the action.</span>Notification newMessageNotification = <span class="hljs-keyword">new</span> Notification.Builder(context, CHANNEL_ID)        .setSmallIcon(R.drawable.ic_message)        .setContentTitle(getString(R.string.title))        .setContentText(getString(R.string.content))        .addAction(action)        .build();<span class="hljs-comment">// Issue the notification.</span>NotificationManagerCompat notificationManager = NotificationManagerCompat.from(<span class="hljs-keyword">this</span>);notificationManager.notify(notificationId, newMessageNotification);</code></pre></li><li><p>自定义通知</p><pre><code class="hljs java"><span class="hljs-comment">// Get the layouts to use in the custom notification</span>RemoteViews notificationLayout = <span class="hljs-keyword">new</span> RemoteViews(getPackageName(), R.layout.notification_small);RemoteViews notificationLayoutExpanded = <span class="hljs-keyword">new</span> RemoteViews(getPackageName(), R.layout.notification_large);<span class="hljs-comment">// Apply the layouts to the notification</span>Notification customNotification = <span class="hljs-keyword">new</span> NotificationCompat.Builder(context, CHANNEL_ID)        .setSmallIcon(R.drawable.notification_icon)        .setStyle(<span class="hljs-keyword">new</span> NotificationCompat.DecoratedCustomViewStyle())        .setCustomContentView(notificationLayout)        .setCustomBigContentView(notificationLayoutExpanded)        .build();</code></pre></li></ul><h5 id="2-RemoteViews在桌面小部件上的应用"><a href="#2-RemoteViews在桌面小部件上的应用" class="headerlink" title="2.RemoteViews在桌面小部件上的应用"></a>2.RemoteViews在桌面小部件上的应用</h5><pre><code>AppWidgetProvider是Android中提供的用于实现桌面小部件的类，本质是一个广播</code></pre><ul><li><p>定义小部件界面</p><p>在res/layout/下建立小部件布局界面</p></li><li><p>定义小部件配置信息</p><p>在res/xml/下建立小部件配置信息</p><blockquote><p>重要参数说明：</p><p>initLayout:初始化界面</p><p>updatePeriodMillis:自动更新周期</p></blockquote></li><li><p>定义小部件的实现类</p><p>继承AppWidgetProvider实现具体逻辑</p><blockquote><p>重要方法说明：</p><p>onEnable:小部件第一次添加到桌面时调用该方法</p><p>onUpdate:小部件被添加时或者每次小部件更新时都会调用该方法</p><p>onDeleted:每删除一次桌面小部件就调用一次</p><p>onDisabled:最后一个该类型的桌面小部件被删除时调用该方法</p><p>onReceive:分发具体的事件给其他方法</p></blockquote></li><li><p>在AndroidManifest.xml中声明小部件</p><h5 id="3-PendingIntent概述"><a href="#3-PendingIntent概述" class="headerlink" title="3.PendingIntent概述"></a>3.PendingIntent概述</h5></li></ul><p>​        PendingIntent表示一种处于待定，等待，即将发生状态的意图，支持三种待定意图：启动Activity,启动Service,发送        广播</p><pre><code class="hljs java">getActivity(Context context, <span class="hljs-keyword">int</span> requestCode, Intent intent, <span class="hljs-keyword">int</span> flags);getService(Context context, <span class="hljs-keyword">int</span> requestCode, Intent intent, <span class="hljs-keyword">int</span> flags);getBroadcast(Context context, <span class="hljs-keyword">int</span> requestCode, Intent intent, <span class="hljs-keyword">int</span> flags);</code></pre><ul><li><p>匹配规则：如果两个PendingIntent它们内部的<code>Intent</code>相同并且<code>requestCode</code>也相同，则这两个PendingIntent相同</p><blockquote><p>Intent匹配规则：如果两个Intent的<code>ComponentName</code>和<code>intent-filter</code>都相同，则这两个Intent相同</p></blockquote></li><li><p>Flag参数</p><ul><li><p>FLAG_ONE_SHOT</p><p>当前PendingIntent只能使用一次</p></li><li><p>FLAG_NO_CREATE</p><p>当前PendingIntent不会主动创建，如果不存在，则get方法会直接返回<code>null</code></p></li><li><p>FLAG_CANCEL_CURRENT</p><p>当前描述的PendingIntent如果已存在，那么它们都会被<code>cancel</code></p></li><li><p>FLAG_UPDATE_CURRENT</p><p>当前描述的PendingIntent如果已存在，那么它们都会被更新</p></li></ul></li></ul><h4 id="2-RemoteViews的内部机制"><a href="#2-RemoteViews的内部机制" class="headerlink" title="2.RemoteViews的内部机制"></a>2.RemoteViews的内部机制</h4><ul><li><p>构造方法</p><pre><code class="hljs java"><span class="hljs-comment">/*** <span class="hljs-doctag">@param</span> packageName 当前应用的包名* <span class="hljs-doctag">@param</span> layoutId 待加载的布局文件**/</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RemoteViews</span><span class="hljs-params">(String packageName, <span class="hljs-keyword">int</span> layoutId)</span></span></code></pre><blockquote><p>RemoteViews目前并不支持所有的View类型，支持的所有类型如下</p><p>Layout : FrameLayout, LinearLayout, RelativeLayout, GridLayout</p><p>View : AnalogClock, Button, Chronometer, ImageButton, ImageView, ProgressBar, TextView, ViewFlipper, ListView, GridView, StackView, AdapterViewFlipper, ViewStub</p></blockquote></li><li><p>使用</p><p>RemoteViews没有提供findViewById方法，无法直接访问View元素，必须通过RemoteViews所提供的一系列<code>set</code>方法来完成</p></li><li><p>内部机制</p><ol><li><p>RemoteViews会通过Binder传递到SystemServer进程</p></li><li><p>系统根据RemoteViews中的包名等信息得到该应用的资源，加载RemoteViews中的文件</p></li><li><p>系统对生成的View进行一系列界面更新任务</p><p><img src="https://gitee.com/domeofheaven2017/Image/raw/master/BlogImage/图5-1RemoteViews内部机制.png" srcset="/img/loading.gif" alt></p><blockquote><p>单击事件，RemoteViews中只支持发起PendingIntent,不支持onClickListener.</p><p>setOnClickPendingIntent用于给普通View设置单击事件，但不能给集合(ListView,StackView)中的View设置单击事件</p><p>要给ListView或StackView中的item添加单击事件，必须将setPendingIntentTemplate和setOnClickFillInIntent组合使用</p></blockquote></li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;理解RemoteViews&quot;&gt;&lt;a href=&quot;#理解RemoteViews&quot; class=&quot;headerlink&quot; title=&quot;理解RemoteViews&quot;&gt;&lt;/a&gt;理解RemoteViews&lt;/h3&gt;&lt;h4 id=&quot;1-RemoteViews的应用&quot;&gt;&lt;a 
      
    
    </summary>
    
      <category term="Android开发艺术探索" scheme="http://yoursite.com/categories/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
