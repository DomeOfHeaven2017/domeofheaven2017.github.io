<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DomeOfHeaven</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-06-27T12:10:20.918Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>DomeOfHeaven</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android开发艺术探索学习笔记(第一章)</title>
    <link href="http://yoursite.com/2020/06/27/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E7%AC%AC%E4%B8%80%E7%AB%A0)/"/>
    <id>http://yoursite.com/2020/06/27/Android开发艺术探索学习笔记(第一章)/</id>
    <published>2020-06-27T12:05:17.000Z</published>
    <updated>2020-06-27T12:10:20.918Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Android-开发艺术探索-第一章笔记"><a href="#Android-开发艺术探索-第一章笔记" class="headerlink" title="Android 开发艺术探索 第一章笔记"></a>Android 开发艺术探索 第一章笔记</h3><h4 id="第一章-Activity-的生命周期和启动模式"><a href="#第一章-Activity-的生命周期和启动模式" class="headerlink" title="第一章  Activity 的生命周期和启动模式"></a>第一章  Activity 的生命周期和启动模式</h4><h5 id="Activity-的生命周期"><a href="#Activity-的生命周期" class="headerlink" title="Activity 的生命周期"></a>Activity 的生命周期</h5><ol><li><h5 id="典型情况下的生命周期-在用户参与的情况下，Activity-所经过的生命周期的改变"><a href="#典型情况下的生命周期-在用户参与的情况下，Activity-所经过的生命周期的改变" class="headerlink" title="典型情况下的生命周期 : 在用户参与的情况下，Activity 所经过的生命周期的改变"></a>典型情况下的生命周期 : 在用户参与的情况下，Activity 所经过的生命周期的改变</h5><ol><li>onRestart:Activity 正在重新启动。</li><li>onCreate:Activity 正在被创建。可以在这个方法中进行初始化工作，比如加载界面布局资源，初始化数据等。</li><li>onStart:Activity 正在被启动，此时 Activity 已经<strong>可见</strong>，但是<strong>没有出现在前台</strong>，无法和用户进行交互。</li><li>onResume:Activity 已经可见，且<strong>出现在前台开始活动</strong>。</li><li>onPause:Activity 正在停止。</li><li>onStop:Activity 即将停止，可以做一些回收工作，但不能太耗时。</li><li><p>onDestroy:Activity 即将被销毁，生命周期最后一个回调，可以做一些回收工作和最终资源的释放。</p><p><img src="/assets/img/Android开发艺术探索/图1-1Activity生命周期切换过程.png" srcset="/img/loading.gif" alt="图 1-1Activity 生命周期切换过程"></p></li></ol><blockquote><p>(1) 一个 Activity 第一次启动时的回调为:onCreate-&gt;onStart-&gt;onResume</p><p>(2)打开新的 Activity 或切换到桌面时的回调为:onPause-&gt;onStop(如果新 Activity 采用了透明主题，则不会调用 onStop)</p><p>(3)再次回到原 Activity 时的回调为:onRestart-&gt;onStart-&gt;onResume</p><p>(4)使用 back 键回退时的回调:onPause-&gt;onStop-&gt;onDestroy</p></blockquote></li></ol><h6 id="Remarks-onStart-和-onStop-是从-Activity-是否可见的角度进行回调的-onResume-和-onPause-是从-Activity-是否位于前台的角度。"><a href="#Remarks-onStart-和-onStop-是从-Activity-是否可见的角度进行回调的-onResume-和-onPause-是从-Activity-是否位于前台的角度。" class="headerlink" title="Remarks:onStart 和 onStop 是从 Activity 是否可见的角度进行回调的;onResume 和 onPause 是从 Activity 是否位于前台的角度。"></a>Remarks:onStart 和 onStop 是从 Activity 是否可见的角度进行回调的;onResume 和 onPause 是从 Activity 是否位于前台的角度。</h6><ol start="2"><li><h5 id="异常情况下的生命周期-Activity-被系统回收或者当前设备的-Configuration-发生改变而导致-Activity-被销毁重建"><a href="#异常情况下的生命周期-Activity-被系统回收或者当前设备的-Configuration-发生改变而导致-Activity-被销毁重建" class="headerlink" title="异常情况下的生命周期 : Activity 被系统回收或者当前设备的 Configuration 发生改变而导致 Activity 被销毁重建"></a>异常情况下的生命周期 : Activity 被系统回收或者当前设备的 Configuration 发生改变而导致 Activity 被销毁重建</h5><ol><li>资源相关的系统配置发生改变导致 Activity 被杀死并重新创建</li><li><p>资源内存不足导致低优先级的 Activity 被杀死</p><p>Activity 优先级情况(由高到低)</p><ul><li>前台 Activity ——正在与用户交互的 Activity，优先级最高</li><li>可见但非前台 Activity</li><li>后台 Activity ——已经被暂停的 Activity</li></ul></li></ol></li></ol><h5 id="Activity-的启动模式"><a href="#Activity-的启动模式" class="headerlink" title="Activity 的启动模式"></a>Activity 的启动模式</h5><ol><li><h5 id="Activity-的-LaunchMode"><a href="#Activity-的-LaunchMode" class="headerlink" title="Activity 的 LaunchMode"></a>Activity 的 LaunchMode</h5><ol><li><strong>standard</strong>:标准模式。每次启动一个 Activity 都会重新创建一个新的实例，不管这个实例是否已经存在。<em>在这种模式下，谁启动了这个 Activity，那么这个 Activity 就运行在启动它的那个 Activity 所在的栈中。</em></li><li><strong>singleTop</strong>:栈顶复用模式。在这种模式下，如果新的 Activity 已经位于任务栈的栈顶，那么此 Activity 不会被重新创建，同时它的 onNewIntent 方法会被回调，并且这个 Activity 的 onCreate,onStart 不会被系统调用;如果新 Activity 的实例已存在但不是位于栈顶，那么新 Activity 仍然会重新创建。</li><li><strong>singleTask</strong>:栈内复用模式。这是一种单实例模式，在这种模式下，只要 Activity 在一个栈中存在，那么多次启动此 Activity 都不会重新创建实例。</li><li><p><strong>singleInstance</strong>:单实例模式。除了具有 singleTask 模式的所有特性外，在这种模式下的 Activity 只能单独地位于一个任务栈中。</p><p><em>TaskAffinity:任务相关性。这个参数标识了一个 Activity 所需要的任务栈的名字，默认情况下为应用的包名。TaskAffinity 属性主要和 singleTask 启动模式或者 AllowTaskReparenting 属性配对使用；任务栈分为前台任务栈和后台任务栈，后台任务栈中的 Activity 处于暂停状态。</em></p></li></ol></li><li><h5 id="给-Activity-指定启动模式"><a href="#给-Activity-指定启动模式" class="headerlink" title="给 Activity 指定启动模式"></a>给 Activity 指定启动模式</h5><ol><li><p>通过 <strong>AndroidManifest</strong> 文件给 Activity 指定启动模式</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">activity</span>          <span class="hljs-attr">android:name</span>=<span class="hljs-string">"com.ryg.chapter_1.secondActivity"</span>          <span class="hljs-attr">android:configChanges</span>=<span class="hljs-string">"screenLayout"</span>          <span class="hljs-attr">android:launchMode</span>=<span class="hljs-string">"singleTask"</span>          <span class="hljs-attr">android:label</span>=<span class="hljs-string">"@string/app_name"</span>/&gt;</span></code></pre></li><li><p>通过在 <strong>Intent</strong> 中设置标志位为 Activity 指定启动模式</p><pre><code class="hljs java">Intent intent = <span class="hljs-keyword">new</span> Intent();intent.setClass(MainActivity.<span class="hljs-keyword">this</span>,SecondActivity.class);intent.addFlags(Intetn.FLAG_ACTIVITY_NEW_TASK);startActivity(intent);</code></pre><blockquote><p>两种方式的区别：</p><ol><li>第二种的优先级要高于第一种，当两种同时存在时，以第二种方式为准；</li><li>第一种方式无法直接为 Activity 设定 <strong>FLAG_ACTIVITY_CLEAR_TOP</strong> 标识，而第二种方式无法为 Activity 指定 <strong>singlenstance</strong> 模式</li></ol></blockquote></li></ol></li><li><h5 id="Activity的Flags"><a href="#Activity的Flags" class="headerlink" title="Activity的Flags"></a>Activity的Flags</h5><ul><li>FLAG_ACTIVITY_NEW_TASK:为Activity指定“singleTask”启动模式</li><li>FLAG_ACTIVITY_SINGLE_TOP:为Activity指定“singleTop”启动模式</li><li>FLAG_ACTIVITY_CLEAR_TOP:具有此标记位的Activity启动时，在同一个任务栈中所有位于它上面的Activity都要出栈</li><li>FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS:具有此标记的Activity不会出现在历史Activity的列表中。</li></ul></li><li><h5 id="IntentFilter-的匹配规则"><a href="#IntentFilter-的匹配规则" class="headerlink" title="IntentFilter 的匹配规则"></a>IntentFilter 的匹配规则</h5><ol><li>action(字符串)的匹配规则：<strong>Intent</strong> 中的 action 必须能够和过滤规则中的 action 匹配，即 action 的字符串值完全一样。一个过滤规则中可以有多个 action，只要 <strong>Intent</strong> 中的 action 能够和过滤规则中的任何一个 action 相同即可匹配成功。但如果 <strong>Intent</strong> 中没有指定 action，则匹配失败，并且 action 区分大小写。</li><li>category(字符串)的匹配规则：它要求 <strong>Intent</strong> 中如果含有 category，那么所有的 category 都必须和过滤规则中的其中一个 category 相同。如果 Intent 中没有，仍然可以匹配成功。</li><li><p>data 的匹配规则</p><ol><li><p>结构：由 <em>mimeType</em> 和 <em>URI</em> 两部分组成。其中 <em>mimeType</em> 指的是媒体类型，<em>URI</em> 是资源地址。</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 语法 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">data</span> <span class="hljs-attr">android:scheme</span>=<span class="hljs-string">"string"</span>      <span class="hljs-attr">android:host</span>=<span class="hljs-string">"string"</span>      <span class="hljs-attr">android:port</span>=<span class="hljs-string">"string"</span>      <span class="hljs-attr">android:path</span>=<span class="hljs-string">"string"</span>      <span class="hljs-attr">andrid:pathPattern</span>=<span class="hljs-string">"string"</span>      <span class="hljs-attr">android:pathPrefix</span>=<span class="hljs-string">"string"</span>      <span class="hljs-attr">android:mimeType</span>=<span class="hljs-string">"string"</span> /&gt;</span><span class="hljs-comment">&lt;!-- 结构 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">scheme</span>&gt;</span>://<span class="hljs-tag">&lt;<span class="hljs-name">host</span>&gt;</span>:<span class="hljs-tag">&lt;<span class="hljs-name">port</span>&gt;</span>/[<span class="hljs-tag">&lt;<span class="hljs-name">path</span>&gt;</span>|<span class="hljs-tag">&lt;<span class="hljs-name">pathPrefix</span>&gt;</span>|<span class="hljs-tag">&lt;<span class="hljs-name">pathPattern</span>&gt;</span>]</code></pre></li></ol></li></ol></li></ol><pre><code>2. 匹配规则：Intent中必须含有data数据，并且data数据能够完全匹配过滤规则中的某一个data</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Android-开发艺术探索-第一章笔记&quot;&gt;&lt;a href=&quot;#Android-开发艺术探索-第一章笔记&quot; class=&quot;headerlink&quot; title=&quot;Android 开发艺术探索 第一章笔记&quot;&gt;&lt;/a&gt;Android 开发艺术探索 第一章笔记&lt;/h3&gt;&lt;
      
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Markdown基本语法速查</title>
    <link href="http://yoursite.com/2020/03/27/Markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E9%80%9F%E6%9F%A5/"/>
    <id>http://yoursite.com/2020/03/27/Markdown基本语法速查/</id>
    <published>2020-03-27T13:53:39.000Z</published>
    <updated>2020-06-21T02:29:09.175Z</updated>
    
    <content type="html"><![CDATA[<h4 id="MarkDown基本语法"><a href="#MarkDown基本语法" class="headerlink" title="MarkDown基本语法"></a>MarkDown基本语法</h4><hr><ol><li><p>简介</p><blockquote><p><strong>Markdown</strong>是一种轻量级标记语言，创始人为约翰·格鲁伯（英语：John Gruber）。它允许人们使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML（或者HTML）文档。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。</p><p>由于Markdown的轻量化、易读易写特性，并且对于图片，图表、数学式都有支持，当前许多网站都广泛使用Markdown来撰写帮助文档或是用于论坛上发表消息。如GitHub、Reddit、Diaspora、Stack Exchange、OpenStreetMap 、SourceForge、简书等，甚至还能被使用来撰写电子书。</p><p>​                                                                                                                            —WikiPedia</p></blockquote></li><li><p>基本命令</p><ul><li><p>标题</p><pre><code class="hljs markdown"><span class="hljs-section"># 一级标题</span><span class="hljs-section">## 二级标题</span><span class="hljs-section">### 三级标题</span><span class="hljs-section">#### 四级标题</span><span class="hljs-section">##### 五级标题</span><span class="hljs-section">###### 六级标题</span></code></pre></li><li><p>字体</p></li></ul></li></ol><pre><code>**加粗***斜体*~~删除线~~&lt;u&gt;下划线&lt;/u&gt;`注释`==高亮==</code></pre><ul><li>列表</li></ul><pre><code>## 有序列表1. 2. 3. ## 无序列表- - - ## 任务列表- [ ] 任务1- [ ] 任务2- [x] 任务3 </code></pre><ul><li>引用</li></ul><pre><code>&gt; 这是引用部分内容</code></pre><ul><li>代码块</li></ul><pre><code>​<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123; &#125;​</code></pre></code></pre><ul><li>表格</li></ul><pre><code>| First Header  | Second Header || ------------- | ------------- || Content Cell  | Content Cell  || Content Cell  | Content Cell  |</code></pre><ul><li>目录</li></ul><pre><code>[TOC]</code></pre><ul><li><p>链接</p><ul><li>超链接</li></ul></li></ul><pre><code>  [链接名称](链接地址)- 图片链接  ![图片名称](图片地址)</code></pre><ul><li>脚注</li></ul><pre><code>You can create footnotes like this[^footnote].[^footnote]: Here is the *text* of the **footnote**.</code></pre><ul><li>Emoji表情</li></ul><pre><code>:smile::kissing_smiling_eyes::kissing_smiling_eyes:</code></pre><ul><li>视频</li></ul><pre><code>&lt;video src=&quot;xxx.mp4&quot;</code></pre><ul><li>HTML</li></ul><pre><code>&lt;span style=&quot;color:red&quot;&gt;红色的文本&lt;/span&gt;</code></pre><ol start="3"><li><p>绘制结构图</p><ul><li>流程图</li></ul></li></ol><pre><code>## Flowchart.js​<pre><code class="hljs flow">st=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op    ## Mermaid​&lt;pre class=&quot;mermaid&quot;&gt;     graph LRA[Hard edge] --&gt;B(Round edge)    B --&gt; C&#123;Decision&#125;    C --&gt;|One| D[Result one]    C --&gt;|Two| E[Result two]​&lt;/pre&gt;</code></pre></code></pre><ul><li>时序图</li></ul><pre><code>## js-sequence​<pre><code class="hljs sequence">Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks!​</code></pre>## Mermaid​&lt;pre class=&quot;mermaid&quot;&gt;     %% Example of sequence diagram  sequenceDiagram    Alice-&gt;&gt;Bob: Hello Bob, how are you?    alt is sick    Bob-&gt;&gt;Alice: Not so good :(    else is well    Bob-&gt;&gt;Alice: Feeling fresh like a daisy    end    opt Extra response    Bob-&gt;&gt;Alice: Thanks for asking    end​&lt;/pre&gt;</code></pre><ul><li>甘特图</li></ul><pre><code>## Mermaid​&lt;pre class=&quot;mermaid&quot;&gt;     %% Example with selection of syntaxes        gantt        dateFormat  YYYY-MM-DD        title Adding GANTT diagram functionality to mermaid        section A section        Completed task            :done,    des1, 2014-01-06,2014-01-08        Active task               :active,  des2, 2014-01-09, 3d        Future task               :         des3, after des2, 5d        Future task2               :         des4, after des3, 5d​&lt;/pre&gt;</code></pre><ul><li>类图</li></ul><pre><code>## Mermaid​&lt;pre class=&quot;mermaid&quot;&gt;     classDiagram      Animal &lt;|-- Duck      Animal &lt;|-- Fish      Animal &lt;|-- Zebra      Animal : +int age      Animal : +String gender      Animal: +isMammal()      Animal: +mate()      class Duck{          +String beakColor          +swim()          +quack()      }      class Fish{          -int sizeInFeet          -canEat()      }      class Zebra{          +bool is_wild          +run()      }​&lt;/pre&gt;</code></pre><ul><li>状态图</li></ul><pre><code>​&lt;pre class=&quot;mermaid&quot;&gt;     stateDiagram    [*] --&gt; Still    Still --&gt; [*]    Still --&gt; Moving    Moving --&gt; Still    Moving --&gt; Crash    Crash --&gt; [*]​&lt;/pre&gt;<pre><code class="hljs undefined">   - 饼图     ​&lt;pre class=<span class="hljs-string">"mermaid"</span>&gt;     pie         title Pie Chart         <span class="hljs-string">"Dogs"</span> : <span class="hljs-number">386</span>         <span class="hljs-string">"Cats"</span> : <span class="hljs-number">85</span>         <span class="hljs-string">"Rats"</span> : <span class="hljs-number">150</span>      ​&lt;/pre&gt;<span class="hljs-number">4.</span> 数学公式   ```markdown   ## 行内公式   <span class="hljs-symbol">$</span> a^<span class="hljs-number">2</span> + b^<span class="hljs-number">2</span> = c^<span class="hljs-number">2</span> <span class="hljs-symbol">$</span>   ## 行间公式   <span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>    y = x ^ &#123;<span class="hljs-number">2</span>&#125;    x_&#123;a + b&#125;     x^&#123;a + b&#125;   <span class="hljs-symbol">$</span><span class="hljs-symbol">$</span></code></pre></code></pre><table><thead><tr><th>符号</th><th>代码</th><th>具体含义</th></tr></thead><tbody><tr><td>$\sum$</td><td><code>$\sum$</code></td><td>求和公式</td></tr><tr><td>$\sum_{i=0}^n$</td><td><code>$\sum_{i=0}^n$</code></td><td>求和上下标</td></tr><tr><td>$\times$</td><td><code>$\times$</code></td><td>乘号</td></tr><tr><td>$\pm$</td><td><code>$\pm$</code></td><td>正负号</td></tr><tr><td>$\div$</td><td><code>$\div$</code></td><td>除号</td></tr><tr><td>$\mid$</td><td><code>$\mid$</code></td><td>竖线</td></tr><tr><td>$\cdot$</td><td><code>$\cdot$</code></td><td>点</td></tr><tr><td>$\circ$</td><td><code>$\circ$</code></td><td>圈</td></tr><tr><td>$\ast $</td><td><code>$\ast $</code></td><td>星号</td></tr><tr><td>$\bigotimes$</td><td><code>$\bigotimes$</code></td><td>克罗内克积</td></tr><tr><td>$\bigoplus$</td><td><code>$\bigoplus$</code></td><td>异或</td></tr><tr><td>$\leq$</td><td><code>$\leq$</code></td><td>小于等于</td></tr><tr><td>$\geq$</td><td><code>$\geq$</code></td><td>大于等于</td></tr><tr><td>$\neq$</td><td><code>$\neq$</code></td><td>不等于</td></tr><tr><td>$\approx$</td><td><code>$\approx$</code></td><td>约等于</td></tr><tr><td>$\prod$</td><td><code>$\prod$</code></td><td>N元乘积</td></tr><tr><td>$\coprod$</td><td><code>$\coprod$</code></td><td>N元余积</td></tr><tr><td>$\cdots$</td><td><code>$\cdots$</code></td><td>省略号</td></tr><tr><td>$\int$</td><td><code>$\int$</code></td><td>积分</td></tr><tr><td>$\iint$</td><td><code>$\iint$</code></td><td>双重积分</td></tr><tr><td>$\oint$</td><td><code>$\oint$</code></td><td>曲线积分</td></tr><tr><td>$\infty$</td><td><code>$\infty$</code></td><td>无穷</td></tr><tr><td>$\nabla$</td><td><code>$\nabla$</code></td><td>梯度</td></tr><tr><td>$\because$</td><td><code>$\because$</code></td><td>因为</td></tr><tr><td>$\therefore$</td><td><code>$\therefore$</code></td><td>所以</td></tr><tr><td>$\forall$</td><td><code>$\forall$</code></td><td>任意</td></tr><tr><td>$\exists$</td><td><code>$\exists$</code></td><td>存在</td></tr><tr><td>$\not=$</td><td><code>$\not=$</code></td><td>不等于</td></tr><tr><td>$\not&gt;$</td><td><code>$\not&gt;$</code></td><td>不大于</td></tr><tr><td>$\leq$</td><td><code>$\leq$</code></td><td>小于等于</td></tr><tr><td>$\geq$</td><td><code>$\geq$</code></td><td>大于等于</td></tr><tr><td>$\not\subset$</td><td><code>$\not\subset$</code></td><td>不属于</td></tr><tr><td>$\emptyset$</td><td><code>$\emptyset$</code></td><td>空集</td></tr><tr><td>$\in$</td><td><code>$\in$</code></td><td>属于</td></tr><tr><td>$\notin$</td><td><code>$\notin$</code></td><td>不属于</td></tr><tr><td>$\subset$</td><td><code>$\subset$</code></td><td>子集</td></tr><tr><td>$\subseteq$</td><td><code>$\subseteq$</code></td><td>真子集</td></tr><tr><td>$\bigcup$</td><td><code>$\bigcup$</code></td><td>并集</td></tr><tr><td>$\bigcap$</td><td><code>$\bigcap$</code></td><td>交集</td></tr><tr><td>$\bigvee$</td><td><code>$\bigvee$</code></td><td>逻辑或</td></tr><tr><td>$\bigwedge$</td><td><code>$\bigwedge$</code></td><td>逻辑与</td></tr><tr><td>$\alpha$</td><td><code>$\alpha$</code></td><td></td></tr><tr><td>$\beta$</td><td><code>$\beta$</code></td><td></td></tr><tr><td>$\gamma$</td><td><code>$\gamma$</code></td><td></td></tr><tr><td>$\Gamma$</td><td><code>$\Gamma$</code></td><td></td></tr><tr><td>$\delta$</td><td><code>$\delta$</code></td><td></td></tr><tr><td>$\Delta$</td><td><code>$\Delta$</code></td><td></td></tr><tr><td>$\epsilon$</td><td><code>$\epsilon$</code></td><td></td></tr><tr><td>$\varepsilon$</td><td><code>$\varepsilon$</code></td><td></td></tr><tr><td>$\zeta$</td><td><code>$\zeta$</code></td><td></td></tr><tr><td>$\eta$</td><td><code>$\eta$</code></td><td></td></tr><tr><td>$\theta$</td><td><code>$\theta$</code></td><td></td></tr><tr><td>$\Theta$</td><td><code>$\Theta$</code></td><td></td></tr><tr><td><em>ϑ</em></td><td><code>$\vartheta$</code></td><td></td></tr><tr><td><em>ι</em></td><td><code>$\iota$</code></td><td></td></tr><tr><td><em>π</em></td><td><code>$\pi$</code></td><td></td></tr><tr><td><em>ϕ</em></td><td><code>$\phi$</code></td><td></td></tr><tr><td>Φ</td><td><code>$\Phi$</code></td><td></td></tr><tr><td><em>ψ</em></td><td><code>$\psi$</code></td><td></td></tr><tr><td>Ψ</td><td><code>$\Psi$</code></td><td></td></tr><tr><td><em>ω</em></td><td><code>$\omega$</code></td><td></td></tr><tr><td>Ω</td><td><code>$\Omega$</code></td><td></td></tr><tr><td><em>χ</em></td><td><code>\chi</code></td><td></td></tr><tr><td><em>ρ</em></td><td><code>$\rho$</code></td><td></td></tr><tr><td><em>ο</em></td><td><code>$\omicron$</code></td><td></td></tr><tr><td><em>σ</em></td><td><code>$\sigma$</code></td><td></td></tr><tr><td>Σ</td><td><code>$\Sigma$</code></td><td></td></tr><tr><td><em>ν</em></td><td><code>$\nu$</code></td><td></td></tr><tr><td><em>ξ</em></td><td><code>$\xi$</code></td><td></td></tr><tr><td><em>τ</em></td><td><code>$\tau$</code></td><td></td></tr><tr><td><em>λ</em></td><td><code>$\lambda$</code></td><td></td></tr><tr><td>Λ</td><td><code>$\Lambda$</code></td><td></td></tr><tr><td><em>μ</em></td><td><code>\mu</code></td><td></td></tr><tr><td>∂</td><td><code>$\partial$</code></td><td></td></tr><tr><td>{}</td><td><code>$\lbrace \rbrace$</code></td><td></td></tr><tr><td><em>a</em></td><td><code>$\overline{a}$</code></td></tr></tbody></table><p>​     </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;MarkDown基本语法&quot;&gt;&lt;a href=&quot;#MarkDown基本语法&quot; class=&quot;headerlink&quot; title=&quot;MarkDown基本语法&quot;&gt;&lt;/a&gt;MarkDown基本语法&lt;/h4&gt;&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;简介&lt;/p&gt;
&lt;blockquo
      
    
    </summary>
    
    
      <category term="Markdown" scheme="http://yoursite.com/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>ProtocolBuffers-基本使用</title>
    <link href="http://yoursite.com/2020/03/12/ProtocolBuffers-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/03/12/ProtocolBuffers-基本使用/</id>
    <published>2020-03-12T13:11:49.000Z</published>
    <updated>2020-03-14T13:55:55.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Protocol-Buffers"><a href="#Protocol-Buffers" class="headerlink" title="Protocol Buffers"></a>Protocol Buffers</h4><p>​    <em>一种跨语言，跨平台的可扩展的序列化数据格式</em></p><ol><li><p>相比XML的优势</p><ul><li>更简单</li><li>更轻量（数据体积小3~10倍）</li><li>更快速（20～100倍）</li><li>自动化生成更易于编码方式使用的数据访问类</li></ul></li><li><p>使用方法</p><pre class="mermaid">   graph TD;   A[定义protobuf消息格式]　--> B[编译protobuf];   B --> C[使用protobuf API进行读写];</pre><ol><li><p>使用protobuf语法描述需要存储的数据结构（编写．proto文件）</p><pre><code class="hljs protobuf">syntax = <span class="hljs-string">"proto3"</span>; <span class="hljs-comment">//默认为proto2,不能为空</span><span class="hljs-keyword">package</span> tutorial;　<span class="hljs-comment">//避免命名冲突</span><span class="hljs-keyword">option</span> java_package = <span class="hljs-string">"com.example.tutorial"</span>;　<span class="hljs-comment">//生成类的包结构</span><span class="hljs-keyword">option</span> java_outer_classname = <span class="hljs-string">"AddressBookProtos"</span>;　<span class="hljs-comment">//生成包括当前文件所有类的类名，默认是MyProto,生成my_proto.proto，不能与内部定义的类名称相同（不能设为AddressBook）</span><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">Person</span> </span>&#123;   <span class="hljs-built_in">string</span> name = <span class="hljs-number">1</span>;　<span class="hljs-comment">//用于二进制编码的唯一标识</span>   <span class="hljs-built_in">int32</span> id = <span class="hljs-number">2</span>;   <span class="hljs-built_in">string</span> email = <span class="hljs-number">3</span>;  <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">PhoneType</span> </span>&#123;    MOBILE = <span class="hljs-number">0</span>;　<span class="hljs-comment">//必须包含标识０，用于设置默认值和与proto2语义兼容</span>    HOME = <span class="hljs-number">1</span>;    WORK = <span class="hljs-number">2</span>;  &#125;  <span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">PhoneNumber</span> </span>&#123;     <span class="hljs-built_in">string</span> number = <span class="hljs-number">1</span>;     PhoneType type = <span class="hljs-number">2</span> [packed = HOME];  &#125;   PhoneNumber phones = <span class="hljs-number">4</span>;&#125;<span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">AddressBook</span> </span>&#123;   Person people = <span class="hljs-number">1</span>;&#125;</code></pre><blockquote><p>基本语法（proto3）：</p><ol><li><p>消息是各种类型数据的集合，</p></li><li><p>可以包含<code>bool</code>,<code>int32</code>,<code>float</code>,<code>double</code>,<code>string</code>,枚举或者其他的消息</p></li><li><p>标识的范围为1 ~ 2^29^ - 1,1~15的标识比较高的数字少一个字节进行编码，适宜一些常用或者重复的字段;16以上的适用不太常使用的可选字段;19000 ~ 19999不可使用，为内置保留．</p></li><li><p>每个字段都必须标明注解：</p><ol><li><code>required</code>:该字段必须设置值，否则该消息将被视为“未初始化”,构建未初始化的消息将抛出RuntimeException,解析未初始化的消息将抛出IOException;除此之外与<code>optional</code>一致</li><li><code>optional</code>:该字段是可选字段，可以设置值也可以不设置值。如果不设置值，则使用默认值．</li><li><code>repeated</code>:该字段可以重复任意次数（包括零），重复值的顺序将保留在<strong>protobuf</strong>中。可将其视为动态大小的数组．</li></ol></li><li><p>Any字段：</p><pre><code class="hljs protobuf">&gt;    import "google/protobuf/any.proto";&gt;    &gt;    message ErrorStatus &#123;&gt;      string message = 1;&gt;      google.protobuf.Any details = 2;&gt;    &#125;&gt;</code></pre></li></ol></blockquote><blockquote><ol start="6"><li><p>Oneof字段：</p></li><li><p>一个.proto文件中可以定义多种消息</p></li><li><p>每个message类以及它的子类有自己的<code>builder</code>类 ，通过<code>builder</code>类来进行设置</p></li><li><p>数据类型</p></li><li><p>不能在proto3中直接导入proto2的枚举进行使用，要导入其消息．</p></li><li><p>Map类型</p><pre><code class="hljs protobuf">&gt;     map&lt;key_type, value_type&gt; map_field = N;&gt;     map&lt;<span class="hljs-built_in">string</span>, Project&gt; projects = <span class="hljs-number">3</span>;&gt;</code></pre></li></ol></blockquote><blockquote><pre><code>1. `key_type` 可以是任何 int 或者 string 类型(任何的标量类型，具体可以见上面标量类型对应表格，但是要除去 float、double 和 bytes)2. `value_type` 可以是除去 map 以外的任何类型。</code></pre><ol start="12"><li><p>定义service</p><p>如果要使用 RPC（远程过程调用）系统的消息类型，可以在 <code>.proto</code> 文件中定义 RPC 服务接口，protocol buffer 编译器将使用所选语言生成服务接口代码和 stubs</p><pre><code class="hljs protobuf">&gt;     <span class="hljs-comment">//参数为SearchRequest,返回值为SearchResponse</span>&gt;     <span class="hljs-class"><span class="hljs-keyword">service</span> <span class="hljs-title">SearchService</span> </span>&#123;&gt;       <span class="hljs-function"><span class="hljs-keyword">rpc</span> Search (SearchRequest) <span class="hljs-keyword">returns</span> (SearchResponse)</span>;&gt;     &#125;&gt;</code></pre></li></ol></blockquote><blockquote><ol start="13"><li>JSON Map</li></ol><p>如果一个值在json编码的数据中丢失或者它的值是null, 在被解析成protocol buffer时它将设置为对应的默认值.如果一个字段的值正好是protocol buffer的默认值, 这个字段默认就不会出现在json编码的数据中以便节约空间.</p></blockquote></li><li><p>通过protobuf编译器编译．proto文件（生成对应平台的文件）</p><ul><li>使用命令</li></ul><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#命令格式</span></span>protoc [option] PROTO_FILES<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#Java</span></span>protoc -I=$SRC_DIR --java_out=$DST_DIR $SRC_DIR/addressbook.proto<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#Python</span></span>protoc -I=$SRC_DIR --python_out=$DST_DIR $SRC_DIR/addressbook.proto</code></pre><blockquote><ul><li><p>SRC_DIR:源代码路径，默认为当前文件夹</p></li><li><p>DST_DIR:生成的代码路径，默认与SRC_DIR相同</p></li><li><p>–Java_out:生成不同语言对应的文件</p></li><li><p>对于Android使用Java Lite可以减小生成类的体积</p><p>1.安装java_lite环境</p><p>2.编译java_lite版文件</p><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">   protoc --javalite_out=<span class="hljs-variable">$DST_DIR</span> PROTO_FILES</span><span class="hljs-meta">&gt;</span><span class="bash"></span></code></pre></li></ul></blockquote><ul><li><p>使用Android Studio</p><ol><li>安装Protocol Support插件</li><li>配置gradle</li><li>编写．proto文件</li><li>编译项目</li></ol><p><img src="https://img2.tuicool.com/AnMFRbi.jpg!web" srcset="/img/loading.gif" alt="img"></p></li></ul></li><li><p>使用protobuf进行数据读写</p><p> 除了访问器，生成的类中还有其它的方法：</p><p> 消息构建接口</p><ul><li><code>isInitialized()</code>:检测 所有<code>required</code>的字段是否有被设置</li><li><code>toString()</code>: 生成可读的字符串</li><li><code>mergeFrom(Message other)</code>: (builder only)与另一个消息进行合并</li><li><p><code>clear()</code>: (builder only) 将所有字段清除为空状态</p><p>解析接口</p></li><li><code>byte[] toByteArray();</code>: 序列化数据</li><li><code>static Person parseFrom(byte[] data);</code>: 反序列化数据</li><li><code>void writeTo(OutputStream output);</code>: 序列化数据并写入<code>OutputStream</code></li><li><code>static Person parseFrom(InputStream input);</code>: 从<code>InputStream</code>中解析读取消息</li></ul><ol start="4"><li>具体Demo</li></ol></li><li><p>兼容处理</p><p>如果要让新版本向后兼容，旧版本向前兼容，需要遵守以下规则</p><ol><li>不能修改已存在字段的标识（tag）</li><li>不能添加或删除<code>required</code>字段</li><li>可以删除<code>optional</code>或<code>repeated</code>字段</li><li>可以增加<code>optional</code>或<code>repeated</code>字段，但必须使用没有用过的标识，已经删除的也不能用</li></ol></li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Protocol-Buffers&quot;&gt;&lt;a href=&quot;#Protocol-Buffers&quot; class=&quot;headerlink&quot; title=&quot;Protocol Buffers&quot;&gt;&lt;/a&gt;Protocol Buffers&lt;/h4&gt;&lt;p&gt;​    &lt;em&gt;一种跨语言
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据编码" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Hexo基本命令</title>
    <link href="http://yoursite.com/2020/03/10/Hexo%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2020/03/10/Hexo基本命令/</id>
    <published>2020-03-10T13:13:49.000Z</published>
    <updated>2020-03-12T13:02:40.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="init"><a href="#init" class="headerlink" title="init"></a>init</h4><pre><code class="hljs undefined">hexo init <span class="hljs-string">[folder]</span></code></pre><blockquote><p>新建一个网站</p></blockquote><h4 id="hexo-new"><a href="#hexo-new" class="headerlink" title="hexo new"></a>hexo new</h4><pre><code class="hljs undefined">hexo <span class="hljs-keyword">new</span> [layout] &lt;<span class="hljs-built_in">title</span>&gt;</code></pre><blockquote><ul><li>新建一个title.md文档</li></ul></blockquote><h4 id="hexo-generate-hexo-g"><a href="#hexo-generate-hexo-g" class="headerlink" title="hexo generate(hexo g)"></a>hexo generate(hexo g)</h4><table><thead><tr><th style="text-align:left">选项</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">-d, –deploy</td><td style="text-align:left">文件生成后立即部署网站</td></tr><tr><td style="text-align:left">-w, –watch</td><td style="text-align:left">监视文件变动</td></tr><tr><td style="text-align:left">-b, –bail</td><td style="text-align:left">生成过程中如果发生任何未处理的异常则抛出异常</td></tr><tr><td style="text-align:left">-f, –force</td><td style="text-align:left">强制重新生成文件 Hexo 引入了差分机制，如果 <code>public</code> 目录存在，那么 <code>hexo g</code> 只会重新生成改动的文件。 使用该参数的效果接近 <code>hexo clean &amp;&amp; hexo generate</code></td></tr><tr><td style="text-align:left">-c, –concurrency</td><td style="text-align:left">最大同时生成文件的数量，默认无限制</td></tr></tbody></table><blockquote><p>生成网站静态文件到默认设置的 public 文件夹</p></blockquote><h4 id="publish"><a href="#publish" class="headerlink" title="publish"></a>publish</h4><pre><code class="hljs undefined">hexo publish <span class="hljs-string">[layout]</span> &lt;fileName&gt;</code></pre><blockquote><p>发表草稿</p></blockquote><h4 id="hexo-server-hexo-s"><a href="#hexo-server-hexo-s" class="headerlink" title="hexo server(hexo s)"></a>hexo server(hexo s)</h4><blockquote><p>启动服务器，默认网址为<code>http://localhost:4000/</code></p></blockquote><table><thead><tr><th style="text-align:left">项</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">-p, –port</td><td style="text-align:left">重设端口</td></tr><tr><td style="text-align:left">-s, –static</td><td style="text-align:left">只使用静态文件</td></tr><tr><td style="text-align:left">-l, –log</td><td style="text-align:left">启动日记记录，使用覆盖记录格式</td></tr></tbody></table><h4 id="hexo-deploy-hexo-d"><a href="#hexo-deploy-hexo-d" class="headerlink" title="hexo deploy(hexo d)"></a>hexo deploy(hexo d)</h4><blockquote><p>部署网站到服务器</p></blockquote><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">-g, –generate</td><td style="text-align:left">部署之前预先生成静态文件</td></tr></tbody></table><h4 id="hexo-clean"><a href="#hexo-clean" class="headerlink" title="hexo clean"></a>hexo clean</h4><blockquote><p>清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;init&quot;&gt;&lt;a href=&quot;#init&quot; class=&quot;headerlink&quot; title=&quot;init&quot;&gt;&lt;/a&gt;init&lt;/h4&gt;&lt;pre&gt;&lt;code class=&quot;hljs undefined&quot;&gt;hexo init &lt;span class=&quot;hljs-str
      
    
    </summary>
    
      <category term="Hexo" scheme="http://yoursite.com/categories/Hexo/"/>
    
    
      <category term="博客" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
</feed>
