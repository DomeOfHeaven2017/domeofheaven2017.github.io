<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DomeOfHeaven</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-08-16T03:21:37.554Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>DomeOfHeaven</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Kotlin基础</title>
    <link href="http://yoursite.com/2020/08/16/Kotlin%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2020/08/16/Kotlin基础/</id>
    <published>2020-08-16T02:59:44.000Z</published>
    <updated>2020-08-16T03:21:37.554Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Kotlin基础知识"><a href="#Kotlin基础知识" class="headerlink" title="Kotlin基础知识"></a>Kotlin基础知识</h3><ol><li><h5 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h5><ol><li><p>函数的基本构成</p><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> 函数名称 <span class="hljs-params">(参数列表)</span></span>: 返回类型 &#123;  函数体&#125;<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">max</span><span class="hljs-params">(a:<span class="hljs-type">Int</span>,b:<span class="hljs-type">Int</span>)</span></span>:<span class="hljs-built_in">Int</span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span>(a&gt;b) a <span class="hljs-keyword">else</span> b&#125;</code></pre></li><li><p>表达式和语句</p><p>表达式：有值，并且能作为另一个表达式的一部分使用</p><p>语   句：总是包含着它的代码块中的顶层元素，并且没有自己的值</p><blockquote><p>在Java中所有的控制结构都是语句；</p><p>在Kotlin中除了循环(for,do和do/while)以外大多数控制结构都是表达式</p></blockquote></li><li><p>省略返回值类型</p><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">max</span> <span class="hljs-params">( a:<span class="hljs-type">Int</span>,b:<span class="hljs-type">Int</span>)</span></span> = <span class="hljs-keyword">if</span>(a&gt;b) a <span class="hljs-keyword">else</span> b</code></pre><blockquote><p>如果函数体写在花括号中，则这个函数有代码块体，如果直接返回一个表达式，则它有表达式体</p></blockquote></li></ol></li><li><h5 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h5><ul><li><p>如果指定了初始化器，那么在不指定类型的情况下，编译器会分析初始化器表达式的值，并把它的类型作为变量的类型，</p><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>:<span class="hljs-built_in">Int</span>=&#123;  <span class="hljs-keyword">val</span> xValue = <span class="hljs-number">2.5</span>  <span class="hljs-keyword">val</span> yValue = <span class="hljs-number">3</span>  <span class="hljs-keyword">return</span> xValue + yValue&#125;</code></pre></li><li><p>如果没有指定初始化器，需要显示地指定它的类型，因为此时编译器无法推断出它的类型。</p><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;  <span class="hljs-keyword">val</span> eValue : <span class="hljs-built_in">Int</span>  println(<span class="hljs-string">"eValue = <span class="hljs-variable">$eValue</span>"</span>)&#125;</code></pre></li></ul><ol><li><p>可变变量和不可变变量</p><ul><li><p>Val(Value)-不可变引用：使用该关键字声明的变量不能在初始化后再次赋值．</p><ol><li><p>对应<strong>JAVA</strong>中的final变量</p></li><li><p>如果编译器确保只有唯一一条语句会被执行，可以根据条件使用不同的值来初始化</p><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> message:String<span class="hljs-keyword">if</span>(canPerformOperation())&#123;    message = <span class="hljs-string">"Success"</span>&#125;<span class="hljs-keyword">else</span>&#123;    message = <span class="hljs-string">"Failed"</span>&#125;</code></pre></li><li><p>虽然val引用自身不可变，但指向的对象是可变的</p><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> language = arrayListOf(<span class="hljs-string">"Java"</span>)language.add(<span class="hljs-string">"Kotlin"</span>)</code></pre></li></ol></li><li><p>Var(Variable)-可变引用：该关键字声明的变量的值可以改变．</p><ol><li>对应<strong>JAVA</strong>中的普通变量</li><li>var变量的类型是不可变的,编译器只会根据初始化器来推断变量的类型，如果需要则必须<strong>手动转换</strong>或者<strong>强制转换</strong></li></ol></li></ul></li></ol></li><li><h5 id="字符串模板"><a href="#字符串模板" class="headerlink" title="字符串模板"></a>字符串模板</h5><p>声明一个变量后，在变量名称前添加字符<code>$</code>,就可以在字符串字面值中引用该变量．</p><ol><li><p>打印字符串变量</p><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args:<span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span>&#123;    <span class="hljs-keyword">val</span> name = <span class="hljs-string">"Kotlin"</span>    printlin(<span class="hljs-string">"Hello,<span class="hljs-variable">$name</span>!"</span>)&#125;</code></pre></li><li><p>复杂表达式</p><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args:<span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span>&#123;    <span class="hljs-keyword">if</span>(args.size &gt; <span class="hljs-number">0</span>)&#123;        println(<span class="hljs-string">"Hello,<span class="hljs-subst">$&#123;args[<span class="hljs-number">0</span>]!&#125;</span>"</span>)    &#125;&#125;</code></pre></li><li><p>双引号嵌套</p><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args:<span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span>&#123;    println(<span class="hljs-string">"Hello,<span class="hljs-subst">$&#123;if(args.size &gt; <span class="hljs-number">0</span> args[<span class="hljs-number">0</span>] else "Kotln")&#125;</span>"</span>)&#125;</code></pre></li></ol></li><li><h5 id="类和属性"><a href="#类和属性" class="headerlink" title="类和属性"></a>类和属性</h5><pre><code class="hljs java"><span class="hljs-comment">//Java中的类</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;    <span class="hljs-keyword">private</span> String mName;        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span></span>&#123;        mName = name;    &#125;        <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> mName;    &#125;&#125;</code></pre><blockquote><p>字段和其访问器的组合为属性</p></blockquote><pre><code class="hljs kotlin"><span class="hljs-comment">//Kotlin中的类</span><span class="hljs-comment">//Kotlin中属性默认为public</span>Class Person(<span class="hljs-keyword">val</span> name:String)</code></pre><ol><li>Kotlin中属性默认为<strong>public</strong></li><li>声明属性时默认生成访问器，只读属性只生成<strong>getter</strong>,可写属性生成<strong>getter</strong>和<strong>setter</strong><pre><code class="hljs kotlin"><span class="hljs-comment">//自定义访问器</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span></span>(<span class="hljs-keyword">val</span> height:<span class="hljs-built_in">Int</span>,<span class="hljs-keyword">val</span> width:<span class="hljs-built_in">Int</span>)&#123;    <span class="hljs-keyword">val</span> isSquare:<span class="hljs-built_in">Boolean</span>    <span class="hljs-keyword">get</span>()&#123;        <span class="hljs-keyword">return</span> height == width    &#125;&#125;</code></pre></li></ol></li><li><h5 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h5><pre><code class="hljs kotlin"><span class="hljs-comment">//声明枚举类</span><span class="hljs-keyword">enum</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Color</span></span>&#123;    RED,ORANGE,YELLOW,GREEN,BLUE,INDIGO,VIOLET&#125;</code></pre><p>Kotlin中，<em>enum</em>是<strong>软关键字</strong>,在class前面才有特殊意义，其他地方只是普通名称</p><p>和Java一样，枚举不是值的列表，可以给枚举类声明属性和方法</p><pre><code class="hljs kotlin"><span class="hljs-keyword">enum</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Color</span> </span>( <span class="hljs-keyword">val</span> r : <span class="hljs-built_in">Int</span>, <span class="hljs-keyword">val</span> g : <span class="hljs-built_in">Int</span>, <span class="hljs-keyword">val</span> b : <span class="hljs-built_in">Int</span>  <span class="hljs-comment">//声明常量属性</span>) &#123;    RED(<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), ORANGE(<span class="hljs-number">255</span>, <span class="hljs-number">165</span>, <span class="hljs-number">0</span>);  <span class="hljs-comment">//必须添加分号结束</span>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">rgb</span><span class="hljs-params">()</span></span> = (r * <span class="hljs-number">256</span> + g) * <span class="hljs-number">256</span> + b  <span class="hljs-comment">//定义方法</span>&#125;</code></pre><blockquote><p>如果要在枚举类中定义任何方法，就要使用<strong>分号</strong>把枚举常量列表和方法定义分开。</p></blockquote></li><li><h5 id="When表达式"><a href="#When表达式" class="headerlink" title="When表达式"></a><strong>When</strong>表达式</h5><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getWarmth</span><span class="hljs-params">(color:<span class="hljs-type">Color</span>)</span></span> = <span class="hljs-keyword">when</span>(color)&#123;    Color.RED,Color.ORANGE,Color.YELLOW -&gt; <span class="hljs-string">"warm"</span>    Color.GREEN -&gt; <span class="hljs-string">"neutral"</span>    Color.BLUE,Color.INDIGO,Color.VIOLET -&gt; <span class="hljs-string">"cold"</span>&#125;</code></pre><blockquote><p><code>when</code>表达式的实参可以是任何对象</p></blockquote><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">mix</span><span class="hljs-params">(c1:<span class="hljs-type">Color</span>,c2:<span class="hljs-type">Color</span>)</span></span> = <span class="hljs-keyword">when</span>(setOf(c1,c2))&#123;    setOf(Color.RED,Color.YELLOW) -&gt; Color.ORANGE    setOf(Color.YELLOW,Color.BLUE) -&gt; Color.GREEN    setOf(Color.BLUE,Color.VIOLET) -&gt; Color.INDIGO    <span class="hljs-keyword">else</span> -&gt; <span class="hljs-keyword">throw</span> Exception(<span class="hljs-string">"Dirty Color"</span>)&#125;</code></pre><p>计算<code>(1+2)+4</code></p><pre><code class="hljs kotlin"><span class="hljs-comment">//类结构</span><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Expr</span></span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Num</span></span>(<span class="hljs-keyword">val</span> value:<span class="hljs-built_in">Int</span>) : Expr<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sum</span></span>(<span class="hljs-keyword">val</span> left:Expr,<span class="hljs-keyword">val</span> right:Expr) : Expr</code></pre><pre class="mermaid">   graph TB;A[Sum] --> B[Sum]A[Sum] --> C["Num(4)"]B[Sum] --> D["Num(1)"]B[Sum] --> E["Num(2)"]</pre><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">eval</span><span class="hljs-params">(e:<span class="hljs-type">Expr</span>)</span></span> : <span class="hljs-built_in">Int</span> = <span class="hljs-keyword">when</span>(e)&#123;    <span class="hljs-keyword">is</span> Num -&gt; e.value    <span class="hljs-keyword">is</span> Sum -&gt; eval(e.right)+eval(e.left)    <span class="hljs-keyword">else</span> -&gt; <span class="hljs-keyword">throw</span> IllegalArgumentException(<span class="hljs-string">"Unknown expression"</span>)&#125;</code></pre></li><li><p><strong>While</strong>循环</p><ol><li><p><code>while</code>循环</p><pre><code class="hljs kotlin"><span class="hljs-comment">//当codition为true时执行循环</span><span class="hljs-keyword">while</span>(codition)&#123;    <span class="hljs-comment">//循环体</span>&#125;</code></pre></li><li><p><code>do-while</code>循环</p><pre><code class="hljs kotlin"><span class="hljs-comment">//循环体第一次无条件执行，此后，当codition为true时才执行</span><span class="hljs-keyword">do</span>&#123;    <span class="hljs-comment">//循环体</span>&#125; <span class="hljs-keyword">while</span>(codition)</code></pre></li></ol></li><li><p><strong>for</strong>循环</p><p>kotlin使用<strong>区间</strong>的概念：［起始值．．结束值］</p><pre><code class="hljs kotlin"><span class="hljs-keyword">for</span>(i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span> until <span class="hljs-number">100</span> step <span class="hljs-number">2</span>)&#123;    &#125;<span class="hljs-keyword">for</span>(i <span class="hljs-keyword">in</span> <span class="hljs-number">100</span> downTo <span class="hljs-number">1</span> step <span class="hljs-number">2</span>)&#123;&#125;</code></pre></li><li><p>迭代<strong>map</strong></p><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> binaryReps = TreeMap&lt;<span class="hljs-built_in">Char</span>,String&gt;()<span class="hljs-keyword">for</span>(c <span class="hljs-keyword">in</span> <span class="hljs-string">'A'</span>..<span class="hljs-string">'F'</span>)&#123;    <span class="hljs-keyword">val</span> binary = Integer.toBinaryString(c.toInt())    binaryReps[c] = binary&#125;<span class="hljs-keyword">for</span>((letter,binary) <span class="hljs-keyword">in</span> binaryReps)&#123;    println(<span class="hljs-string">"<span class="hljs-variable">$letter</span> = <span class="hljs-variable">$binary</span>"</span>)&#125;</code></pre></li><li><p>Ktolin中的异常</p><ol><li><p>捕获异常</p><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">readNumber</span><span class="hljs-params">(reader:<span class="hljs-type">BufferedReader</span>)</span></span> : <span class="hljs-built_in">Int</span>?&#123;    <span class="hljs-keyword">try</span>&#123;        <span class="hljs-keyword">val</span> line = reader.readLine()        <span class="hljs-keyword">return</span> Interger.parseInt(line)    &#125;<span class="hljs-keyword">catch</span>(e:NumberFormatException)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>    &#125;<span class="hljs-keyword">finally</span>&#123;        reader.close()    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">readNumber</span><span class="hljs-params">(reader:<span class="hljs-type">BufferedReader</span>)</span></span>&#123;    <span class="hljs-keyword">val</span> number = <span class="hljs-keyword">try</span>&#123;        Integer.parseInt(reader.readLine())    &#125;<span class="hljs-keyword">catch</span>(e:NumberFormatException)&#123;        <span class="hljs-literal">null</span>    &#125;    println(number)&#125;</code></pre><blockquote><p><strong>try</strong>结构也可以作为表达式</p></blockquote></li><li><p>抛出异常</p><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> percentage = <span class="hljs-keyword">if</span>(number <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">100</span>)&#123;    number&#125;<span class="hljs-keyword">else</span>&#123;    <span class="hljs-keyword">throw</span> IllegalArgumentException(<span class="hljs-string">"...."</span>)&#125;</code></pre><blockquote><p>与<em>Java</em>中不同的是，<em>kotlin</em>中<strong>throw</strong>结构是一个表达式．</p></blockquote></li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Kotlin基础知识&quot;&gt;&lt;a href=&quot;#Kotlin基础知识&quot; class=&quot;headerlink&quot; title=&quot;Kotlin基础知识&quot;&gt;&lt;/a&gt;Kotlin基础知识&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;h5 id=&quot;函数&quot;&gt;&lt;a href=&quot;#函数&quot; class=
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法-二叉树</title>
    <link href="http://yoursite.com/2020/08/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2020/08/09/数据结构与算法-二叉树/</id>
    <published>2020-08-09T14:50:42.000Z</published>
    <updated>2020-08-09T15:02:31.078Z</updated>
    
    <content type="html"><![CDATA[<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><hr><h4 id="一-定义"><a href="#一-定义" class="headerlink" title="一. 定义"></a>一. 定义</h4><p>每个节点最多只有两个分支（即不存在分支度大于 2 的节点）的树结构。左子树和右子树是有顺序的，不能任意颠倒。</p><h4 id="二-性质"><a href="#二-性质" class="headerlink" title="二. 性质"></a>二. 性质</h4><ol><li>非空的二叉树，若树叶总数为<code>n0</code>,分支度为<code>n2</code>,则$n0 = n2 + 1$</li></ol><h4 id="三-类型"><a href="#三-类型" class="headerlink" title="三. 类型"></a>三. 类型</h4><pre class="mermaid">graph LRD[二叉树] --> G[完全二叉树]D --> H[平衡二叉树]D --> I[排序二叉树]G --> J[满二叉树]</pre><ul><li><p>满二叉树(Full Binary Tree)：一棵深度为<code>k</code>，且有<strong>2^k^ - 1</strong>个节点的二叉树。</p></li><li><p>完全二叉树(Complete Tree)：除最后一层外，如其余层都是满的，并且最后一层是满的或者是在右边缺少连续若干节点的二叉树</p><blockquote><p>具有<code>n</code>个节点的完全二叉树的深度为$\log_2{n} + 1$</p><p>深度为<code>k</code>的完全二叉树，至少有<strong>2^k-1^</strong>个节点，至多有<strong>2^k^ -1</strong>个节点</p></blockquote></li><li><p>平衡二叉树</p></li><li><p>排序二叉树</p></li></ul><h4 id="四-存储结构"><a href="#四-存储结构" class="headerlink" title="四. 存储结构"></a>四. 存储结构</h4><ul><li><p>顺序存储表示</p><p>二叉树可以用数组或链接串列来存储，若是满二叉树就能紧凑排列而不浪费空间。如果某个节点的索引为<em>i</em>，（假设根节点的索引为0）则在它左子节点的索引会是$2i + 1$，以及右子节点会是$2i + 2$；而它的父节点（如果有）索引则为$ \lfloor \frac{i-1}{2} \rfloor$这种方法更有利于紧凑存储和更好的访问的局部性，特别是在前序遍历中。然而，它需要连续的存储空间，这样在存储高度为<em>h</em>的<em>n</em>个节点所组成的一般树时，将浪费很多空间。在最糟糕的情况下，如果深度为<em>h</em>的二叉树其每个节点都只有右孩子，则该存储结构需要占用<strong>2^h^ - 1</strong>的空间，实际上却有h个节点，浪费了不少空间，是顺序存储结构的一大缺点。</p></li><li><p>链表存储表示</p><p>二叉树通常用树结点结构来存储。有时也包含指向唯一的父节点的指针。如果一个结点的子结点个数小于2，一些子结点指针可能为空值，或者为特殊的哨兵结点。 使用链表能避免顺序存储浪费空间的问题，算法和结构相对简单，但使用二叉链表，由于缺乏父链的指引，在找回父节点时需要重新扫描树得知父节点的节点地址。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> val;    <span class="hljs-keyword">public</span> TreeNode left;    <span class="hljs-keyword">public</span> TreeNode right;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TreeNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;        val = x;    &#125;&#125;</code></pre></li></ul><h4 id="五-遍历方法"><a href="#五-遍历方法" class="headerlink" title="五. 遍历方法"></a>五. 遍历方法</h4><ul><li><p>前序遍历：先访问根节点，再访问根的左节点和右节点</p><pre><code class="hljs java"><span class="hljs-comment">//递归方式</span><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    treeNodeTraversal(list, root);    <span class="hljs-keyword">return</span> list;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">treeNodeTraversal</span><span class="hljs-params">(List&lt;Integer&gt; list, TreeNode root)</span></span>&#123;    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span>;    &#125;;    <span class="hljs-comment">//访问根节点</span>    list.add(root.val);    <span class="hljs-comment">//遍历左子树</span>    treeNodeTraversal(list, root.left, <span class="hljs-number">0</span>);    <span class="hljs-comment">//遍历右子树</span>    treeNodeTraversal(list, root.right, <span class="hljs-number">0</span>);&#125;<span class="hljs-comment">//迭代方式</span><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> list;    &#125;    Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();    <span class="hljs-comment">//将根节点压入栈中</span>    stack.push(root);    <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;        TreeNode node = stack.pop();        <span class="hljs-comment">//访问根节点</span>        list.add(node.val);        <span class="hljs-comment">//由于栈是先入后出，所以右子节点先入栈，左子节点后入栈</span>        <span class="hljs-keyword">if</span> (node.right != <span class="hljs-keyword">null</span>) &#123;            stack.push(node.right);        &#125;        <span class="hljs-keyword">if</span> (node.left != <span class="hljs-keyword">null</span>) &#123;            stack.push(node.left);        &#125;    &#125;    <span class="hljs-keyword">return</span> list;&#125;</code></pre></li><li><p>中序遍历：先遍历左子节点，再遍历根节点，最后遍历右子节点</p><pre><code class="hljs java"><span class="hljs-comment">//递归方式</span><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    treeNodeTraversal(list, root);    <span class="hljs-keyword">return</span> list;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">treeNodeTraversal</span><span class="hljs-params">(List&lt;Integer&gt; list, TreeNode root)</span></span>&#123;    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span>;    &#125;;    <span class="hljs-comment">//先遍历左子节点</span>    treeNodeTraversal(list, root.left, <span class="hljs-number">0</span>);    <span class="hljs-comment">//访问</span>    list.add(root.val);    treeNodeTraversal(list, root.right, <span class="hljs-number">0</span>);&#125;<span class="hljs-comment">//非递归方式</span><span class="hljs-comment">//先将左节点全部入栈，遍历到叶子节点后一层层向上遍历根节点和右节点</span><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> list;    &#125;    Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();    TreeNode node = root;    <span class="hljs-comment">//判断条件 1. 栈为空，即遍历完毕或开始遍历；</span>    <span class="hljs-comment">//  2. node不为空则开始遍历</span>    <span class="hljs-keyword">while</span> (!stack.isEmpty() || node != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">if</span> (node != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">//将左节点入栈</span>            stack.push(node);            node = node.left;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">//左节点不存在，则访问该节点，再遍历右节点</span>            node = stack.pop();            list.add(node.val);            node = node.right;        &#125;    &#125;    <span class="hljs-keyword">return</span> list;&#125;</code></pre></li><li><p>后序遍历：先遍历左子节点，再遍历右子节点，最后遍历根节点</p><pre><code class="hljs java"><span class="hljs-comment">//递归方式</span><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    treeNodeTraversal(list, root);    <span class="hljs-keyword">return</span> list;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">treeNodeTraversal</span><span class="hljs-params">(List&lt;Integer&gt; list, TreeNode root)</span></span>&#123;    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span>;    &#125;;    <span class="hljs-comment">//遍历左子树</span>    treeNodeTraversal(list, root.left, <span class="hljs-number">0</span>);    <span class="hljs-comment">//遍历右子树</span>    treeNodeTraversal(list, root.right, <span class="hljs-number">0</span>);    <span class="hljs-comment">//访问根节点</span>    list.add(root.val);&#125;<span class="hljs-comment">//非递归方式</span><span class="hljs-comment">//前序遍历结果为“根左右”，如果修改遍历次序则为“根右左”，在进行倒序则为后序遍历“左右根”</span><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> list;    &#125;    <span class="hljs-comment">//遍历栈,遍历树节点</span>    Stack&lt;TreeNode&gt;  stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();    <span class="hljs-comment">//记录“根右左”遍历的值</span>    Stack&lt;Integer&gt; temp = <span class="hljs-keyword">new</span> Stack&lt;&gt;();    stack.push(root);    <span class="hljs-comment">//根据前序遍历修改遍历次序，使结果输出"根右左"</span>    <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;        TreeNode node = stack.pop();        temp.push(node.val);        <span class="hljs-keyword">if</span> (node.left != <span class="hljs-keyword">null</span>) &#123;            stack.push(node.left);        &#125;        <span class="hljs-keyword">if</span> (node.right != <span class="hljs-keyword">null</span>) &#123;            stack.push(node.right);        &#125;    &#125;    <span class="hljs-comment">//将“根右左”的结果倒序输出为"左右根"</span>    <span class="hljs-keyword">while</span> (!temp.isEmpty()) &#123;        list.add(temp.pop());    &#125;    <span class="hljs-keyword">return</span> list;&#125;</code></pre></li><li><p>层次遍历：每一层按照从左到右的顺序打印节点</p><pre><code class="hljs java"><span class="hljs-comment">//非递归方式</span><span class="hljs-comment">//使用一个队列，依次将节点子节点入队列，再依次出队列即可</span><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;    List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();  <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> result;    &#125;    <span class="hljs-comment">//遍历队列</span>    Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();    <span class="hljs-comment">//先将根节点入队列</span>    queue.add(root);    <span class="hljs-keyword">while</span> ( !queue.isEmpty()) &#123;        <span class="hljs-comment">//每层的数据放在一个数组中</span>        List&lt;Integer&gt; temp = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-comment">//当前队列里元素的数量就是当前层数的总节点数量</span>        <span class="hljs-keyword">int</span> size = queue.size();        <span class="hljs-comment">//使用一个循环遍历当前层数所有的节点</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; size ; i ++) &#123;            TreeNode node = queue.poll();            <span class="hljs-keyword">if</span> (node !=<span class="hljs-keyword">null</span>) &#123;                <span class="hljs-comment">//访问当前节点，并将其子节点入队列</span>                temp.add(node.val);                <span class="hljs-keyword">if</span> (node.left != <span class="hljs-keyword">null</span>) &#123;                    queue.add(node.left);                &#125;                <span class="hljs-keyword">if</span> (node.right != <span class="hljs-keyword">null</span>) &#123;                    queue.add(node.right);                &#125;            &#125;        &#125;        <span class="hljs-comment">//一层遍历完成，将数据添加到结果中</span>        result.add(temp);    &#125;    <span class="hljs-keyword">return</span> result;&#125;<span class="hljs-comment">//递归方式</span><span class="hljs-comment">//增加level表示层级，根据节点的层级，将节点的数据添加到想要数组中</span><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;    List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> result;    &#125;    <span class="hljs-comment">//加入根节点，开始递归遍历</span>    levelOrderDfs(<span class="hljs-number">1</span>, root, result);    <span class="hljs-keyword">return</span> result;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">levelOrderDfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> level, TreeNode node, List&lt;List&lt;Integer&gt;&gt; lists)</span> </span>&#123;    <span class="hljs-comment">//当前层级无相应数组时，添加一个空数组</span>    <span class="hljs-keyword">if</span> (lists.size() &lt; level) &#123;        lists.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;());    &#125;    <span class="hljs-comment">//访问节点值，并将其添加到对应层级的数组里</span>    lists.get(level - <span class="hljs-number">1</span>).add(node.val);    <span class="hljs-comment">//层级递增，遍历下一层，递归遍历左子节点和右子节点</span>    <span class="hljs-keyword">if</span> (node.left != <span class="hljs-keyword">null</span>) &#123;        levelOrderDfs(level + <span class="hljs-number">1</span>, node.left, lists);    &#125;    <span class="hljs-keyword">if</span> (node.right != <span class="hljs-keyword">null</span>) &#123;        levelOrderDfs(level + <span class="hljs-number">1</span>, node.right, lists);    &#125;&#125;</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;二叉树&quot;&gt;&lt;a href=&quot;#二叉树&quot; class=&quot;headerlink&quot; title=&quot;二叉树&quot;&gt;&lt;/a&gt;二叉树&lt;/h3&gt;&lt;hr&gt;
&lt;h4 id=&quot;一-定义&quot;&gt;&lt;a href=&quot;#一-定义&quot; class=&quot;headerlink&quot; title=&quot;一. 定义&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="树" scheme="http://yoursite.com/categories/%E6%A0%91/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法-树</title>
    <link href="http://yoursite.com/2020/08/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%A0%91/"/>
    <id>http://yoursite.com/2020/08/09/数据结构与算法-树/</id>
    <published>2020-08-09T14:50:08.000Z</published>
    <updated>2020-08-09T15:01:46.990Z</updated>
    
    <content type="html"><![CDATA[<h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><hr><h4 id="一-定义"><a href="#一-定义" class="headerlink" title="一. 定义"></a>一. 定义</h4><p>树是一种 <code>抽象数据类型(ADT)</code> 或是实现这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由 n 个有限节点组成的一个具有层次关系的集合。</p><blockquote><p>抽象数据类型(<strong>A</strong>bstract <strong>D</strong>ata <strong>T</strong>ype，<strong>ADT</strong>),是计算机科学中具有类似行为的特定类别的数据结构的数学模型</p></blockquote><h4 id="二-特点"><a href="#二-特点" class="headerlink" title="二. 特点"></a>二. 特点</h4><ul><li>每个节点只有有限个子节点或无子节点</li><li>没有父节点的节点称为根节点</li><li>每一个非根节点有且只有一个父节点</li><li>树里面没有环路</li></ul><h4 id="三-术语"><a href="#三-术语" class="headerlink" title="三. 术语"></a>三. 术语</h4><ol><li><strong>节点的度</strong>：一个节点含有的子树的个数称为该节点的度</li><li><strong>树的度</strong>：一棵树中，最大的节点度称为树的度</li><li><strong>叶节点</strong>或<strong>终端节点</strong>：度为零的节点</li><li><strong>非终端节点</strong>或<strong>分支节点</strong>：度不为零的节点</li><li><strong>父亲节点</strong>或<strong>父节点</strong>：若一个节点含有子节点，则这个节点称为其子节点的父节点</li><li><strong>孩子节点</strong>或<strong>子节点</strong>：一个节点含有的子树的根节点称为该节点的子节点</li><li><strong>兄弟节点</strong>：具有相同父节点的节点互称为兄弟节点</li><li>节点的<strong>层次</strong>：从根开始定义起，根为第 1 层，根的子节点为第 2 层，以此类推</li><li><strong>深度</strong>：对于任意节点 n,n 的深度为从根到 n 的唯一路径长，根的深度为 0</li><li><strong>高度</strong>：对于任意节点 n,n 的高度为从 n 到一片树叶的最长路径长，所有树叶的高度为 0</li><li><strong>堂兄弟节点</strong>：父节点在同一层的节点互为堂兄弟</li><li><strong>节点的祖先</strong>：从根到该节点所经分支上的所有节点</li><li><strong>子孙</strong>：以某节点为根的子树中任一节点都称为该节点的子孙</li><li><strong>森林</strong>：由 m（m&gt;=0）棵互不相交的树的集合称为森林</li></ol><h4 id="四-树的分类"><a href="#四-树的分类" class="headerlink" title="四. 树的分类"></a>四. 树的分类</h4><pre class="mermaid">graph LRA[树] --> B[无序树]A --> C[有序树]C --> D[二叉树]C --> E[霍夫曼树]C --> F[B树]D --> G[完全二叉树]D --> H[平衡二叉树]D --> I[排序二叉树]G --> J[满二叉树]</pre><ul><li>无序树：树中任意节点的子节点之间没有顺序关系</li><li>有序树：树中任意节点的子节点之间有顺序关系<ol><li>二叉树：每个节点最多含有两个子树的树</li><li>霍夫曼树：带权路径最短的二叉树称为哈夫曼树或最优二叉树</li><li>B 树：一种对读写操作进行优化的自平衡的二叉查找树，能够保持数据有序，拥有多于两个子树</li></ol></li></ul><h4 id="五-树的遍历"><a href="#五-树的遍历" class="headerlink" title="五. 树的遍历"></a>五. 树的遍历</h4><pre class="mermaid">graph LRa[树的遍历] --> bb[深度优先遍历] --> c[前序遍历]b --> e[中序遍历]b --> f[后序遍历]a --> d[广度优先遍历]</pre><ul><li><p>深度优先遍历：先访问子节点，再访问父节点，最后是第二个子节点</p><ol><li><p>前序遍历：先访问根，然后访问子树的遍历方式<br><img src="https://gitee.com/domeofheaven2017/Image/raw/master/BlogImage/Sorted_binary_tree_preorder.svg" srcset="/img/loading.gif" alt></p><p>前序遍历：<strong>F, B, A, D, C, E, G, I, H</strong>.</p></li><li><p>中序遍历：先访问左（右）子树，然后访问根，最后访问右（左）子树的遍历方式<br><img src="https://gitee.com/domeofheaven2017/Image/raw/master/BlogImage/Sorted_binary_tree_inorder.svg" srcset="/img/loading.gif" alt></p><p>中序遍历：<strong>A, B, C, D, E, F, G, H, I</strong>.</p></li><li><p>后序遍历:先访问子树，然后访问根的遍历方式</p><p><img src="https://gitee.com/domeofheaven2017/Image/raw/master/BlogImage/Sorted_binary_tree_postorder.svg" srcset="/img/loading.gif" alt></p><p>后序遍历：<strong>A, C, E, D, B, H, I, G, F</strong>.</p></li></ol></li><li>广度优先遍历<br><img src="https://gitee.com/domeofheaven2017/Image/raw/master/BlogImage/Sorted_binary_tree_breadth-first_traversal.svg" srcset="/img/loading.gif" alt><br>层次遍历：<strong>F, B, G, A, D, I, C, E, H</strong>.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;树&quot;&gt;&lt;a href=&quot;#树&quot; class=&quot;headerlink&quot; title=&quot;树&quot;&gt;&lt;/a&gt;树&lt;/h3&gt;&lt;hr&gt;
&lt;h4 id=&quot;一-定义&quot;&gt;&lt;a href=&quot;#一-定义&quot; class=&quot;headerlink&quot; title=&quot;一. 定义&quot;&gt;&lt;/a&gt;一. 定义
      
    
    </summary>
    
      <category term="树" scheme="http://yoursite.com/categories/%E6%A0%91/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Android开发艺术探索-Android中的线程和线程池</title>
    <link href="http://yoursite.com/2020/08/04/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-Android%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://yoursite.com/2020/08/04/Android开发艺术探索-Android中的线程和线程池/</id>
    <published>2020-08-04T13:29:14.000Z</published>
    <updated>2020-08-16T03:09:11.065Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Android中的线程和线程池"><a href="#Android中的线程和线程池" class="headerlink" title="Android中的线程和线程池"></a>Android中的线程和线程池</h3><hr><p>在操作系统中，线程是调度的最小单元，同时线程不能无限制的产生，线程的创建和销毁都需要开销，通过线程池可以避免因为频繁创建和销毁线程而导致的开销。</p><h6 id="一-主线程和子线程"><a href="#一-主线程和子线程" class="headerlink" title="一. 主线程和子线程"></a>一. 主线程和子线程</h6><ul><li><p>主线程:指<strong>进程</strong>所拥有的线程,主要处理和界面相关的事情,也称<code>UI线程</code>.</p><blockquote><p>为了避免界面卡顿,主线程中不能执行耗时的任务,会引起ANR</p></blockquote></li><li><p>子线程:也称<code>工作线程</code>,除主线程以外的线程都是子线程.主要执行耗时任务，如网络请求，I/O操作等</p></li></ul><h6 id="二-Android中的线程形态"><a href="#二-Android中的线程形态" class="headerlink" title="二. Android中的线程形态"></a>二. Android中的线程形态</h6><ul><li><p>AsyncTask</p><p>内部封装了<code>Thread</code>和<code>Handler</code>,在线程池中执行后台任务,把执行进度和结果返回给主线程.</p><blockquote><p>AsyncTask不适合执行特别耗时的后台任务</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncTask</span>&lt;<span class="hljs-title">Params</span>,<span class="hljs-title">Progress</span>,<span class="hljs-title">Result</span>&gt;</span>&#123;    <span class="hljs-comment">//AsyncTask参数</span>    <span class="hljs-comment">//Params:表示参数的类型</span>    <span class="hljs-comment">//Progress:后台任务的执行进度的类型</span>    <span class="hljs-comment">//Result:任务的返回结果的类型</span>    <span class="hljs-comment">/**    * 在主线程中执行,异步任务执行&#123;#doInBackground&#125;之前会被调用    **/</span>    <span class="hljs-meta">@MainThread</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onPreExecute</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-comment">/**    * 用于执行异步任务,在此方法中可以通过publishProgress方法更新进度    **/</span>    <span class="hljs-meta">@WorkerThread</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> Result <span class="hljs-title">doInBackground</span><span class="hljs-params">(Params... params)</span></span>;    <span class="hljs-comment">/**    * 在主线程中执行,用于更新任务进度    **/</span>    <span class="hljs-meta">@MainThread</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onProgressUpdate</span><span class="hljs-params">(Progress... values)</span> </span>&#123;    &#125;    <span class="hljs-comment">/**    * 在主线程中执行,在异步任务执行之后调用,用于返回结果    **/</span>    <span class="hljs-meta">@MainThread</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onPostExecute</span><span class="hljs-params">(Result result)</span> </span>&#123;    &#125;    <span class="hljs-comment">/**    * 执行在主线程,异步任务取消时调用,默认实现中直接调用了onCancelled()方法,所以    * 忽略了结果值,注意在覆写时不要使用super.onCancelled(result)    **/</span>    <span class="hljs-meta">@MainThread</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCancelled</span><span class="hljs-params">(Result result)</span> </span>&#123;        onCancelled();    &#125;   &#125;</code></pre><p>AsyncTask使用限制：</p><ol><li>AsyncTask的类必须在主线程加载</li><li>AsyncTask的对象必须在主线程创建</li><li>execute方法必须在UI线程调用</li><li>不要在程序中直接调用onPreExecute, onPostExecute, doInBackground, onProgressUpdate</li><li>一个AsyncTask对象只能执行一次，即只能调用一次execute方法</li></ol><p>工作原理:</p><pre class="mermaid">  graph TBA["excute(Params... params)"] --> B["executeOnExecutor(sDefaultExecutor,param)"]B --> C["SERIAL_EXECUTOR#execute(Runnable r)"]C --> D["SERIAL_EXECUTOR#scheduleNext()"]D --> E["THREAD_POOL_EXECUTOR#execute(Runnable r)"]</pre><blockquote><p>AsyncTask中有两个线程池(SERIAL_EXECUTOR,THREAD_POOL_EXECUTOR)和一个线程Handler(InternalHandler)</p><p>SERIAL_EXECUTOR:内部实现的<code>SerialExecutor</code>,用于任务的排队,接收到传递过来的<strong>FutureTask</strong>对象后将其插入到任务队列中,如果此时没有任务在执行则调用<em>scheduleNext</em>方法执行下一个任务.可以看出AsyncTask是<strong>串行执行</strong>的</p><p>THREAD_POOL_EXECUTOR:用于执行任务</p><p>InternalHandler:用于子线程切换到主线程</p></blockquote></li><li><p>HandlerThread</p><p>HandlerThread继承自Thread,其内部构建了一个消息处理循环</p><ul><li><p>用法</p><pre><code class="hljs java"><span class="hljs-comment">//创建HandlerThread实例</span>HandlerThread mMsgThread = <span class="hljs-keyword">new</span> HandlerThread(<span class="hljs-string">"msg-handler"</span>);<span class="hljs-comment">//启动</span>mMsgThread.start();<span class="hljs-comment">//关联Handler处理消息</span>Handler mMsgHandler = <span class="hljs-keyword">new</span> Handler(mMsgThread.getLooper())&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(Message msg)</span></span>&#123;        <span class="hljs-comment">//消息处理</span>    &#125;&#125;</code></pre></li></ul></li><li><p>IntentService</p><p>IntentService是继承了<em>Service</em>的一个<strong>抽象类</strong>.可用于执行后台耗时的任务,<strong>当任务执行完成后自动停止</strong>.</p><p>工作原理:</p><pre><code class="hljs java"><span class="hljs-comment">//onCreate</span><span class="hljs-comment">//创建一个HandlerThread,并通过其再创建mServiceHandler</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">super</span>.onCreate();    HandlerThread thread = <span class="hljs-keyword">new</span> HandlerThread(<span class="hljs-string">"IntentService["</span> + mName + <span class="hljs-string">"]"</span>);    thread.start();    mServiceLooper = thread.getLooper();    mServiceHandler = <span class="hljs-keyword">new</span> ServiceHandler(mServiceLooper);&#125;<span class="hljs-comment">//onStart中通过mServiceHandler发送消息,然后在ServiceHandler中调用onHandleIntent</span><span class="hljs-comment">//方法处理消息,并随后调用Service#stopSelt(startId)停止服务</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServiceHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Handler</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ServiceHandler</span><span class="hljs-params">(Looper looper)</span> </span>&#123;        <span class="hljs-keyword">super</span>(looper);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(Message msg)</span> </span>&#123;        onHandleIntent((Intent)msg.obj);        stopSelf(msg.arg1);    &#125;&#125;</code></pre><blockquote><ul><li>Service中的<code>stopSelf()</code>和<code>stopSelf(int startId)</code>都能停止服务,但<code>stopSelf()</code>会立刻停止服务,而<code>stopSelf(int startId)</code>会等待所有消息都处理完成后停止服务.</li><li><code>onHandleIntent</code>方法需要在子类中实现,根据Intent参数区分不同的任务并执行.</li><li><code>onHandleIntent</code>中的任务是排队执行的,执行顺序为发起请求的顺序.</li></ul></blockquote></li></ul><h6 id="三-Android中的线程池"><a href="#三-Android中的线程池" class="headerlink" title="三. Android中的线程池"></a>三. Android中的线程池</h6><ul><li><p>线程池的优点</p><ol><li>线程复用,避免线程重复创建和销毁带来的开销</li><li>有效控制线程池的最大并发数,避免大量的线程之间因资源抢占而阻塞</li><li>统一管理线程</li></ol></li><li><p>ThreadPoolExecutor</p><pre><code class="hljs java"><span class="hljs-comment">//构造方法</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize,                          <span class="hljs-keyword">int</span> maximumPoolSize,                          <span class="hljs-keyword">long</span> keepAliveTime,                          TimeUnit unit,                          BlockingQueue&lt;Runnable&gt; workQueue,                          ThreadFactory threadFactory,                          RejectedExecutionHandler handler)</span></span></code></pre><ol><li><p>构造参数</p><ul><li><p>corePoolSize:线程池的核心线程数,默认会一直存活.</p></li><li><p>maximumPoolSize:线程池能容纳的<strong>最大线程数</strong>,达到这个数值后,后续任务会被<strong>阻塞</strong></p></li><li><p>keepAliveTime:<strong>非核心线程</strong>闲置时的超时时长,超过这个时间后会被回收.</p><blockquote><p>如果设置<code>allowCoreThreadTimeOut</code>为<strong>True</strong>,可作用于核心线程</p></blockquote></li><li><p>unit:<code>keepAliveTime</code>参数时间单位</p></li><li><p>workQueue:线程池中的任务队列,通过线程池的<code>execute</code>方法提交的<em>Runnable</em>对象会存储在该参数中</p></li><li><p>threadFactory:线程工厂,为线程池提供创建新线程的功能</p></li><li><p>handler:当线程池无法执行新任务时,<code>ThreadPoolExecutor</code>会调用该handler的<strong>rejectedExecution</strong>方法,默认直接抛出<code>RejectedExecutionException</code></p></li></ul></li><li><p>执行规则</p><ul><li>如果线程池中的线程数未达到核心线程数,则直接启动核心线程执行任务</li><li>如果线程数量大于或等于核心线程数,任务会被插入到任务队列中排队等待</li><li>如果线程数量大于或等于核心线程数且任务队列也已满,此时如果线程数量未达到线程能容纳的最大值,则立刻启动一个非核心线程执行任务;如果达到了最大值则拒绝执行任务调用<code>rejectedExecution</code>方法</li></ul></li><li><p>线程池的分类</p><ul><li><p>FixedThreadPool</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nThreads)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,                                  <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,                                  <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;                                  ());&#125;</code></pre><p>通过<code>Executors</code>的<code>newFixedThreadPool</code>方法创建.一种线程数量固定的线程池,只有核心线程,没有超时机制和任务队列大小限制.</p></li><li><p>CachedThreadPool</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newCachedThreadPool</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">0</span>, Integer.MAX_VALUE,                                  <span class="hljs-number">60L</span>, TimeUnit.SECONDS,                                  <span class="hljs-keyword">new</span> SynchronousQueue&lt;Runnable&gt;());&#125;</code></pre><p>通过<code>Executors</code>的<code>newCachedThreadPool</code>方法来创建.一种线程数量不定的线程池,只有非核心线程,且最大线程数为<em>Interger.MAX_VALUE</em>.线程池中的空闲线程都有超时机制,超时时间为60s</p></li><li><p>ScheduledThreadPool</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ScheduledExecutorService <span class="hljs-title">newScheduledThreadPool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ScheduledThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize)</span> </span>&#123;    <span class="hljs-keyword">super</span>(corePoolSize, Integer.MAX_VALUE,          DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,          <span class="hljs-keyword">new</span> DelayedWorkQueue());&#125;</code></pre><p>通过<code>Executors</code>的<code>newSingleThreadScheduledExecutor</code>创建.核心线程数固定,非核心线程数最大为<em>Interger.MAX_VALUE</em>,非核心线程闲置时会被回收.用于执行定时任务和具有固定周期的重复任务.</p></li><li><p>SingleThreadExecutor</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newSingleThreadExecutor</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FinalizableDelegatedExecutorService        (<span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,                                <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,                                <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));&#125;</code></pre><p>通过<code>Executors</code>的<code>newSingleThreadExecutor</code>方法创建.线程池中只有一个核心线程,确保所有的任务都在同一个线程中按顺序执行.</p></li></ul></li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Android中的线程和线程池&quot;&gt;&lt;a href=&quot;#Android中的线程和线程池&quot; class=&quot;headerlink&quot; title=&quot;Android中的线程和线程池&quot;&gt;&lt;/a&gt;Android中的线程和线程池&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;在操作系统中，线程是调度的
      
    
    </summary>
    
      <category term="Android开发艺术探索" scheme="http://yoursite.com/categories/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Android开发艺术探索-Android的消息机制</title>
    <link href="http://yoursite.com/2020/08/03/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-Android%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2020/08/03/Android开发艺术探索-Android的消息机制/</id>
    <published>2020-08-03T14:49:27.000Z</published>
    <updated>2020-08-16T03:08:47.812Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Android的消息机制"><a href="#Android的消息机制" class="headerlink" title="Android的消息机制"></a>Android的消息机制</h3><hr><ol><li><h4 id="Android的消息机制概述"><a href="#Android的消息机制概述" class="headerlink" title="Android的消息机制概述"></a>Android的消息机制概述</h4><p>Android的消息机制主要指<strong>Handler</strong>的运行机制以及<strong>Handler</strong>所附带的<strong>MessageQueue</strong>和<strong>Looper</strong>的工作过程，Handler的主要作用是将一个任务切换到某个指定的线程中去执行。Handler创建时会采用当前线程的Looper来构建内部的消息循环系统，如果没有Looper会报错。线程中默认是没有Looper的，主线程（UI线程，即ActivityThread）被创建时会初始化Looper，所以主线程默认可以使用Handler</p><p><img src="https://gitee.com/domeofheaven2017/Image/raw/master/BlogImage/图10-1Handler的工作过程.png" srcset="/img/loading.gif" alt="图10-1Handler的工作过程"></p></li><li><h4 id="Android的消息机制分析"><a href="#Android的消息机制分析" class="headerlink" title="Android的消息机制分析"></a>Android的消息机制分析</h4><ul><li><p>ThreadLocal的工作原理</p><p>ThreadLocal:是一个线程内部的数据存储类，可以通过它在指定的线程存储和获取数据（其他线程无法获取）</p><pre><code class="hljs java"><span class="hljs-comment">//定义</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLocal</span>&lt;<span class="hljs-title">T</span>&gt;//<span class="hljs-title">set</span>方法<span class="hljs-title">public</span> <span class="hljs-title">void</span> <span class="hljs-title">set</span>(<span class="hljs-title">T</span> <span class="hljs-title">value</span>) </span>&#123;        Thread t = Thread.currentThread();        ThreadLocalMap map = getMap(t);        <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>)            map.set(<span class="hljs-keyword">this</span>, value);        <span class="hljs-keyword">else</span>            createMap(t, value);  &#125;  <span class="hljs-comment">//get方法</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;        Thread t = Thread.currentThread();        ThreadLocalMap map = getMap(t);        <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>) &#123;            ThreadLocalMap.Entry e = map.getEntry(<span class="hljs-keyword">this</span>);            <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)                T result = (T)e.value;                <span class="hljs-keyword">return</span> result;            &#125;        &#125;        <span class="hljs-keyword">return</span> setInitialValue();    &#125;</code></pre></li></ul></li></ol><ul><li><p>消息队列的工作原理</p><p>MessageQueue主要包含两个操作：<strong>插入</strong>和<strong>读取</strong>，对应<em>enqueueMessage</em>和<em>next</em>，MessageQueue是通过一个单链表的数据结构来维护消息列表的，不是队列。</p><blockquote><p>enqueueMessage方法的主要操作是单链表的插入操作</p><p>next方法的主要操作是构建一个无限循环，有消息时返回这条消息并移除；无消息时则进行阻塞。</p></blockquote></li><li><p>Looper的工作原理</p><p>Looper是消息循环，会不停的查看MessageQueue中是否有新消息，有则立即处理；无则进行阻塞。</p><p>重要方法：</p><p><code>prepare</code> : 为当前线程创建一个Looper</p><p><code>prepareMainLooper</code> : ActivityThread创建Looper使用</p><p><code>getMainLooper</code> : 获取主线程的Looper</p><p><code>quit</code> : 直接退出Looper</p><p><code>quitSafely</code> : 设定退出标记，在把消息队列中已有消息处理完后安全退出</p><p><code>loop</code> : 调用MessageQueue的next方法来获取新消息</p></li><li><p>Handler的工作原理</p><p><strong>Handler</strong>的工作主要包含消息的发送和接收过程。</p><p>发送消息的过程为向消息队列中插入一条消息，随后<strong>MessageQueue</strong>返回消息给<strong>Looper</strong>，<strong>Looper</strong>在交由<strong>Handler</strong>处理，即调用<strong>Handler</strong>的<em>dispatchMessage</em>方法</p><p><img src="https://gitee.com/domeofheaven2017/Image/raw/master/BlogImage/图10-2Handler消息处理流程.png" srcset="/img/loading.gif" alt="image-20200803223746136"></p></li></ul><ol start="3"><li><h4 id="主线程的消息循环"><a href="#主线程的消息循环" class="headerlink" title="主线程的消息循环"></a>主线程的消息循环</h4><p>主线程即ActivityThread,其入口方法为main，在main方法中通过Looper.prepareMainLooper来创建主线程的Looper以及MessageQueue，并通过Looper.loop方法来开启主线程的消息循环</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="hljs-string">"ActivityThreadMain"</span>);       <span class="hljs-comment">// Install selective syscall interception</span>    AndroidOs.install();       <span class="hljs-comment">// CloseGuard defaults to true and can be quite spammy.  We</span>    <span class="hljs-comment">// disable it here, but selectively enable it later (via</span>    <span class="hljs-comment">// StrictMode) on debug builds, but using DropBox, not logs.</span>    CloseGuard.setEnabled(<span class="hljs-keyword">false</span>);       Environment.initForCurrentUser();       <span class="hljs-comment">// Make sure TrustedCertificateStore looks in the right place for CA certificates</span>    <span class="hljs-keyword">final</span> File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());    TrustedCertificateStore.setDefaultUserDirectory(configDir);       Process.setArgV0(<span class="hljs-string">"&lt;pre-initialized&gt;"</span>);       Looper.prepareMainLooper();       <span class="hljs-comment">// Find the value for &#123;@link #PROC_START_SEQ_IDENT&#125; if provided on the command line.</span>    <span class="hljs-comment">// It will be in the format "seq=114"</span>    <span class="hljs-keyword">long</span> startSeq = <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span> (args != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = args.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;            <span class="hljs-keyword">if</span> (args[i] != <span class="hljs-keyword">null</span> &amp;&amp; args[i].startsWith(PROC_START_SEQ_IDENT)) &#123;                startSeq = Long.parseLong(                        args[i].substring(PROC_START_SEQ_IDENT.length()));            &#125;        &#125;    &#125;    ActivityThread thread = <span class="hljs-keyword">new</span> ActivityThread();    thread.attach(<span class="hljs-keyword">false</span>, startSeq);       <span class="hljs-keyword">if</span> (sMainThreadHandler == <span class="hljs-keyword">null</span>) &#123;        sMainThreadHandler = thread.getHandler();    &#125;       <span class="hljs-keyword">if</span> (<span class="hljs-keyword">false</span>) &#123;        Looper.myLooper().setMessageLogging(<span class="hljs-keyword">new</span>                LogPrinter(Log.DEBUG, <span class="hljs-string">"ActivityThread"</span>));    &#125;       <span class="hljs-comment">// End of event ActivityThreadMain.</span>    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);    Looper.loop();       <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"Main thread loop unexpectedly exited"</span>);&#125;</code></pre><p>ActivityThread通过ActivityThread.H来和消息队列进行交互。具体流程为：ActivityThread通过ApplicationThread和ActivityManagerService进行进程间通信，AMS以进程间通信的方式完成ActivityTread的请求后会回调ApplicationThread中的Binder方法，然后ApplicationThread会向H发送消息，H收到消息后将ApplicationThread中的逻辑切换到ActivityThread中去执行，即切换到主线程执行。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Android的消息机制&quot;&gt;&lt;a href=&quot;#Android的消息机制&quot; class=&quot;headerlink&quot; title=&quot;Android的消息机制&quot;&gt;&lt;/a&gt;Android的消息机制&lt;/h3&gt;&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;&lt;h4 id=&quot;Android的消息机
      
    
    </summary>
    
      <category term="Android开发艺术探索" scheme="http://yoursite.com/categories/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Android开发艺术探索-四大组件的工作过程</title>
    <link href="http://yoursite.com/2020/08/02/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/08/02/Android开发艺术探索-四大组件的工作过程/</id>
    <published>2020-08-02T12:13:21.000Z</published>
    <updated>2020-08-16T03:08:29.325Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第九章-四大组件的工作过程"><a href="#第九章-四大组件的工作过程" class="headerlink" title="第九章　四大组件的工作过程"></a>第九章　四大组件的工作过程</h3><ol><li><h4 id="四大组件的运行状态"><a href="#四大组件的运行状态" class="headerlink" title="四大组件的运行状态"></a>四大组件的运行状态</h4><ul><li><p>Activity</p><p>展示一个界面并和用户进行交互．由<strong>Intent</strong>触发启动 ，分为显示Intent和隐式Intent，显示Intent可以明确指向一个Activity组件，隐式Intent可以指向<strong>一个或多个</strong>Activity组件</p></li><li><p>Service</p><p>一种计算型组件，用于在后台执行一系列计算．与Activity只有一种启动状态不同，Service有两种状态：启动状态（startService）和绑定状态（bindService）．Service是运行在主线程中的．</p></li><li><p>BroadcastReceiver</p><p>一种消息型组件，用于在不同的组件，不同的应用之间传递消息．</p><p>广播有两种注册方式：</p><ol><li>静态注册：在AndroidManifest中注册广播，在应用安装时被系统解析，无须应用启动就可以收到相应的广播．</li><li>动态注册：通过<strong>Context.registerReceiver()</strong>和<strong>Context.unRegisterReceiver()</strong>来注册和注销广播，需要应用启动才能注册并接收广播．</li></ol></li><li><p>ContentProvider</p><p>一种数据共享型组件，用于向其它组件和应用共享数据．</p></li></ul></li><li><h4 id="Activity的工作过程"><a href="#Activity的工作过程" class="headerlink" title="Activity的工作过程"></a>Activity的工作过程</h4><ul><li><p>显示调用，启动Activity</p><pre><code class="hljs java">Intent intent = <span class="hljs-keyword">new</span> Intent(<span class="hljs-keyword">this</span>, TestActivity.Class);startActivity(intent);</code></pre></li><li><p>启动流程</p><pre class="mermaid">     sequenceDiagramActivity ->> Activity : startActvityActivity ->> Activity : startActivityForResultActivity ->> Instrumentation : execStartActivityInstrumentation ->> ActivityManagerService : ActivityManagerNative.getDefault().startActivityActivityManagerService ->> ActivityManagerService : startActivityActivityManagerService ->> ActivityStackSupervisor : startActivityLockedActivityStackSupervisor ->> ActivityStack : resumeTopActivitiesLockedActivityStack ->> ActivityStackSupervisor : startSpecificActivityLockedActivityStackSupervisor ->> ActivityStackSupervisor : realStartActivityLockedActivityStackSupervisor ->> ApplicationThread : sceduleLaunchActivityApplicationThread ->> ActivityThread : handleLaunchActivityActivityThread ->> ActivityThread : performLaunchActivity</pre><p><code>performLaunchActivity</code>方法具体内容：</p><ol><li>从<strong>ActivityClientRecord</strong>中获取待启动的Activity的组件信息</li><li>通过<strong>Instrumentation</strong>的<em>newActivity</em>方法使用类加载器创建Activity对象</li><li>通过<strong>LoadedApk</strong>的<em>makeApplication</em>方法来尝试创建Application对象</li><li>创建<strong>ContextImpl</strong>对象并通过Activity的<em>attach</em>方法完成h重要数据初始化</li><li>调用Activity的<em>onCreate</em>方法</li></ol></li></ul></li><li><h4 id="Service的工作过程"><a href="#Service的工作过程" class="headerlink" title="Service的工作过程"></a>Service的工作过程</h4><ul><li><p>启动状态：主要用于执行后台计算</p><pre><code class="hljs java"><span class="hljs-comment">//启动Service</span>Intent intentService = <span class="hljs-keyword">new</span> Intent(<span class="hljs-keyword">this</span>,TmpService.class);startService(intentService);</code></pre></li><li><p>绑定状态：用于其他组件和Service的交互</p><pre><code class="hljs java"><span class="hljs-comment">//绑定Service</span>Intent intentService = <span class="hljs-keyword">new</span> Intent(<span class="hljs-keyword">this</span>,TmpService.class);bindService(intentService,mServiceConn,BIND_AUTO_CREATE);</code></pre></li></ul><blockquote><p>两种状态可以共存，一个Service既可以处于启动状态，也可以同时处于绑定状态</p></blockquote><ol><li><p>Service的启动过程</p><pre class="mermaid">      sequenceDiagramActivity ->> ContextWrapper : startServiceContextWrapper ->> ContextImpl : startServiceContextImpl ->> ContextImpl : startServiceCommonContextImpl ->> ActivityManagerService : startServiceActivityManagerService ->> ActiveServices : startServiceLockedActiveServices ->> ActiveServices : startServiceInnerLockedActiveServices ->> ActiveServices : bringUpServiceLockedActiveServices ->> ApplicationThread : realStartServiceLockedApplicationThread ->> ApplicationThread : scheduleCreateServiceApplicationThread ->> ActivityThread : handleCreateService</pre><p><code>handleCreateService</code>方法具体内容：</p><ol><li>通过类加载器创建<strong>Service</strong>的实例</li><li>创建<strong>Application</strong>对象并调用其<em>onCreate</em></li><li>创建<strong>ContextImpl</strong>对象并通过<strong>Service</strong>的<em>attach</em>方法建立联系</li><li>调用<strong>Service</strong>的<em>onCreate</em>方法并将<strong>Service</strong>对象存到<strong>ActivityThread</strong>的列表中</li></ol></li><li><p>Service的绑定过程</p><pre class="mermaid">      sequenceDiagramContextWrapper ->> ContextImpl : bindServiceContextImpl ->> ContextImpl : bindServiceCommonContextImpl ->> LoadedApk : getServiceDispatcherLoadedApk -->> ContextImpl : ServiceDispatcher.InnerConnectionContextImpl ->> ActivityManagerService : bindServiceActivityManagerService ->> ActiveServices : bindServiceLockedActiveServices ->> ActiveServices : bringUpServiceLockedActiveServices ->> ApplicationThread : realStartServiceLockedApplicationThread ->> ActivityManagerService : handleBindServiceActivityManagerService ->> ActivityManagerService : publishServiceActivityManagerService ->> ActiveServices : publishServiceLocked</pre></li></ol></li><li><h4 id="BroadcastReceiver的工作过程"><a href="#BroadcastReceiver的工作过程" class="headerlink" title="BroadcastReceiver的工作过程"></a>BroadcastReceiver的工作过程</h4><ol><li><p>广播的注册过程</p><ul><li><p>静态注册</p><p>静态注册的广播在应用安装时由<code>PackageManagerService</code>来完成整个注册过程(其它三大组件亦是如此)</p></li><li><p>动态注册</p><pre class="mermaid">        sequenceDiagramContextWrapper ->> ContextImpl : registerReceiverContextImpl ->> ContextImpl : registerReceiverInternalContextImpl ->> LoadedApk : getReceiverDispatcherLoadedApk -->> ContextImpl : IIntentReceiverContextImpl ->> ActivityManagerService : registerReceiver</pre></li></ul></li><li><p>广播的发送和接收过程</p><ul><li><p>广播的发送过程</p><pre class="mermaid">        sequenceDiagramContextWrapper ->> ContextImpl : sendBroadcastContextImpl ->> ActivityManagerService : broadcastIntentActivityManagerService ->> ActivityManagerService : broadcastIntentLockedActivityManagerService ->> ActivityManagerService : scheduleBroadcastsLockedActivityManagerService ->> ActivityManagerService : processNextBroadcastActivityManagerService ->> ActivityManagerService : performReceiveLockedActivityManagerService ->> ApplicationThread : scheduleRegisteredReceiverApplicationThread ->> InnerReceiver : performReceiverInnerReceiver ->> LoadedApk.ReceiverDispatcher : performReceive</pre><blockquote><p>应用处于停止状态的两种情形：</p><ol><li>应用安装后未运行</li><li>应用被手动或其他应用强制停止</li></ol></blockquote></li></ul></li></ol></li><li><h4 id="ContentProvider的工作过程"><a href="#ContentProvider的工作过程" class="headerlink" title="ContentProvider的工作过程"></a>ContentProvider的工作过程</h4><p><strong>ContentProvider</strong>是一种内容共享型组件，它通过<em>Binder</em>向其他组件乃至其他应用提供数据。当<strong>ContentProvider</strong>所在的进程启动时，<strong>ContentProvider</strong>会同时启动并被发布到<strong>AMS</strong>中。这时候<strong>ContentProvider</strong>的<em>onCreate</em>要先于<strong>Application</strong>的<em>onCreate</em>而执行<br><img src="D:\Downloads\图片\图9-1 ContentProvider的启动过程.png" srcset="/img/loading.gif" alt="image-20200802104139887"></p><p>ContentProvider启动后，外界可以提供它所提供的<strong>增删改查</strong>四个接口来操作数据源，这四个方法都是通过Binder来调用的，外界无法直接访问ContentProvider，只能通过ActivityManagerService根据Uri来获取对应的ContentProvider的Binder接口IContentProvider，再通过IContentProvider访问ContentProvider中的数据源</p><ul><li><p>ContentProvider的启动过程(以query为例)</p><pre class="mermaid">     sequenceDiagramActivityThread ->> ActivityManagerService : startProcessLockedActivityManagerService ->> ActivityThread : mainActivityThread ->> ActivityThread : attachActivityThread ->> ActivityManagerService : attachApplicationActivityManagerService ->> ActivityManagerService : attachApplicationLockedActivityManagerService ->> ApplicationThread : bindApplicationApplicationThread ->> ActivityThread : handleBindApplication</pre><p><code>handleBindApplication</code>具体内容：</p><ol><li>创建<strong>ContextImpl</strong>和<strong>Instrumentation</strong></li><li>创建<strong>Application</strong>对象</li><li>启动当前进程的<strong>ContentProvider</strong>并调用其<em>onCreate</em>f方法</li><li>调用<strong>Application</strong>的<em>onCreate</em>方法</li></ol></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;第九章-四大组件的工作过程&quot;&gt;&lt;a href=&quot;#第九章-四大组件的工作过程&quot; class=&quot;headerlink&quot; title=&quot;第九章　四大组件的工作过程&quot;&gt;&lt;/a&gt;第九章　四大组件的工作过程&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;h4 id=&quot;四大组件的运行状态&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="Android开发艺术探索" scheme="http://yoursite.com/categories/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Android开发艺术探索-理解Window和WindowManager</title>
    <link href="http://yoursite.com/2020/07/26/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%90%86%E8%A7%A3Window%E5%92%8CWindowManager/"/>
    <id>http://yoursite.com/2020/07/26/Android开发艺术探索-理解Window和WindowManager/</id>
    <published>2020-07-26T12:11:07.000Z</published>
    <updated>2020-08-16T03:08:05.920Z</updated>
    
    <content type="html"><![CDATA[<h3 id="理解Window和WindowManager"><a href="#理解Window和WindowManager" class="headerlink" title="理解Window和WindowManager"></a>理解Window和WindowManager</h3><hr><p><strong>Window</strong>表示一个窗口的概念，是一个抽象类，它的具体实现是<code>PhoneWindow</code>。创建一个<strong>Window</strong>需要通过<strong>WindowManage</strong>来完成，<strong>WindowManager</strong>是外界访问<strong>Window</strong>的入口，<strong>Window</strong>的具体实现在<code>WindowManagerService</code>中，<strong>WindowManager</strong>和<code>WindwManagerService</code>的交互是一个<strong>IPC</strong>过程。Android中所有的视图都是通过<strong>Window</strong>来呈现的，<strong>Window</strong>是<strong>View</strong>的直接管理者。</p><h4 id="1-Window和WindowManager"><a href="#1-Window和WindowManager" class="headerlink" title="1. Window和WindowManager"></a>1. Window和WindowManager</h4><p>​    WindowManager常用的有三个方法：添加View, 更新View, 删除View</p><pre><code class="hljs java"><span class="hljs-comment">//添加View</span>mButton = <span class="hljs-keyword">new</span> Button(<span class="hljs-keyword">this</span>);mLayoutParams = <span class="hljs-keyword">new</span> WindowManager.LayoutParams(....);mLayoutParams.flags = LayoutParams.FLAG_NOT_TOUCH_MODAL...;mLayoutParams.gravity = Gravity.LEFT;mLayoutParams.x = <span class="hljs-number">100</span>;mLayoutParams.y = <span class="hljs-number">300</span>;mWindowManager.addView(mButton, mLayoutParams);</code></pre><blockquote><ul><li><p><code>flags</code>参数表示Window的属性：</p><p>FLAG_NOT_FOCUSABLE:Window不需要获取焦点，也不需要接收各种输入事件</p><p>FLAG_NOT_TOUCH_MODAL: 系统会将当前Window区域以外的单击事件传递给底层的Window,区域内View处理<br>FLAG_SHOW_WHEN_LOCKED: 可以让Window显示在锁屏的界面上</p></li><li><p>Window是分层的，每个Window都有对应的<code>z-ordered</code>，层级大的会覆盖在层级小的上面。</p></li><li><p><code>type</code>参数表示Window的类型，Window有三种类型，分别为</p><p><code>应用Window</code> : 对应着一个Activity.层级范围是==1~99==</p><p><code>子Window</code> : 不能单独存在，需要附属在特定的父Window中，比如dialog等，层级范围是==1000~1999==</p><p><code>系统Window</code> ：需要声明权限才能创建的Window，比如Toast和系统状态栏，层级范围是==2000~2999==</p></li></ul></blockquote><h4 id="2-Window的内部机制"><a href="#2-Window的内部机制" class="headerlink" title="2. Window的内部机制"></a>2. Window的内部机制</h4><p>​    每个Window都对应着一个View和一个ViewRootImpl,Window和View通过ViewRootImpl来建立联系。</p><ol><li><p>Window的添加过程</p><pre class="mermaid">   sequenceDiagramActor ->>+ Window : addViewWindow ->>+ WindowManager : addViewWindowManager ->>+ WindowManagerImpl : addViewWindowManagerImpl ->>+ WindowManagerGlobal : addViewWindowManagerGlobal ->> WindowManagerGlobal : 检查参数是否合法WindowManagerGlobal ->> WindowManagerGlobal : 创建ViewRootImpl,添加View列表WindowManagerGlobal ->> ViewRootImpl : 更新界面ViewRootImpl ->> WindowSession : 添加WindowWindowSession ->> WindowManagerService : 添加Window</pre></li><li><p>Window的删除过程</p><pre class="mermaid">   sequenceDiagramWindow... ->> WindowManagerImpl :removeViewWindowManagerImpl ->> WindowManagerImpl : 查找待删除的View索引WindowManagerImpl ->> WindowManagerImpl : 调用removeViewLocked完成删除</pre><blockquote><p>真正删除的逻辑在<code>dispatchDetachedFromWindow</code>方法中实现</p><ol><li>垃圾回收</li><li>通过Session的remove方法删除Window</li><li>调用View的dispatchDetachedFromWindow方法</li><li>调用WindowManagerGlobal的doRemoveView方法刷新数据</li></ol></blockquote></li><li><p>Window的更新过程</p><p>更新逻辑在<strong>WindowManagerGlobal</strong>的<code>updateViewLayout</code>中</p><ol><li>更新View的LayoutParams并替换掉原有的</li><li>更新ViewRootImpl中的LayoutParams</li></ol></li></ol><h4 id="3-Window的创建过程"><a href="#3-Window的创建过程" class="headerlink" title="3. Window的创建过程"></a>3. Window的创建过程</h4><ol><li><p>Activity的Window创建过程</p><pre class="mermaid">   sequenceDiagramActor ->> ActivityThread : startActivityActivityThread ->> ActivityThread : performLaunchActivityActivityThread ->> PolicyManager : attachPolicyManager ->> PolicyManager : makeNewWindowPolicyManager ->> Policy : makeNewWindow</pre><p>Activity将具体实现交给了Window，所以其逻辑在<code>PhoneWindow</code>中,大致步骤如下：</p><ol><li>如果没有DecorView，就创建它</li><li>将View添加到DecorView的mContentParent中</li><li>回调Activity的onContentChanged方法通知视图改变</li><li>调用Activity的makeVisible方法，完成DecorView的添加和显示</li></ol></li><li><p>Dialog的Window创建过程</p><ol><li>创建Window</li><li>初始化DecorView并将Dialog的视图添加到DecorView中</li><li>将DecorView添加到Window中并显示</li></ol><blockquote><p>普通的Dialog必须采用Activity的Context，否则会报缺失token的错误，应用token一般只有Activity拥有，但系统Window可以不需要token</p></blockquote></li><li><p>Toast的Window创建过程</p><p>在Toast内部有两类IPC过程，第一类是Toast访问<code>NotificationManagerService</code>,第二类是<code>NotificationManagerService</code>回调Toast中的TN接口。Toast属于系统Window。</p><pre class="mermaid">   sequenceDiagramToast ->> NotificationManagerService : showNotificationManagerService ->> NotificationManagerService : enqueueToastNotificationManagerService ->> NotificationManagerService : showNextToastoLockedNotificationManagerService ->>NotificationManagerService : scheduleTimeoutLocked</pre></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;理解Window和WindowManager&quot;&gt;&lt;a href=&quot;#理解Window和WindowManager&quot; class=&quot;headerlink&quot; title=&quot;理解Window和WindowManager&quot;&gt;&lt;/a&gt;理解Window和WindowManag
      
    
    </summary>
    
      <category term="Android开发艺术探索" scheme="http://yoursite.com/categories/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Android开发艺术探索-Android动画深入分析</title>
    <link href="http://yoursite.com/2020/07/22/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-Android%E5%8A%A8%E7%94%BB%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2020/07/22/Android开发艺术探索-Android动画深入分析/</id>
    <published>2020-07-22T13:26:37.000Z</published>
    <updated>2020-08-16T03:07:45.588Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Android动画深入分析"><a href="#Android动画深入分析" class="headerlink" title="Android动画深入分析"></a>Android动画深入分析</h3><hr><h4 id="1-View动画"><a href="#1-View动画" class="headerlink" title="1. View动画"></a>1. View动画</h4><p>​    View动画的作用对象是View,支持<code>平移动画</code>,<code>缩放动画</code>,<code>旋转动画</code>,<code>透明度动画</code>四种动画效果</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">标签</th><th style="text-align:center">子类</th><th style="text-align:center">效果</th></tr></thead><tbody><tr><td style="text-align:center">平移动画</td><td style="text-align:center">&lt;translate&#62;</td><td style="text-align:center">TransateAnimation</td><td style="text-align:center">移动View</td></tr><tr><td style="text-align:center">缩放动画</td><td style="text-align:center">&lt;scale&#62;</td><td style="text-align:center">ScaleAnimation</td><td style="text-align:center">放大或缩小View</td></tr><tr><td style="text-align:center">旋转动画</td><td style="text-align:center">&lt;rotate&#62;</td><td style="text-align:center">RotateAnimation</td><td style="text-align:center">旋转View</td></tr><tr><td style="text-align:center">透明度动画</td><td style="text-align:center">&lt;alpha&#62;</td><td style="text-align:center">AlphaAnimation</td><td style="text-align:center">改变View透明度</td></tr></tbody></table><h5 id="1-使用步骤"><a href="#1-使用步骤" class="headerlink" title="1.使用步骤"></a>1.使用步骤</h5><ol><li><p>在res/anim/路径下创建动画的xml文件</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">set</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://scemas.android.com/apk/res/android"</span>     <span class="hljs-attr">android:fillAfter</span>=<span class="hljs-string">"true"</span>     <span class="hljs-attr">android:zAdjustment</span>=<span class="hljs-string">"normal"</span> &gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">rotate</span>            <span class="hljs-attr">android:duration</span>=<span class="hljs-string">"400"</span>            <span class="hljs-attr">android:fromDegress</span>=<span class="hljs-string">"0"</span>            <span class="hljs-attr">android:toDegress</span>=<span class="hljs-string">"90"</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span></code></pre></li><li><p>在代码中调用</p><pre><code class="hljs java">Animation animation = AnimationUtils.loadAnimation(<span class="hljs-keyword">this</span>, R.anim.animation_file);mButton.startAnimation(animation)</code></pre><p>也可直接在代码中进行设置和调用</p><pre><code class="hljs java">AlphaAnimation alphaAnim = <span class="hljs-keyword">new</span> AlphaAnimation(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);alphaAnim.setDuration(<span class="hljs-number">300</span>);mButton.startAnimation(animation)</code></pre></li></ol><h5 id="2-自定义View动画"><a href="#2-自定义View动画" class="headerlink" title="2.自定义View动画"></a>2.自定义View动画</h5><ol><li>继承Animation</li><li><p>重写<code>initialize</code>和<code>applyTransformation</code>方法</p><blockquote><p>initialize : 初始化</p><p>applyTransformation : 进行相应的矩阵变换</p></blockquote></li></ol><h4 id="2-帧动画"><a href="#2-帧动画" class="headerlink" title="2. 帧动画"></a>2. 帧动画</h4><p>​    帧动画是顺序播放一组预先定义好的图片。</p><h5 id="1-使用步骤-1"><a href="#1-使用步骤-1" class="headerlink" title="1. 使用步骤"></a>1. 使用步骤</h5><ol><li><p>通过XML定义AnimationDrawable</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- res/drawable/frame_anim.xml --&gt;</span><span class="hljs-meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">animation-list</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://scemas.android.com/apk/res/android"</span>                <span class="hljs-attr">android:oneshot</span>=<span class="hljs-string">"false"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">andrid:drawable</span>=<span class="hljs-string">"@drawable/image1"</span> <span class="hljs-attr">android:duration</span>=<span class="hljs-string">"500"</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">andrid:drawable</span>=<span class="hljs-string">"@drawable/image2"</span> <span class="hljs-attr">android:duration</span>=<span class="hljs-string">"500"</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">andrid:drawable</span>=<span class="hljs-string">"@drawable/image3"</span> <span class="hljs-attr">android:duration</span>=<span class="hljs-string">"500"</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">animation-list</span>&gt;</span></code></pre><ol start="2"><li>代码中调用</li></ol><pre><code class="hljs java">mButton.setBackroundResource(R.drawable.frame_anim);AnimationDrawable drawable = (AnimationDrawable) mButton.getBackground();drawable.start();</code></pre></li></ol><h4 id="3-View动画的特殊使用场景"><a href="#3-View动画的特殊使用场景" class="headerlink" title="3. View动画的特殊使用场景"></a>3. View动画的特殊使用场景</h4><ol><li><p>LayoutAnimation</p><p>LayoutAnimation作用于ViewGroup,为ViewGroup指定一个动画，子元素都会具有该动画效果</p></li><li><p>Activity的切换效果</p><p>主要用到<code>overridePendingTransition(int enterAnim, int exitAnim)</code>方法，这个方法必须在<strong>startActivity</strong>或者<strong>finish</strong>方法之后调用才能生效</p><p>enterAnim ： Activity被打开时的动画资源</p><p>exitAnim ： Activity被暂停时的动画资源</p></li></ol><h4 id="4-属性动画"><a href="#4-属性动画" class="headerlink" title="4. 属性动画"></a>4. 属性动画</h4><p>​        属性动画可以对任意对象的属性进行动画而不仅仅是View,动画的默认时间间隔是300ms,默认帧率是10ms/帧，其可以达到的效果是：在一个时间间隔内完成对象从一个属性值到另一个属性值的改变。</p><blockquote><p>插值器(TimeInterpolator)：根据时间流逝的百分比来计算当前属性值改变的百分比</p><p>估值器(TypeEvaluator)：根据当前属性改变的百分比来计算改变后的属性值</p></blockquote><p>属性动画的监听器：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AnimatorListener</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onAnimationStart</span><span class="hljs-params">(Animator animation)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onAnimationEnd</span><span class="hljs-params">(Animator animation)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onAnimationCancel</span><span class="hljs-params">(Animator animation)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onAnimationRepeat</span><span class="hljs-params">(Animator animation)</span></span>;&#125;</code></pre><p>属性动画的工作原理：</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Android动画深入分析&quot;&gt;&lt;a href=&quot;#Android动画深入分析&quot; class=&quot;headerlink&quot; title=&quot;Android动画深入分析&quot;&gt;&lt;/a&gt;Android动画深入分析&lt;/h3&gt;&lt;hr&gt;
&lt;h4 id=&quot;1-View动画&quot;&gt;&lt;a hre
      
    
    </summary>
    
      <category term="Android开发艺术探索" scheme="http://yoursite.com/categories/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Android开发艺术探索-理解RemoteViews</title>
    <link href="http://yoursite.com/2020/07/19/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%90%86%E8%A7%A3RemoteViews/"/>
    <id>http://yoursite.com/2020/07/19/Android开发艺术探索-理解RemoteViews/</id>
    <published>2020-07-19T12:46:27.000Z</published>
    <updated>2020-08-16T03:07:22.001Z</updated>
    
    <content type="html"><![CDATA[<h3 id="理解RemoteViews"><a href="#理解RemoteViews" class="headerlink" title="理解RemoteViews"></a>理解RemoteViews</h3><h4 id="1-RemoteViews的应用"><a href="#1-RemoteViews的应用" class="headerlink" title="1. RemoteViews的应用"></a>1. RemoteViews的应用</h4><p>RemoteViews在实际开发中主要用在通知栏和桌面小部件的开发中。通知栏主要通过<code>NotificationManager</code>的<strong>notify</strong>方法实现，桌面小部件则通过<code>AppWidgetProvider</code>实现。这两个的界面都运行在系统的<strong>SystemServer</strong>进程中，无法直接更新View.</p><h5 id="1-RemoteViews在通知栏上的应用"><a href="#1-RemoteViews在通知栏上的应用" class="headerlink" title="1.RemoteViews在通知栏上的应用"></a>1.RemoteViews在通知栏上的应用</h5><ul><li><p>使用系统默认样式</p><pre><code class="hljs java"><span class="hljs-comment">// Build the notification and add the action.</span>Notification newMessageNotification = <span class="hljs-keyword">new</span> Notification.Builder(context, CHANNEL_ID)        .setSmallIcon(R.drawable.ic_message)        .setContentTitle(getString(R.string.title))        .setContentText(getString(R.string.content))        .addAction(action)        .build();<span class="hljs-comment">// Issue the notification.</span>NotificationManagerCompat notificationManager = NotificationManagerCompat.from(<span class="hljs-keyword">this</span>);notificationManager.notify(notificationId, newMessageNotification);</code></pre></li><li><p>自定义通知</p><pre><code class="hljs java"><span class="hljs-comment">// Get the layouts to use in the custom notification</span>RemoteViews notificationLayout = <span class="hljs-keyword">new</span> RemoteViews(getPackageName(), R.layout.notification_small);RemoteViews notificationLayoutExpanded = <span class="hljs-keyword">new</span> RemoteViews(getPackageName(), R.layout.notification_large);<span class="hljs-comment">// Apply the layouts to the notification</span>Notification customNotification = <span class="hljs-keyword">new</span> NotificationCompat.Builder(context, CHANNEL_ID)        .setSmallIcon(R.drawable.notification_icon)        .setStyle(<span class="hljs-keyword">new</span> NotificationCompat.DecoratedCustomViewStyle())        .setCustomContentView(notificationLayout)        .setCustomBigContentView(notificationLayoutExpanded)        .build();</code></pre></li></ul><h5 id="2-RemoteViews在桌面小部件上的应用"><a href="#2-RemoteViews在桌面小部件上的应用" class="headerlink" title="2.RemoteViews在桌面小部件上的应用"></a>2.RemoteViews在桌面小部件上的应用</h5><pre><code>AppWidgetProvider是Android中提供的用于实现桌面小部件的类，本质是一个广播</code></pre><ul><li><p>定义小部件界面</p><p>在res/layout/下建立小部件布局界面</p></li><li><p>定义小部件配置信息</p><p>在res/xml/下建立小部件配置信息</p><blockquote><p>重要参数说明：</p><p>initLayout:初始化界面</p><p>updatePeriodMillis:自动更新周期</p></blockquote></li><li><p>定义小部件的实现类</p><p>继承AppWidgetProvider实现具体逻辑</p><blockquote><p>重要方法说明：</p><p>onEnable:小部件第一次添加到桌面时调用该方法</p><p>onUpdate:小部件被添加时或者每次小部件更新时都会调用该方法</p><p>onDeleted:每删除一次桌面小部件就调用一次</p><p>onDisabled:最后一个该类型的桌面小部件被删除时调用该方法</p><p>onReceive:分发具体的事件给其他方法</p></blockquote></li><li><p>在AndroidManifest.xml中声明小部件</p><h5 id="3-PendingIntent概述"><a href="#3-PendingIntent概述" class="headerlink" title="3.PendingIntent概述"></a>3.PendingIntent概述</h5></li></ul><p>​        PendingIntent表示一种处于待定，等待，即将发生状态的意图，支持三种待定意图：启动Activity,启动Service,发送        广播</p><pre><code class="hljs java">getActivity(Context context, <span class="hljs-keyword">int</span> requestCode, Intent intent, <span class="hljs-keyword">int</span> flags);getService(Context context, <span class="hljs-keyword">int</span> requestCode, Intent intent, <span class="hljs-keyword">int</span> flags);getBroadcast(Context context, <span class="hljs-keyword">int</span> requestCode, Intent intent, <span class="hljs-keyword">int</span> flags);</code></pre><ul><li><p>匹配规则：如果两个PendingIntent它们内部的<code>Intent</code>相同并且<code>requestCode</code>也相同，则这两个PendingIntent相同</p><blockquote><p>Intent匹配规则：如果两个Intent的<code>ComponentName</code>和<code>intent-filter</code>都相同，则这两个Intent相同</p></blockquote></li><li><p>Flag参数</p><ul><li><p>FLAG_ONE_SHOT</p><p>当前PendingIntent只能使用一次</p></li><li><p>FLAG_NO_CREATE</p><p>当前PendingIntent不会主动创建，如果不存在，则get方法会直接返回<code>null</code></p></li><li><p>FLAG_CANCEL_CURRENT</p><p>当前描述的PendingIntent如果已存在，那么它们都会被<code>cancel</code></p></li><li><p>FLAG_UPDATE_CURRENT</p><p>当前描述的PendingIntent如果已存在，那么它们都会被更新</p></li></ul></li></ul><h4 id="2-RemoteViews的内部机制"><a href="#2-RemoteViews的内部机制" class="headerlink" title="2.RemoteViews的内部机制"></a>2.RemoteViews的内部机制</h4><ul><li><p>构造方法</p><pre><code class="hljs java"><span class="hljs-comment">/*** <span class="hljs-doctag">@param</span> packageName 当前应用的包名* <span class="hljs-doctag">@param</span> layoutId 待加载的布局文件**/</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RemoteViews</span><span class="hljs-params">(String packageName, <span class="hljs-keyword">int</span> layoutId)</span></span></code></pre><blockquote><p>RemoteViews目前并不支持所有的View类型，支持的所有类型如下</p><p>Layout : FrameLayout, LinearLayout, RelativeLayout, GridLayout</p><p>View : AnalogClock, Button, Chronometer, ImageButton, ImageView, ProgressBar, TextView, ViewFlipper, ListView, GridView, StackView, AdapterViewFlipper, ViewStub</p></blockquote></li><li><p>使用</p><p>RemoteViews没有提供findViewById方法，无法直接访问View元素，必须通过RemoteViews所提供的一系列<code>set</code>方法来完成</p></li><li><p>内部机制</p><ol><li><p>RemoteViews会通过Binder传递到SystemServer进程</p></li><li><p>系统根据RemoteViews中的包名等信息得到该应用的资源，加载RemoteViews中的文件</p></li><li><p>系统对生成的View进行一系列界面更新任务</p><p><img src="https://gitee.com/domeofheaven2017/Image/raw/master/BlogImage/图5-1RemoteViews内部机制.png" srcset="/img/loading.gif" alt></p><blockquote><p>单击事件，RemoteViews中只支持发起PendingIntent,不支持onClickListener.</p><p>setOnClickPendingIntent用于给普通View设置单击事件，但不能给集合(ListView,StackView)中的View设置单击事件</p><p>要给ListView或StackView中的item添加单击事件，必须将setPendingIntentTemplate和setOnClickFillInIntent组合使用</p></blockquote></li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;理解RemoteViews&quot;&gt;&lt;a href=&quot;#理解RemoteViews&quot; class=&quot;headerlink&quot; title=&quot;理解RemoteViews&quot;&gt;&lt;/a&gt;理解RemoteViews&lt;/h3&gt;&lt;h4 id=&quot;1-RemoteViews的应用&quot;&gt;&lt;a 
      
    
    </summary>
    
      <category term="Android开发艺术探索" scheme="http://yoursite.com/categories/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Android开发艺术探索-View的工作原理</title>
    <link href="http://yoursite.com/2020/07/12/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-View%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2020/07/12/Android开发艺术探索-View的工作原理/</id>
    <published>2020-07-12T13:03:10.000Z</published>
    <updated>2020-08-16T03:06:57.075Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Android开发艺术探索-第四章笔记"><a href="#Android开发艺术探索-第四章笔记" class="headerlink" title="Android开发艺术探索 第四章笔记"></a>Android开发艺术探索 第四章笔记</h3><h4 id="第四章-View的工作原理"><a href="#第四章-View的工作原理" class="headerlink" title="第四章  View的工作原理"></a>第四章  View的工作原理</h4><ol><li><p>初识ViewRoot和DecorView</p><p>ViewRoot:对应于ViewRootImpl类，是连接WindowManager和DecorView的纽带，View的三大流程(measure,layout,draw)来完成的。</p><pre><code class="hljs java"><span class="hljs-comment">//在ActivityThread中，当Activity对象被创建完后，会将DecorView添加到Window中，同时创建 </span><span class="hljs-comment">//ViewRootImpl对象，并将这两者关联起来</span>root = <span class="hljs-keyword">new</span> ViewRootImpl(view.getContext(),display);root.setView(view,wparams,panelParentView);</code></pre><p>View的绘制流程从ViewRoot的performTraversals方法开始，经过三大流程完成绘制。</p><p><img src="https://gitee.com/domeofheaven2017/Image/raw/master/BlogImage/图4-1performTraversals的工作流程图.png" srcset="/img/loading.gif" alt="图4-1performTraversals的工作流程图"></p><p>​                                            图 4-1 performTraversals的工作流程图</p><blockquote><p>measure:测量View的宽和高</p><p>layout:确定View在父容器中的放置位置</p><p>draw:将View绘制在屏幕上</p></blockquote></li><li><p>理解MeasureSpec</p><p>在很大程度上决定了一个View的尺寸规格(会受到父容器的影响)。</p><ol><li><p>MeasureSpec:代表一个32位int值，高2位代表<strong>SpecMode</strong>，低30位代表<strong>SpecSize</strong>。</p><ul><li>SpecMode：测量模式</li><li>SpecSize：在某种测量模式下的规格大小</li></ul><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MODE_SHIFT = <span class="hljs-number">30</span>;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MODE_MASK = <span class="hljs-number">0x3</span> &lt;&lt; MODE_SHIFT;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> UNSPECIFIED = <span class="hljs-number">0</span> &lt;&lt; MODE_SHIFT;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> EXACTLY = <span class="hljs-number">1</span> &lt;&lt; MODE_SHIFT;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> AT_MOST = <span class="hljs-number">2</span> &lt;&lt; MODE_SHIFT;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">makeMeasureSpec</span><span class="hljs-params">(<span class="hljs-keyword">int</span> size,<span class="hljs-keyword">int</span> mode)</span></span>&#123;  <span class="hljs-keyword">if</span>(sUseBrokenMakeMeasureSpec)&#123;    <span class="hljs-keyword">return</span> size + mode;  &#125;<span class="hljs-keyword">else</span>&#123;    <span class="hljs-keyword">return</span> (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK)  &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> measureSpec)</span></span>&#123;  <span class="hljs-keyword">return</span> (measureSpec &amp; MODE_MASK);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSize</span><span class="hljs-params">(<span class="hljs-keyword">int</span> measureSpec)</span></span>&#123;  <span class="hljs-keyword">return</span> (measureSpec &amp; ~MODE_MASK);&#125;</code></pre><ul><li><strong>UNSPECIFIED</strong>:父容器不对View有任何限制</li><li><strong>EXACTLY</strong>：父容器已检测出View所需要的精确大小，对应于LayoutParams中的match_parent和具体的尺寸数值。</li><li><strong>AT_MOST</strong>：父容器给View指定了可用大小，View的大小不能大于这个值，对应于LayoutParams中的wrap_content。</li></ul></li><li><p>MeasureSpec和LayoutParams的对应关系</p><ol><li><p>顶级View（Decoriew）：Measurespec由窗口的尺寸和其自身的LayoutParams来共同确定；</p><ul><li>MATVH_PARENT：精确模式，大小就是窗口的大小；</li><li>WRAP_CONTENT:最大模式，大小不定，不能超过窗口的大小；</li><li>固定大小：精确模式，大小为LayoutParams中指定到大小。</li></ul></li><li><p>普通View:Measurespec由父容器的MeasureSpec和自身到LayoutParams共同决定。</p><p>TODO</p><p><img src="https://gitee.com/domeofheaven2017/Image/raw/master/BlogImage/普通View的MeasureSpec的流程.png" srcset="/img/loading.gif" alt></p></li></ol></li></ol></li><li><p>View的工作流程</p><ol><li><p>measure过程</p><ul><li><p>View的measure过程</p><pre><code class="hljs java"><span class="hljs-comment">//在View的measur方法中会去调用View的onMeasure方法</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onMeasure</span><span class="hljs-params">(<span class="hljs-keyword">int</span> widthMeasureSpec, <span class="hljs-keyword">int</span> heightMeasureSpec)</span> </span>&#123;    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(),widthMeasureSpec),getDefaultSize(getSuggestedMinimumHeight(),heightMeasureSpec));&#125;</code></pre><blockquote><p>getSuggestedMinimumXXX:如果View没有设置背景，那么返回<code>android:minXXX</code>这个属性的值；如果View设置了背景，则返回<code>android:minXXX</code>和背景的最小尺寸这两个的最大值。</p><p>直接继承View的自定义控件需要重写onMeasure方法并设置wrap_content时的大小，否则在布局中使用wrap_content就相当于使用match_parent</p></blockquote></li><li><p>ViewGroup的measure过程</p><p>除了完成自己的measure过程外，还需要遍历所有子元素的measure方法。</p><pre><code class="hljs java"><span class="hljs-comment">//ViewGroup是抽象类，没有重写onMeasure方法，提供了measureChildren方法</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">measureChildren</span><span class="hljs-params">(<span class="hljs-keyword">int</span> widthMeasureSpec, <span class="hljs-keyword">int</span> heightMeasureSpec)</span> </span>&#123;    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> size = mChildrenCount;    <span class="hljs-keyword">final</span> View[] children = mChildren;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i) &#123;        <span class="hljs-keyword">final</span> View child = children[i];        <span class="hljs-keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123;            measureChild(child, widthMeasureSpec, heightMeasureSpec);        &#125;    &#125;&#125;</code></pre><blockquote><p>measure完成后，通过<code>getMeasuredWidth/Height</code>方法就可以正确获取到View的宽高，但由于存在多次measure的情况，所以在onMeasure中得到的测量宽高不一定准确，<strong>在onLayout方法中获取宽高比较好一点</strong>。<br>View的measue过程和Activity的生命周期方法不是同步执行的。可以通过以下方法解决：</p><ul><li>Activity/View#onWindowFocusChanged</li><li>view.post(runnable)</li><li>ViewTreeObserver</li><li>view.measure(int widthMeasureSpec, int heightMeasureSpec) </li></ul></blockquote></li></ul></li><li><p>layout过程</p><p>Layout的作用是ViewGroup用来确定子元素的位置，当ViewGroup的位置被确定后，它在onLayout中会遍历所有的子元素并调用其layout方法，在layout方法中onLayout又会被调用。</p><ul><li><p>View的layout方法流程</p><p>首先通过<code>setFrame</code>方法来设定View的四个顶点的位置，接着调用onLayout方法。</p></li></ul><blockquote><p>在View的默认实现中，View的测量宽高和最终宽高是相等的，不同点是测量宽高形成于View的measure过程，最终宽高形成于View的layout过程。</p></blockquote></li><li><p>draw过程</p><p>将View绘制到屏幕上，绘制过程如下：</p><ol><li>绘制背景：backgroud.draw(canvas)</li><li>绘制自身：onDraw</li><li>绘制子元素：dispatchDraw</li><li>绘制装饰：onDrawScrollBars</li></ol><p>View绘制过程的传递通过dispatchDraw实现，该方法会遍历调用所有子元素的draw方法</p></li></ol></li><li><p>自定义View</p><ol><li><p>自定义View的分类</p><pre class="mermaid">      graph LRA[自定义View] --> B[继承View重写onDraw方法]A --> C[继承ViewGroup派生特殊的Layout]A --> D[继承特定的View 如TextView等]A --> E[继承特定的ViewGroup 如LinearLayout等]</pre></li><li><p>自定义View须知</p><ul><li>让View支持<code>wrap_content</code></li><li>支持<code>Padding</code></li><li>尽量不要在View中使用Handler</li><li>View中如果有线程或者动画，需要及时停止(<code>View#onDetachedFromWindow</code>)</li><li>处理好滑动冲突</li></ul></li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Android开发艺术探索-第四章笔记&quot;&gt;&lt;a href=&quot;#Android开发艺术探索-第四章笔记&quot; class=&quot;headerlink&quot; title=&quot;Android开发艺术探索 第四章笔记&quot;&gt;&lt;/a&gt;Android开发艺术探索 第四章笔记&lt;/h3&gt;&lt;h4 i
      
    
    </summary>
    
      <category term="Android开发艺术探索" scheme="http://yoursite.com/categories/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Android开发艺术探索-View的事件体系</title>
    <link href="http://yoursite.com/2020/07/08/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-View%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/"/>
    <id>http://yoursite.com/2020/07/08/Android开发艺术探索-View的事件体系/</id>
    <published>2020-07-08T13:53:09.000Z</published>
    <updated>2020-08-16T03:06:35.076Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Android开发艺术探索-第三章笔记"><a href="#Android开发艺术探索-第三章笔记" class="headerlink" title="Android开发艺术探索 第三章笔记"></a>Android开发艺术探索 第三章笔记</h3><h4 id="第三章-View的事件体系"><a href="#第三章-View的事件体系" class="headerlink" title="第三章 View的事件体系"></a>第三章 View的事件体系</h4><h5 id="3-1-View基础知识"><a href="#3-1-View基础知识" class="headerlink" title="3.1 View基础知识"></a>3.1 View基础知识</h5><ol><li><p>什么是View</p><p>View是Android中所有控件的基类，是一种界面层的控件的一种抽象。ViewGroup内部包含了许多控件，是一组View，它们之间的关系如下图。</p><p><img src="https://gitee.com/domeofheaven2017/Image/raw/master/BlogImage/图3-1View的层级结构.png" srcset="/img/loading.gif" alt="图3-1View的层级结构"></p></li><li><p>View的位置参数</p><p>View的位置由它的四个顶点决定，分别对应于View的四个属性：<strong>top, left, right, bottom </strong>即它的四个坐标，并且这四个坐标都是相对与View的父容器来说的，是相对坐标。</p><p><img src="https://gitee.com/domeofheaven2017/Image/raw/master/BlogImage/图3-2View的位置坐标和父容器的关系.png" srcset="/img/loading.gif" alt="图3-2View的位置坐标和父容器的关系"></p><blockquote><p>width = right - left</p><p>height = bottom - top</p></blockquote></li><li><p>MotionEvent和TouchSlop</p><ol><li><p>MotionEvent:在手指接触屏幕后所产生的一系列事件</p><ul><li>ACTION_DOWN——手指刚接触屏幕</li><li>ACTION_MOVE——手指在屏幕上移动</li><li>ACTION_UP——手指从屏幕上松开的一瞬间</li></ul><ol><li>典型事件序列</li></ol><ul><li>点击屏幕后离开松开，事件序列为——DOWN -&gt; UP;</li><li>点击屏幕滑动一会儿在松开，事件序列为——DOWN-&gt;MOVE-&gt;…-&gt;MOVE-&gt;UP</li></ul><ol start="2"><li>通过MotionEvent对象可以得到点击事件发生的<strong>x</strong>和<strong>y</strong>坐标。</li></ol><ul><li>getX/getY——返回的是相对于当前View左上角的x和y坐标；</li><li>getRawX/getRawY——返回的是相对于手机屏幕左上角的x和y坐标。</li></ul></li><li><p>TouchSlop：系统所能识别的滑动的最小距离，当两次滑动之间的距离小于这个常量时，系统不能识别为是滑动事件，值和设备有关，通过如下方法可以获取这个常量。</p><pre><code class="hljs java">ViewConfiguration.get(getContext()).getScaledTouchSlop();</code></pre></li></ol></li><li><p>VelocityTracker,GestureDetector和Scroller</p><ol><li><p>VelocityTracker：速度追踪，用于追踪手指在滑动过程中的速度，包括水平和竖直方向。</p><pre><code class="hljs java"><span class="hljs-comment">//1.首先在View的onTouchEvent方法中追踪当前点击事件的速度</span>VelocityTracker velocityTracker = VelocityTracker.obtain();velocityTracker.addMovement(event);<span class="hljs-comment">//2.获取当前速度</span>velocityTracker.computeCurrentVelocity(<span class="hljs-number">1000</span>);<span class="hljs-comment">//计算一个时间段内的速度</span><span class="hljs-keyword">int</span> xVelocity = (<span class="hljs-keyword">int</span>) velocityTracker.getXVelocity();<span class="hljs-keyword">int</span> yVelocity = (<span class="hljs-keyword">int</span>) velocityTracker.getYVelocity();<span class="hljs-comment">//3.重置并回收内存</span>velocityTracker.clear();velocityTracker.recycle();</code></pre></li><li><p>GestureDetector：手势检测，用于辅助检测用户的单击，滑动，长按，双击等行为。</p><pre><code class="hljs java"><span class="hljs-comment">//1.创建一个GestureDetector对象，实现onGestureListener接口</span>GestureDetector mGestureDetector = <span class="hljs-keyword">new</span> GestureDetector(<span class="hljs-keyword">this</span>);mGestureDetector.setIsLongpressEnabled(<span class="hljs-keyword">false</span>);<span class="hljs-comment">//解决长按屏幕后无法拖动的现象</span><span class="hljs-comment">//2.接管目标View的onTouchEvent方法,在其中使用</span><span class="hljs-keyword">boolean</span> consume = mGestureDetector.onTouchEvent(event);<span class="hljs-keyword">return</span> consume;<span class="hljs-comment">//3.选择实现onGestureListener和OnDoubleTapListener中的方法</span><span class="hljs-comment">//比如onSingleTapup():单击 ，onFling():滑动，onScroll():拖动，onLongPress():长按，</span><span class="hljs-comment">//onDoubleTap():双击</span></code></pre></li><li><p>Scroller：弹性滑动对象，用于实现View的弹性滑动。</p><pre><code class="hljs java">Scroller mScroller = <span class="hljs-keyword">new</span> Scroller(mContext);<span class="hljs-comment">//缓慢滚动到指定位置</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">smoothScrollTo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> destX,<span class="hljs-keyword">int</span> destY)</span></span>&#123;  <span class="hljs-keyword">int</span> scrollX = getScrollX();  <span class="hljs-keyword">int</span> delta = destX-scrollX;  mScroller.startScroll(ScrollX,<span class="hljs-number">0</span>,delta,<span class="hljs-number">0</span>,<span class="hljs-number">1000</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">computeScroll</span><span class="hljs-params">()</span></span>&#123;  <span class="hljs-keyword">if</span>(mScroller.computeScrollOffset())&#123;    smoothScrollTo(mScroller.getCurrX(),mScroller.getCurrY());    postInvalidate();  &#125;&#125;</code></pre></li></ol></li></ol><h5 id="3-2-View的滑动"><a href="#3-2-View的滑动" class="headerlink" title="3.2 View的滑动"></a>3.2 View的滑动</h5><ol><li><p>使用ScrollTo/scrollBy</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> scrollTo（ <span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y）&#123;  <span class="hljs-keyword">if</span>(mScrollX != x||mScrollY !=y)&#123;    <span class="hljs-keyword">int</span> oldX = mScrollX;    <span class="hljs-keyword">int</span> oldY = mScrollY;    mScrollX = x;    mScrollY = y;    invalidateParentCaches();    onScrollChanged(mScrollX,mScrollY,oldX,oldY);    <span class="hljs-keyword">if</span>(!awakenScrollBars())&#123;      postInvalidateOnAnimation();    &#125;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">scrollBy</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;    scrollTo(mScrollX + x,mScrollY + y);  &#125;&#125;</code></pre><blockquote><p>在滑动过程中，mScrollX的值总是等于View左边缘和View内容左边缘在水平方向的距离；mScrollY的值等于View上边缘和View内容上边缘在竖直方向上的距离</p><p>scrollTo和scrollBy只能改变View内容的位置而不能改变View在布局中的位置。</p><p>如果从左向右滑动，那么mScrollX为负值，反之为正值；如果从上往下滑动，那么mScrollY为负值，反之为正值。</p></blockquote><p><img src="https://gitee.com/domeofheaven2017/Image/raw/master/BlogImage/图3-3mScrollX和mScrollY的变换规律.png" srcset="/img/loading.gif" alt="图3-3mScrollX和mScrollY的变换规律"> b</p></li><li><p>使用动画</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--View动画实现移动--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">translate</span>           <span class="hljs-attr">android:duration</span>=<span class="hljs-string">"100"</span>           <span class="hljs-attr">android:fromXDelta</span>=<span class="hljs-string">"0"</span>           <span class="hljs-attr">android:fromYDelta</span>=<span class="hljs-string">"0"</span>           <span class="hljs-attr">android:interpolator</span>=<span class="hljs-string">"@android:anim/linear_interpolator"</span>           <span class="hljs-attr">android:toXDelta</span>=<span class="hljs-string">"100"</span>           <span class="hljs-attr">android:toYDelta</span>=<span class="hljs-string">"100"</span>/&gt;</span></code></pre><pre><code class="hljs java"><span class="hljs-comment">//属性动画实现移动</span>ObjectAnimator.ofFloat(targetView,<span class="hljs-string">"translationX"</span>,<span class="hljs-number">0</span>,<span class="hljs-number">100</span>)              .setDuration(<span class="hljs-number">100</span>)              .start();</code></pre></li><li><p>改变布局参数：即改变<strong>LayoutParams</strong></p><pre><code class="hljs java">MarginLayoutParams params = (MarginLayoutParams)mButton.getLayoutParams();params.width +=<span class="hljs-number">100</span>;params.leftMargin +=<span class="hljs-number">100</span>;mButton.requestLayout(); <span class="hljs-comment">//或者 mButton.setLayoutParams(params);</span></code></pre></li><li><p>各种滑动方式的对比</p><ul><li>scrollTo/scrollBy :  操作简单，适合对View内容的滑动</li><li>动画 ：操作简单，主要适用于没有交互的View和实现复杂的动画效果</li><li>改变布局参数 ：操作稍复杂，适用于有交互的View</li></ul></li></ol><h5 id="3-3-弹性滑动"><a href="#3-3-弹性滑动" class="headerlink" title="3.3 弹性滑动"></a>3.3 弹性滑动</h5><ol><li><p>使用Scroller</p><p>当View重绘后会在在<code>draw</code>方法中调用<strong>computeScroll</strong>，而computeScroll又会去向当前<strong>Scroller</strong>获取当前的<code>scrollX</code>和<code>scrollY</code>；然后通过<code>scrollTo</code>方法实现滑动，然后继续重绘，循环反复。</p></li><li><p>通过动画</p></li><li><p>使用延时策略</p><p>通过发送一系列延时消息达到渐进式的效果，可以使用<code>Handler</code>或View的<code>postDelayed</code>方法。</p></li></ol><h5 id="3-4-View的事件分发机制"><a href="#3-4-View的事件分发机制" class="headerlink" title="3.4 View的事件分发机制"></a>3.4 View的事件分发机制</h5><ol><li><p>点击事件的传递规则</p><pre><code class="hljs java"><span class="hljs-comment">//点击事件分发过程中的三个重要方法</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dispatchTouchEvent</span><span class="hljs-params">(MotionEvent e)</span>  <span class="hljs-comment">//用来进行事件的分发</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onInterceptTouchEvent</span><span class="hljs-params">(MotionEvent e)</span> <span class="hljs-comment">//用来判断是否拦截某个事件</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onTouchEvent</span><span class="hljs-params">(MotionEvent e)</span>  <span class="hljs-comment">//在dispatchTouchEvent中调用，用来处理点击事件</span><span class="hljs-comment">//三个方法的关系（伪代码）</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dispatchTouchEvent</span><span class="hljs-params">(MotionEvent e)</span></span>&#123;  <span class="hljs-keyword">boolean</span> consume =<span class="hljs-keyword">false</span>;  <span class="hljs-keyword">if</span>(onInterceptTouchEvent(e))&#123;    consume =onTOuchEvent(e);  &#125;<span class="hljs-keyword">else</span>&#123;    consume = child.dispatchTouchEvent(e);  &#125;  <span class="hljs-keyword">return</span> consume;&#125;</code></pre><p>当一个点击事件产生时，它的传递过程为：<strong>Activity -&gt; Window -&gt;View</strong>,即事件先传递给Activity，Activity再传递给Window，最后Window再传递给顶级View，顶级View接收到事件后，就会按照事件分发机制去分发事件。</p><blockquote><p>PS：</p><ol><li>同一个事件序列是指从手指接触屏幕那一刻起到手指离开屏幕的那一刻结束，在这一过程中产生的一系列事件；</li><li>正常情况下，一个事件序列只能被一个View拦截且消耗；</li><li>某个View一旦决定拦截，那么这个事件序列都只能由它处理，并且它的onInterceptTouchEvent不会被调用；</li><li>某个View一旦开始处理事件，如果它不消耗ACTION_DOWN(onTouchEvent返回false)，那么同一事件序列的其它事件都不会交由它处理，事件会重新交由它的父元素处理(调用父元素的onTouchEvent);</li><li>ViewGroup默认不拦截任何事件；</li><li>View没有onInterceptTouchEvent方法，一旦有点击 事件传递给它，它的onTouchEvent方法就会调用；</li><li>View的onTouchEvent默认都会消耗事件(返回true)。除非它是不可点击的(clickable和longClickable都为false)；</li><li>View的enable属性不影响onTouchEvent的默认返回值。、</li><li>onClick会发生的前提是当前View是可点击的，并且它收到了down和up事件；</li><li>事件传递过程是由外向内的，即事件总是先传递给父元素，再由父元素分发给子View，通过requestDisallowInterceptTouchEvent方法可以在子元素中干预父元素的事件分发过程，但是ACTION_DOWN事件除外。</li></ol></blockquote></li><li><p>事件分发的源码解析</p><ol><li><p>Activity对点击事件的分发过程</p><p>当一个点击操作发生时，事件最先传递给当前Activity，由Activity的dispatchTouchEvent来进行事件分发，具体是由Activity的Window来完成的。Window会将事件传递给<strong>decor view</strong>，decor view 一般是当前界面的底层容器(即setContentView所设置的View的父容器)。</p><pre><code class="hljs java"><span class="hljs-comment">//Activity # dispatchTouchEvent</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dispatchTouchEvent</span><span class="hljs-params">(MotionEvent ev)</span></span>&#123;  <span class="hljs-keyword">if</span>(ev.getAction() == MotionEvent.ACTION_DOWN)&#123;    onUserInteraction();  &#125;  <span class="hljs-comment">//交由所附属的Window进行分发</span>  <span class="hljs-keyword">if</span>(getWindow().superDispatchTouchEvent(ev))&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;      &#125;  <span class="hljs-keyword">return</span> onTouchEvent(ev);<span class="hljs-comment">//所有View都没有处理，调用Activity的onTouchEvent()</span>&#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">//Window的分发</span><span class="hljs-comment">//Window # superDispatchTouchEvent</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">superDispatchTouchEvent</span><span class="hljs-params">(MotionEvent event)</span><span class="hljs-comment">//Window的唯一实现是PhoneWindow</span><span class="hljs-comment">//PhoneWindow # superDispatchTouchEvent</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">superDispatchTouchEvent</span><span class="hljs-params">(MotionEvent event)</span></span>&#123;  <span class="hljs-keyword">return</span> mDecor.superDispatchTouchEvent(event);&#125;<span class="hljs-comment">//DecorView</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DecorView</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">FrameLayout</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RootViewSurfaceTaker</span></span>&#123;  <span class="hljs-keyword">private</span> DecorView mDecor;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> View <span class="hljs-title">getDecorView</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">if</span>(mDecor == <span class="hljs-keyword">null</span>)&#123;      installDecor();    &#125;    <span class="hljs-keyword">return</span> mDecor;  &#125;&#125;</code></pre></li><li><p>顶级View对点击事件的分发过程</p><p>点击事件到达顶级View(一般是ViewGroup)以后，会调用ViewGroup的<strong>dispatchTouchEvent</strong>方法，然后如果ViewGroup拦截事件(<strong>onInterceptTouchEvent</strong>返回true)，则事件由ViewGroup处理，此时如果ViewGroup设置了<strong>onTouchListener</strong>，则<strong>onTouch</strong>会被调用，否则调用<strong>onTouchEvent</strong>，且如果设置了<strong>onClickListener</strong>，则会调用<strong>onClick</strong>。如果顶级View不拦截，则事件会传递给它所在的点击事件链上的子View，调用子View的<strong>dispatchTouchEvent</strong>，如此循环，完成整个事件的分发。</p><p><img src="https://gitee.com/domeofheaven2017/Image/raw/master/BlogImage/图3-4顶级View的事件分发.png" srcset="/img/loading.gif" alt="图3-4顶级View的事件分发"></p><pre><code class="hljs java"><span class="hljs-comment">//check for interception # dispatchTouchEvent # ViewGroup</span><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> intercepted;<span class="hljs-keyword">if</span>(actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != <span class="hljs-keyword">null</span>)&#123;  <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="hljs-number">0</span>;  <span class="hljs-keyword">if</span>(!disallowIntercept)&#123;    intercepted = onInterceptTouchEvent(ev);    ev.setAction(action);<span class="hljs-comment">//restore action in case it was changed</span>  &#125;<span class="hljs-keyword">else</span>&#123;    intercepted = <span class="hljs-keyword">true</span>;  &#125;&#125;<span class="hljs-keyword">else</span>&#123;  intercepated = <span class="hljs-keyword">true</span>;&#125;</code></pre><blockquote><ol><li><code>onInterceptTouchEvent</code>不是每次事件都会被调用，当事件能够传递到当前的<strong>ViewGroup</strong>时，<code>dispatchTouchEvent</code>会每次都调用</li><li><code>FLAG_DISALLOW_INTERCEPT</code>标记可以让<strong>ViewGroup</strong>不再拦截事件</li></ol></blockquote></li><li><p>View对点击事件的处理过程</p><p><img src="https://gitee.com/domeofheaven2017/Image/raw/master/BlogImage/View点击事件处理流程.png" srcset="/img/loading.gif" alt></p></li></ol></li></ol><h5 id="3-5-View的滑动冲突"><a href="#3-5-View的滑动冲突" class="headerlink" title="3.5 View的滑动冲突"></a>3.5 View的滑动冲突</h5><ol><li><p>常见的滑动冲突场景</p><ol><li><p>外部滑动方向和内部滑动方向不一致</p><p><img src="https://gitee.com/domeofheaven2017/Image/raw/master/BlogImage/图3-5常见滑动冲突场景1.png" srcset="/img/loading.gif" alt="图3-5常见滑动冲突场景1"></p></li><li><p>外部滑动方向和内部滑动方向一致</p><p><img src="https://gitee.com/domeofheaven2017/Image/raw/master/BlogImage/图3-6常见滑动冲突场景2.png" srcset="/img/loading.gif" alt="图3-6常见滑动冲突场景2"></p></li><li><p>上面两种情况的嵌套</p><p><img src="https://gitee.com/domeofheaven2017/Image/raw/master/BlogImage/图3-7常见滑动冲突场景3.png" srcset="/img/loading.gif" alt="图3-7常见滑动冲突场景3"></p></li></ol></li><li><p>滑动冲突的处理规则</p><ul><li>第一种滑动冲突：根据滑动时水平滑动还是竖直滑动来判断由谁拦截事件。</li><li>第二种滑动冲突：根据实际业务需求来进行处理</li><li>第三种滑动冲突：与第二种一致</li></ul></li><li><p>滑动冲突的解决方式</p><ol><li><p>外部拦截法</p><p>点击事件都先经过父容器的拦截处理，根据父容器的需求即可解决滑动冲突</p></li><li><p>内部拦截法</p><p>父容器不拦截任何事件，所有的事件都传递给子元素，子元素可以直接消耗掉或者交由父容器进行处理。需要配合<code>requestDisallowInterceptTouchEvent</code>方法才能正常工作。</p></li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Android开发艺术探索-第三章笔记&quot;&gt;&lt;a href=&quot;#Android开发艺术探索-第三章笔记&quot; class=&quot;headerlink&quot; title=&quot;Android开发艺术探索 第三章笔记&quot;&gt;&lt;/a&gt;Android开发艺术探索 第三章笔记&lt;/h3&gt;&lt;h4 i
      
    
    </summary>
    
      <category term="Android开发艺术探索" scheme="http://yoursite.com/categories/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Android开发艺术探索-IPC机制</title>
    <link href="http://yoursite.com/2020/07/05/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-IPC%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2020/07/05/Android开发艺术探索-IPC机制/</id>
    <published>2020-07-05T13:45:05.000Z</published>
    <updated>2020-08-16T03:05:31.323Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Android开发艺术探索-第二章笔记"><a href="#Android开发艺术探索-第二章笔记" class="headerlink" title="Android开发艺术探索 第二章笔记"></a>Android开发艺术探索 第二章笔记</h3><h4 id="第二章-IPC机制"><a href="#第二章-IPC机制" class="headerlink" title="第二章  IPC机制"></a>第二章  IPC机制</h4><ol><li><h5 id="Android-IPC-简介"><a href="#Android-IPC-简介" class="headerlink" title="Android IPC 简介"></a>Android IPC 简介</h5><p>IPC：Inter-Process Communication的缩写，意思为进程间通信或者跨进程通信，指两个进程之间进行数据交换的过程。</p><p>线程：CPU调度的最小单元，是一种有限的系统资源。</p><p>进程：一般指一个执行单元，在PC和移动设备上指一个程序或者应用。一个进程可以包含多个线程。</p></li><li><h5 id="Android中的多进程模式"><a href="#Android中的多进程模式" class="headerlink" title="Android中的多进程模式"></a>Android中的多进程模式</h5><ol><li><p>开启多进程模式</p><p>在Android中使用多进程只有一个方法，那就是给<strong>四大组件</strong>在<strong>AndroidManifest</strong>中指定<em>android:process</em>属性。</p><blockquote><p>进程名以“：”开头的进程属于当前应用的私有进程，其他应用的组件不可以和它在同一进程中，而进程名不以“：”开头的进程属于全局进程，其他应用可以通过ShareUID方式和它在同一进程中。Android系统会为每个应用分配一个唯一的UID，具有相同UID的应用才能共享数据。(两个应用通过<strong>ShareUID</strong>在同一个进程张，不但<strong>ShareUID</strong>要相同，签名也必须相同才可以互相访问数据)</p></blockquote></li><li><p>多进程模式运行机制</p><p>多进程造成的问题：</p><ol><li>静态成员和单例模式完全失效。</li><li>线程同步机制完全失效。</li><li><strong>SharedPreferences</strong>的可靠性下降。</li><li><strong>Application</strong>会多次创建。</li></ol><blockquote><p>在多进程模式中，不同进程的组件会拥有独立的虚拟机，Application以及内存空间。</p></blockquote></li></ol></li><li><h5 id="IPC基础概念介绍"><a href="#IPC基础概念介绍" class="headerlink" title="IPC基础概念介绍"></a>IPC基础概念介绍</h5><ol><li><p>Serializable接口：Java所提供的一个序列化接口，是一个空接口，为对象提供序列化和反序列化操作。</p><p>实现只要实现该接口，并且在类的声明中指定下面的标识即可自动实现默认的序列化操作。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span></span>&#123;     <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">871136882100083044L</span>     <span class="hljs-keyword">private</span> String userName;     <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> isMale;     ...  』</code></pre><pre><code class="hljs java"><span class="hljs-comment">//序列化操作</span>User user = <span class="hljs-keyword">new</span> User(<span class="hljs-string">"Stephanie"</span>,<span class="hljs-keyword">false</span>);ObjectOutputStream out = <span class="hljs-keyword">new</span> ObjectOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">"cache.txt"</span>));out.writeObject(user);out.close<span class="hljs-comment">//反序列化操作</span>ObjectInputStream in = <span class="hljs-keyword">new</span> ObjectInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">"cache.txt"</span>));User user = (User)in.readObject();in.close();</code></pre><blockquote><p>serialVersionUID工作机制：序列化时系统会将当前类的serialVersionUID写入序列化的文件中，当反序列化时系统会去检测文件中的serialVersionUID，看它是否和当前类的serialVersionUID一致，一致则说明版本相同可以成功反序列化；否则无法正常反序列化</p><p>Notice: </p><ol><li>静态成员变量属于类不属于对象，所以不会参与序列化过程；</li><li>用<strong>transient</strong>关键字标记的成员变量不参与序列化过程。</li><li>通过重写<strong>readObject()</strong>和<strong>writeObject()</strong>方法可以改变系统的默认序列化过程。</li></ol></blockquote></li><li><p>Parcelable接口：Android提供的新的序列化方式。</p><pre><code class="hljs java"><span class="hljs-comment">//实现Parcelable典型用法</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Parcelable</span></span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> userId;    <span class="hljs-keyword">public</span> String userName;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> isMale;    <span class="hljs-keyword">public</span> Book book;    <span class="hljs-comment">//构造方法</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(<span class="hljs-keyword">int</span> UserId,String userName,<span class="hljs-keyword">boolean</span> isMale)</span></span>&#123;        <span class="hljs-keyword">this</span>.userId = userId;        <span class="hljs-keyword">this</span>.userName = userName;        <span class="hljs-keyword">this</span>.isMale = isMale;    &#125;    <span class="hljs-comment">//返回当前对象的内容描述，含文件描述符返回1，否则返回0</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">describeContents</span><span class="hljs-params">()</span></span>&#123;        reaturn <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">//将当前对象写入序列化结构中，flags标识有两种值(0,1),为1时标识当前对象需要作为返回值返回，不能     //立即释放资源</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeToParcel</span><span class="hljs-params">(Parcel out,<span class="hljs-keyword">int</span> flags)</span></span>&#123;        out.writeInt(userId);        out.writeString(userName);        out.writeInt(isMale ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);        out.writeParcelable(book,<span class="hljs-number">0</span>);    &#125;    <span class="hljs-comment">//实现反序列化功能</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Parcelable.Creator&lt;User&gt; CREATER = <span class="hljs-keyword">new</span> Parcelable.Creator&lt;User&gt;()&#123;        <span class="hljs-comment">//从序列化后的对象中创建原始对象</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">createrFromParcel</span><span class="hljs-params">(Parcel in)</span></span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User(in);        &#125;        <span class="hljs-comment">//创建指定长度的原始对象数组</span>        <span class="hljs-keyword">public</span> User[] newArray(<span class="hljs-keyword">int</span> size)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User[size];        &#125;    &#125;;    <span class="hljs-comment">//</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">User</span><span class="hljs-params">(Parcel in)</span></span>&#123;        userId = in.readInt();        userName = in.readString();        isMale = in.readInt() == <span class="hljs-number">1</span>;        book = in.readParcelable(Thread.currentThread().getContextClassLoader());    &#125;&#125;</code></pre><blockquote><p><strong>Parcelable</strong> 和<strong>Serializable</strong>选取：</p><p>Serializable是Java中的序列化接口，使用简单但需要大量I/O操作，开销很大；Parcelable使用较麻烦但在Android平台上效率很高，所以首选<strong>Parcelable</strong>接口。</p></blockquote></li><li><p>Binder:Binder是Android中的一种跨进程通信方式。在Android开发中，Binder主要用于Service中，包括AIDL和Messenger。</p><blockquote><ol><li>当客户端发起远程请求时，由于当前线程会被挂起直至服务端进程返回数据，所以不能在UI线程中发起耗时的远程请求；</li><li>由于服务打的Binder方法运行在Binder的线程池中，所以Binder方法不管是否耗时都应该采用同步的方法去实现。</li></ol></blockquote><p><img src="https://gitee.com/domeofheaven2017/Image/raw/master/BlogImage/图2-1Binder的工作机制.png" srcset="/img/loading.gif" alt="图2-1Binder的工作机制"><br>Binder实现步骤</p><ol><li>声明一个AIDL性质的接口，只需继承<strong>IInterface</strong>接口</li><li>实现<strong>Stub</strong>类和Stub类的<strong>Proxy</strong>代理类</li></ol></li><li><p>给Binder设置死亡代理：</p><ol><li><p>声明一个<strong>Deathecipient</strong>对象。<strong>Deathecipient</strong>是一个接口，我们需要实现其内部的回调方法<strong>binderDied</strong></p><pre><code class="hljs java"><span class="hljs-keyword">private</span> IBinder.DeathRecipient mDeathRecipient = <span class="hljs-keyword">new</span> IBinder.DeathRecipient()&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">binderDied</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">if</span>(mBookManager == <span class="hljs-keyword">null</span>)            <span class="hljs-keyword">return</span>;      mBookManager.asBinder().unlinkToDeath(mDeathRecipient,<span class="hljs-number">0</span>);      mBookManager = <span class="hljs-keyword">null</span>;    &#125;&#125;</code></pre></li><li><p>在客户端绑定远程服务成功后，给binder设置死亡代理</p><pre><code class="hljs java">mService  = IMessageBoxManager.Stub.asInterface(binder);binder.linkToDeath(mDeathRecipient,<span class="hljs-number">0</span>);</code></pre></li></ol><blockquote><p>通过Binderd方法<strong>isBinderAlive</strong>可以判断Binder是否死亡        </p></blockquote></li></ol></li><li><h5 id="Android中IPC方式"><a href="#Android中IPC方式" class="headerlink" title="Android中IPC方式"></a>Android中IPC方式</h5><ol><li><p>使用Bundle</p><p>四大组件中的三大组件(Activity，Service，Receiver)都是支持Intent中传递Bundle数据的，由于Bundle实现了Parcelable接口，所以它可以在不同的进程之间传输。但是，传输的数据必须能够被序列化，比如基本类型和实现了Parcelable接口的对象。</p></li><li><p>使用文件共享</p><p>即两个进程通过<strong>读/写</strong>同一个文件来交换数据。除了可以交换一些文本信息外，还可以序列化一个对象到文件系统的同时另一个进程中恢复这个对象。</p><pre><code class="hljs java"><span class="hljs-comment">//MainActivity</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">persistToFile</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable()&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;            User user = <span class="hljs-keyword">new</span> User(<span class="hljs-number">1</span>,<span class="hljs-string">"hello world"</span>,<span class="hljs-keyword">false</span>);            File dir = <span class="hljs-keyword">new</span> File(MyConstants.CHAPTER_2_PATH);            <span class="hljs-keyword">if</span>(!dir.exists())&#123;                dir.mkdirs();            &#125;            File cachedFile = <span class="hljs-keyword">new</span> File(MyConstants.CACHE_FILE_PATH);            ObjectOutputStream objectOutputStream = <span class="hljs-keyword">null</span>;            <span class="hljs-keyword">try</span>&#123;                objectOutputStream = <span class="hljs-keyword">new</span> ObjectOutputStream(<span class="hljs-keyword">new</span>                                                                FileOutputStream(cacheFile));                objectOutputStream.writeObject(user);                Log.d(TAG,<span class="hljs-string">"persist user : "</span> + user);            &#125;<span class="hljs-keyword">catch</span>(IOException e)&#123;                e.printStackTrace();            &#125;<span class="hljs-keyword">finally</span>&#123;                MyUtils.close(objectOutputStream);            &#125;        &#125;    &#125;).start();&#125;<span class="hljs-comment">//SecondActivity</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">recoverFromFile</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable()&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;            User user = <span class="hljs-keyword">null</span>;            File cachedFile = <span class="hljs-keyword">new</span> File(MyConstants.CACHE_FILE_PATH);            <span class="hljs-keyword">if</span>(cachedFile.exists())&#123;                ObjectInputStream objectInputStream = <span class="hljs-keyword">null</span>;                <span class="hljs-keyword">try</span>&#123;                    objectInputStream = <span class="hljs-keyword">new</span> ObjectInputStream(<span class="hljs-keyword">new</span> FileInputStream(                                                                 cachedFile));                    user = (User) objectInputStream.readObject();                    Log.d(TAG,<span class="hljs-string">"recover user :"</span>+user);                &#125;<span class="hljs-keyword">catch</span>(IOException)&#123;                    e.printStackTrace();                &#125;<span class="hljs-keyword">catch</span>(ClassNotFoundException e)&#123;                    e.printStackTrace();                &#125;<span class="hljs-keyword">finally</span>&#123;                    MyUtils.close(objectInputStream);                &#125;            &#125;        &#125;    &#125;).start();&#125;</code></pre><blockquote><p>文件共享方式适合在对数据同步要求不高的进程之间进行通信，并且要妥善处理<strong>并发读/写</strong>的问题。</p></blockquote></li><li><p>使用Messenger</p><p>译为“信使”，可以在Message中放入需要传递的数据，通过它在不同进程中传递Message对象。它的底层实现是AIDL</p><pre><code class="hljs java"><span class="hljs-comment">//Messenger的构造方法</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Messenger</span><span class="hljs-params">(Handler target)</span></span>&#123;    mTarget = target.getIMessenger();&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Messenger</span><span class="hljs-params">(IBinder target)</span></span>&#123;    mTarget = IMessenger.Stub.asInterface(target);&#125;</code></pre><blockquote><p>Messenger一次处理一个请求，因此在服务端不用考虑线程同步的问题</p></blockquote><p>实现Messenger的步骤：</p><ol><li><p>服务端进程</p><p>首先在服务端创建一个Service来处理客户端的连接请求，同时创建一个Handler并通过它来创建    Messenger对象，然后在Service的onBind中返回Messenger对象底层的Binder。</p></li><li><p>客户端进程</p><p>首先绑定服务端的Service，绑定成功后用服务端返回的IBinder对象创建一个Messenger，通过这个Messenger就可以向服务端发送Message对象。</p><pre><code class="hljs java"><span class="hljs-comment">//服务端</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessengerService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Service</span></span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String TAG = <span class="hljs-string">"MessengerService"</span>;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessengerHandler</span> <span class="hljs-title">extend</span> <span class="hljs-title">Handler</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(Message msg)</span></span>&#123;        <span class="hljs-keyword">switch</span>(msg.what)&#123;          <span class="hljs-keyword">case</span> MyConstants.MSG_FROM_CLIENT:            Log.i(TAG,<span class="hljs-string">"receive msg from client : "</span>+msg.getData().getString(<span class="hljs-string">"msg"</span>));            <span class="hljs-keyword">break</span>;          <span class="hljs-keyword">default</span>:            <span class="hljs-keyword">super</span>.handleMessage(msg);        &#125;    &#125;&#125;&#125;</code></pre><pre><code class="hljs xml">//注册Service<span class="hljs-tag">&lt;<span class="hljs-name">service</span>         <span class="hljs-attr">android:name</span> = <span class="hljs-string">"com.ryg.chapter_2.messenger.MessengerService"</span>         <span class="hljs-attr">android:process</span> = <span class="hljs-string">":remote"</span>&gt;</span></code></pre><pre><code class="hljs java"><span class="hljs-comment">//客户端</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessengerActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Activity</span></span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String TAG = <span class="hljs-string">"MessengerActivity"</span>;    <span class="hljs-keyword">private</span> Messenger mService;    <span class="hljs-keyword">private</span> ServicerConnection mConnection = <span class="hljs-keyword">new</span> ServiceConnection()&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onServiceConnected</span><span class="hljs-params">(ComponentName className,IBinder service)</span></span>&#123;            mService = <span class="hljs-keyword">new</span> Messenger(service);            Message msg = Message.obtain(<span class="hljs-keyword">null</span>,<span class="hljs-string">"MyConstants.MSG_FROM_CLIENT"</span>);            Bundle data = <span class="hljs-keyword">new</span> Bundle();            data.putString(<span class="hljs-string">"msg"</span>,<span class="hljs-string">"hello ,this is client."</span>);            msg.setData(data);            <span class="hljs-keyword">try</span>&#123;                mService.send(msg);            &#125;<span class="hljs-keyword">catch</span>(RemoteException e)&#123;                e.printStackTrace();            &#125;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onServiceDisconnected</span><span class="hljs-params">(ComponentName className)</span></span>&#123;&#125;    &#125;;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span></span>&#123;        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);        setContentView(R.layout.activity_messenger);        Intent intent = <span class="hljs-keyword">new</span> Intent(<span class="hljs-keyword">this</span>,MessengerService.class);        bindService(intent,mConnection,Conatext.BIND_AUTO_CREATE);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDestroy</span><span class="hljs-params">()</span></span>&#123;        unbindService(mConnection);        <span class="hljs-keyword">super</span>.onDestroy();    &#125;&#125;</code></pre></li></ol></li><li><p>使用AIDL</p><p>AIDL的使用流程:</p><ol><li><p>服务端</p><ul><li>创建一个Service用来监听客户端的连接</li><li>创建一个AIDL文件声明给客户端的接口</li><li>在Service中实现这个AIDL接口</li></ul></li><li><p>客户端</p><ul><li>需要绑定服务端的Service</li><li>绑定成功后将服务端返回的Binder对象转换成AIDL接口所属的类型</li></ul></li><li><p>AIDL接口的创建</p><pre><code class="hljs java"><span class="hljs-comment">//IBookManager.aidl</span><span class="hljs-keyword">package</span> com.ryg.chapter_2.aidl<span class="hljs-keyword">import</span> com.ryg.chapter_2.aidl.Book;<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IBookManager</span></span>&#123;  <span class="hljs-function">List&lt;Book&gt; <span class="hljs-title">getBookList</span><span class="hljs-params">()</span></span>;  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addBook</span><span class="hljs-params">(in Book book)</span></span>;&#125;</code></pre><p>AIDL文件支持的数据类型</p><ul><li>基本数据类型(int , long , char , boolean , double等);</li><li>String和CharSequence;</li><li>List:只支持<strong>ArrayList</strong>,并且里面的每个元素都必须能够被AIDL支持；</li><li>Map:只支持<strong>Hashap</strong>，并且里面的每个元素都必须能够被AIDL支持；</li><li>Parcelabel：所有实现了Parcelable接口的对象；</li><li>AIDL：所有的AIDL接口本身也可以在AIDL文件中使用。</li></ul><blockquote><p>自定义的Parcelable对象和AIDL对象必须要显式<strong>import</strong>进来，无论它是否与当前AIDL文件位于同一个包内。</p><p>如果AIDL文件中用到了自定义的Parcelable对象，必须新建一个和它同名的AIDL文件，并在其中声明它为Parcelabel类型。</p><p>AIDL中除了基本数据类型，其他类型的参数必须标上方向：in，out，inout</p><p>AIDL中的定向 tag 表示了在跨进程通信中数据的流向,数据流向是针对在客户端中的那个传入方法的对象而言的。</p><p>​         in： 表示数据只能由客户端流向服务端</p><p>​         out：表示数据只能由服务端流向客户端</p><p>​         inout：表示数据可在服务端与客户端之间双向流通     </p></blockquote></li><li><p>远程服务端Service的实现</p><pre><code class="hljs java"><span class="hljs-comment">//服务端Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookManagerService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Service</span></span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String TAG = <span class="hljs-string">"BMS"</span>;    <span class="hljs-comment">//CopyOnWriteArrayList:支持并发读/写。</span>    <span class="hljs-keyword">private</span> CopyOnWriteArrayList&lt;Book&gt; mBookList = <span class="hljs-keyword">new</span> CopyOnWriteArrayList&lt;Book&gt;();    <span class="hljs-keyword">private</span> Binder mBinder = <span class="hljs-keyword">new</span> IBookManager.Stub()&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Book&gt; <span class="hljs-title">getBookList</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> RemoteException</span>&#123;            <span class="hljs-keyword">return</span> mBookList;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addBook</span><span class="hljs-params">(Book book)</span><span class="hljs-keyword">throws</span> RemoteException</span>&#123;            mBookList.add(Book);        &#125;    &#125;;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">super</span>.onCreate();        mBookList.add(<span class="hljs-keyword">new</span> Book(<span class="hljs-number">1</span>,<span class="hljs-string">"Android"</span>));        mBookList.add(<span class="hljs-keyword">new</span> Book(<span class="hljs-number">2</span>,<span class="hljs-string">"IOS"</span>));    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> IBinder <span class="hljs-title">onBind</span><span class="hljs-params">(Intent intent)</span></span>&#123;        <span class="hljs-keyword">return</span> mBinder;    &#125;&#125;</code></pre><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">service</span>         <span class="hljs-attr">android:name</span>=<span class="hljs-string">".aidl.BookManagerService"</span>         <span class="hljs-attr">android:process</span>=<span class="hljs-string">":remote"</span>/&gt;</span></code></pre></li><li><p>客户端的实现</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookManagerActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Activity</span></span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String TAG = <span class="hljs-string">"BookManagerActivity"</span>;    <span class="hljs-keyword">private</span> ServiceConnection mConnection = <span class="hljs-keyword">new</span> ServiceConnection()&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onServiceConnected</span><span class="hljs-params">(ComponentName className,IBinder service)</span></span>&#123;            IBookManager bookManager = IBookManager.Stub.asInterface(service);            <span class="hljs-keyword">try</span>&#123;                List&lt;Book&gt; list = bookManager.getBookList();                Log.i(TAG,<span class="hljs-string">"query book list ,list"</span>+                                                  <span class="hljs-string">"type:"</span>+list.getClass().getCanonicalName());                Log.i(TAG,<span class="hljs-string">"query book list :"</span>+list.toString());            &#125;<span class="hljs-keyword">catch</span>(RemoteException e)&#123;                e.printStackTrace();            &#125;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onServiceDisconnected</span><span class="hljs-params">(ComponentName className)</span></span>&#123;&#125;    &#125;;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span></span>&#123;        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);        setContentView(R.layout.activity_book_manager);        Intent intent = <span class="hljs-keyword">new</span> Intent(<span class="hljs-keyword">this</span>,BookManagerService.class);        bindService(intent,mConnection,Context.BIND_AUTOCREATE);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDestroy</span><span class="hljs-params">()</span></span>&#123;        unbindService(mConnection);        <span class="hljs-keyword">super</span>.onDestroy();                                              &#125;&#125;</code></pre></li></ol></li></ol></li></ol><pre><code>6. 解除监听   `RemoteCallbackList`是系统提供的用于删除跨进程Listener的接口   <pre><code class="hljs java"><span class="hljs-comment">//声明RemoteCalbackList</span>   <span class="hljs-keyword">private</span> RemoteCallbackList&lt;IOnNewBookListener&gt; mListenerList = <span class="hljs-keyword">new</span> RemoteCallbackList&lt;&gt;();   <span class="hljs-comment">//修改注册和注销方法</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerListener</span><span class="hljs-params">(IOnNewBookListener listener)</span> <span class="hljs-keyword">throws</span> RemoteException</span>&#123;    mListener.register(listener);   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unregisterListener</span><span class="hljs-params">(IOnNewBookListener listener)</span> <span class="hljs-keyword">throws</span> RemoteException</span>&#123;       mListener.unregister(listener);&#125;   <span class="hljs-comment">//通知Listener</span><span class="hljs-keyword">int</span> N = mListenerList.beginBroadcast();   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;    IOnNewBookListener l = mListenerList.getBroadcastItem(i);       <span class="hljs-keyword">if</span>(l != <span class="hljs-keyword">null</span>)&#123;           ......       &#125;   &#125;   mListenerList.finishBroadcast();</code></pre>   &gt; RemoteCallbackList并不是一个List,遍历时必须按照上述流程进行，`beginBroadcast`和`finishBroadcast`必须要配对使用。   &gt;   &gt; 客户端的`onServiceConnected`和`onServiceDisconnected`方法都运行在主线程，不能在其中直接调用服务端的耗时方法。   &gt;   &gt; `onServiceDiscnnected`在客户端的UI线程中被回调，而`binderDied`在客户端的Binder线程池中被回调7. 在AIDL中进行权限验证   - 在onBind中进行验证   - 在服务端的onTransact方法中进行验证</code></pre><ol start="5"><li><p>使用ContentProvider</p><p>ContentProvider是Android中提供的用于不同应用间进行数据共享的方式,其底层实现是Binder。</p><p>自定义ContentProvider步骤：</p><ul><li>继承自ContentProvider类</li><li>实现其中的抽象方法：onCreate,query,update,insert,delete和getType。</li><li>注册这个类</li></ul><blockquote><p>与query方法不同的是，update,insert和delete方法会引起数据源的改变，需要通过ContentResolver的<strong>notifyhange</strong>方法进行更新。</p><p>要观察一个ContentProvider中的数据变化，可以通过ContentResolver的registerContentObserver方法注册观察者，用unregisterContentObserver来进行解除。</p></blockquote></li><li><p>使用Socket</p><p>Socket，也称为“套接字”，它分为<strong>流式套接字</strong>和<strong>用户数据报套接字</strong>，分别对应与网络传输控制层中的<strong>TCP</strong>和<strong>UDP</strong>协议。两个进程可以通过Socket来实现信息的传输，Socket本身可以支持传输任意字节流。</p><p>Socket连接过程</p><p><img src="https://gitee.com/domeofheaven2017/Image/raw/master/BlogImage/socket_connect.png" srcset="/img/loading.gif" alt></p></li></ol><ol start="5"><li><h5 id="Binder连接池"><a href="#Binder连接池" class="headerlink" title="Binder连接池"></a>Binder连接池</h5><p>将每个业务模块的Binder请求统一转发到远程Service中去执行，从而避免了重复创建Service。</p></li><li><h5 id="选用合适的IPC方式"><a href="#选用合适的IPC方式" class="headerlink" title="选用合适的IPC方式"></a>选用合适的IPC方式</h5><p>| 名称              | 优点                                | 缺点                                       | 适用场景                               |<br>| ————— | ——————————— | —————————————- | ———————————- |<br>| Bundle          | 简单易用                              | 只能传输Bundle支持的数据类型                        | 四大组件间的进程间通信                        |<br>| 文件共享            | 简单易用                              | 不适合高并发场景，并且无法做到进程间的即时通信                  | 无并发访问情形，交换简单的数据实时性不高的场景            |<br>| AIDL            | 功能强大                              | 使用稍复杂，需要处理好线程同步                          | 一对多通信且有RPC需求                       |<br>| Messenger       | 功能一般，支持一对多串行通信，支持实时通信             | 不能很好处理高并发，不支持RPC，数据只能通过Message传输Bundle支持的数据类型 | 低并发的一对多即时通信，无RPC需求，或者无须要返回结果的RPC需求 |<br>| ContentProvicer | 数据源访问功能强大，支持一对多并发数据共享，可通过Call方法扩展 | 可以理解为受约束的AIDL，主要提供数据源的CRUD操作             | 一对多的进程间的数据共享                       |<br>| Socket          | 功能强大，可以通过网络传输字节流，支持一对多并发实时通信      | 实现细节稍繁琐，不支持直接的RPC                        | 网络数据交换                             |</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Android开发艺术探索-第二章笔记&quot;&gt;&lt;a href=&quot;#Android开发艺术探索-第二章笔记&quot; class=&quot;headerlink&quot; title=&quot;Android开发艺术探索 第二章笔记&quot;&gt;&lt;/a&gt;Android开发艺术探索 第二章笔记&lt;/h3&gt;&lt;h4 i
      
    
    </summary>
    
      <category term="Android开发艺术探索" scheme="http://yoursite.com/categories/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Android开发艺术探索-Activity 的生命周期和启动模式</title>
    <link href="http://yoursite.com/2020/06/27/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-Activity%20%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/06/27/Android开发艺术探索-Activity 的生命周期和启动模式/</id>
    <published>2020-06-27T12:05:17.000Z</published>
    <updated>2020-08-16T03:06:05.116Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Android-开发艺术探索-第一章笔记"><a href="#Android-开发艺术探索-第一章笔记" class="headerlink" title="Android 开发艺术探索 第一章笔记"></a>Android 开发艺术探索 第一章笔记</h3><h4 id="第一章-Activity-的生命周期和启动模式"><a href="#第一章-Activity-的生命周期和启动模式" class="headerlink" title="第一章  Activity 的生命周期和启动模式"></a>第一章  Activity 的生命周期和启动模式</h4><h5 id="Activity-的生命周期"><a href="#Activity-的生命周期" class="headerlink" title="Activity 的生命周期"></a>Activity 的生命周期</h5><ol><li><h5 id="典型情况下的生命周期-在用户参与的情况下，Activity-所经过的生命周期的改变"><a href="#典型情况下的生命周期-在用户参与的情况下，Activity-所经过的生命周期的改变" class="headerlink" title="典型情况下的生命周期 : 在用户参与的情况下，Activity 所经过的生命周期的改变"></a>典型情况下的生命周期 : 在用户参与的情况下，Activity 所经过的生命周期的改变</h5><ol><li>onRestart:Activity 正在重新启动。</li><li>onCreate:Activity 正在被创建。可以在这个方法中进行初始化工作，比如加载界面布局资源，初始化数据等。</li><li>onStart:Activity 正在被启动，此时 Activity 已经<strong>可见</strong>，但是<strong>没有出现在前台</strong>，无法和用户进行交互。</li><li>onResume:Activity 已经可见，且<strong>出现在前台开始活动</strong>。</li><li>onPause:Activity 正在停止。</li><li>onStop:Activity 即将停止，可以做一些回收工作，但不能太耗时。</li><li><p>onDestroy:Activity 即将被销毁，生命周期最后一个回调，可以做一些回收工作和最终资源的释放。</p><p><img src="https://gitee.com/domeofheaven2017/Image/raw/master/BlogImage/图1-1Activity生命周期切换过程.png" srcset="/img/loading.gif" alt="图1-1Activity生命周期切换过程"></p></li></ol><blockquote><p>(1) 一个 Activity 第一次启动时的回调为:onCreate-&gt;onStart-&gt;onResume</p><p>(2)打开新的 Activity 或切换到桌面时的回调为:onPause-&gt;onStop(如果新 Activity 采用了透明主题，则不会调用 onStop)</p><p>(3)再次回到原 Activity 时的回调为:onRestart-&gt;onStart-&gt;onResume</p><p>(4)使用 back 键回退时的回调:onPause-&gt;onStop-&gt;onDestroy</p></blockquote></li></ol><h6 id="Remarks-onStart-和-onStop-是从-Activity-是否可见的角度进行回调的-onResume-和-onPause-是从-Activity-是否位于前台的角度。"><a href="#Remarks-onStart-和-onStop-是从-Activity-是否可见的角度进行回调的-onResume-和-onPause-是从-Activity-是否位于前台的角度。" class="headerlink" title="Remarks:onStart 和 onStop 是从 Activity 是否可见的角度进行回调的;onResume 和 onPause 是从 Activity 是否位于前台的角度。"></a>Remarks:onStart 和 onStop 是从 Activity 是否可见的角度进行回调的;onResume 和 onPause 是从 Activity 是否位于前台的角度。</h6><ol start="2"><li><h5 id="异常情况下的生命周期-Activity-被系统回收或者当前设备的-Configuration-发生改变而导致-Activity-被销毁重建"><a href="#异常情况下的生命周期-Activity-被系统回收或者当前设备的-Configuration-发生改变而导致-Activity-被销毁重建" class="headerlink" title="异常情况下的生命周期 : Activity 被系统回收或者当前设备的 Configuration 发生改变而导致 Activity 被销毁重建"></a>异常情况下的生命周期 : Activity 被系统回收或者当前设备的 Configuration 发生改变而导致 Activity 被销毁重建</h5><ol><li>资源相关的系统配置发生改变导致 Activity 被杀死并重新创建</li><li><p>资源内存不足导致低优先级的 Activity 被杀死</p><p>Activity 优先级情况(由高到低)</p><ul><li>前台 Activity ——正在与用户交互的 Activity，优先级最高</li><li>可见但非前台 Activity</li><li>后台 Activity ——已经被暂停的 Activity</li></ul></li></ol></li></ol><h5 id="Activity-的启动模式"><a href="#Activity-的启动模式" class="headerlink" title="Activity 的启动模式"></a>Activity 的启动模式</h5><ol><li><h5 id="Activity-的-LaunchMode"><a href="#Activity-的-LaunchMode" class="headerlink" title="Activity 的 LaunchMode"></a>Activity 的 LaunchMode</h5><ol><li><strong>standard</strong>:标准模式。每次启动一个 Activity 都会重新创建一个新的实例，不管这个实例是否已经存在。<em>在这种模式下，谁启动了这个 Activity，那么这个 Activity 就运行在启动它的那个 Activity 所在的栈中。</em></li><li><strong>singleTop</strong>:栈顶复用模式。在这种模式下，如果新的 Activity 已经位于任务栈的栈顶，那么此 Activity 不会被重新创建，同时它的 onNewIntent 方法会被回调，并且这个 Activity 的 onCreate,onStart 不会被系统调用;如果新 Activity 的实例已存在但不是位于栈顶，那么新 Activity 仍然会重新创建。</li><li><strong>singleTask</strong>:栈内复用模式。这是一种单实例模式，在这种模式下，只要 Activity 在一个栈中存在，那么多次启动此 Activity 都不会重新创建实例。</li><li><p><strong>singleInstance</strong>:单实例模式。除了具有 singleTask 模式的所有特性外，在这种模式下的 Activity 只能单独地位于一个任务栈中。</p><p><em>TaskAffinity:任务相关性。这个参数标识了一个 Activity 所需要的任务栈的名字，默认情况下为应用的包名。TaskAffinity 属性主要和 singleTask 启动模式或者 AllowTaskReparenting 属性配对使用；任务栈分为前台任务栈和后台任务栈，后台任务栈中的 Activity 处于暂停状态。</em></p></li></ol></li><li><h5 id="给-Activity-指定启动模式"><a href="#给-Activity-指定启动模式" class="headerlink" title="给 Activity 指定启动模式"></a>给 Activity 指定启动模式</h5><ol><li><p>通过 <strong>AndroidManifest</strong> 文件给 Activity 指定启动模式</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">activity</span>          <span class="hljs-attr">android:name</span>=<span class="hljs-string">"com.ryg.chapter_1.secondActivity"</span>          <span class="hljs-attr">android:configChanges</span>=<span class="hljs-string">"screenLayout"</span>          <span class="hljs-attr">android:launchMode</span>=<span class="hljs-string">"singleTask"</span>          <span class="hljs-attr">android:label</span>=<span class="hljs-string">"@string/app_name"</span>/&gt;</span></code></pre></li><li><p>通过在 <strong>Intent</strong> 中设置标志位为 Activity 指定启动模式</p><pre><code class="hljs java">Intent intent = <span class="hljs-keyword">new</span> Intent();intent.setClass(MainActivity.<span class="hljs-keyword">this</span>,SecondActivity.class);intent.addFlags(Intetn.FLAG_ACTIVITY_NEW_TASK);startActivity(intent);</code></pre><blockquote><p>两种方式的区别：</p><ol><li>第二种的优先级要高于第一种，当两种同时存在时，以第二种方式为准；</li><li>第一种方式无法直接为 Activity 设定 <strong>FLAG_ACTIVITY_CLEAR_TOP</strong> 标识，而第二种方式无法为 Activity 指定 <strong>singlenstance</strong> 模式</li></ol></blockquote></li></ol></li><li><h5 id="Activity的Flags"><a href="#Activity的Flags" class="headerlink" title="Activity的Flags"></a>Activity的Flags</h5><ul><li>FLAG_ACTIVITY_NEW_TASK:为Activity指定“singleTask”启动模式</li><li>FLAG_ACTIVITY_SINGLE_TOP:为Activity指定“singleTop”启动模式</li><li>FLAG_ACTIVITY_CLEAR_TOP:具有此标记位的Activity启动时，在同一个任务栈中所有位于它上面的Activity都要出栈</li><li>FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS:具有此标记的Activity不会出现在历史Activity的列表中。</li></ul></li><li><h5 id="IntentFilter-的匹配规则"><a href="#IntentFilter-的匹配规则" class="headerlink" title="IntentFilter 的匹配规则"></a>IntentFilter 的匹配规则</h5><ol><li>action(字符串)的匹配规则：<strong>Intent</strong> 中的 action 必须能够和过滤规则中的 action 匹配，即 action 的字符串值完全一样。一个过滤规则中可以有多个 action，只要 <strong>Intent</strong> 中的 action 能够和过滤规则中的任何一个 action 相同即可匹配成功。但如果 <strong>Intent</strong> 中没有指定 action，则匹配失败，并且 action 区分大小写。</li><li>category(字符串)的匹配规则：它要求 <strong>Intent</strong> 中如果含有 category，那么所有的 category 都必须和过滤规则中的其中一个 category 相同。如果 Intent 中没有，仍然可以匹配成功。</li><li><p>data 的匹配规则</p><ol><li><p>结构：由 <em>mimeType</em> 和 <em>URI</em> 两部分组成。其中 <em>mimeType</em> 指的是媒体类型，<em>URI</em> 是资源地址。</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 语法 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">data</span> <span class="hljs-attr">android:scheme</span>=<span class="hljs-string">"string"</span>      <span class="hljs-attr">android:host</span>=<span class="hljs-string">"string"</span>      <span class="hljs-attr">android:port</span>=<span class="hljs-string">"string"</span>      <span class="hljs-attr">android:path</span>=<span class="hljs-string">"string"</span>      <span class="hljs-attr">andrid:pathPattern</span>=<span class="hljs-string">"string"</span>      <span class="hljs-attr">android:pathPrefix</span>=<span class="hljs-string">"string"</span>      <span class="hljs-attr">android:mimeType</span>=<span class="hljs-string">"string"</span> /&gt;</span><span class="hljs-comment">&lt;!-- 结构 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">scheme</span>&gt;</span>://<span class="hljs-tag">&lt;<span class="hljs-name">host</span>&gt;</span>:<span class="hljs-tag">&lt;<span class="hljs-name">port</span>&gt;</span>/[<span class="hljs-tag">&lt;<span class="hljs-name">path</span>&gt;</span>|<span class="hljs-tag">&lt;<span class="hljs-name">pathPrefix</span>&gt;</span>|<span class="hljs-tag">&lt;<span class="hljs-name">pathPattern</span>&gt;</span>]</code></pre></li></ol></li></ol></li></ol><pre><code>2. 匹配规则：Intent中必须含有data数据，并且data数据能够完全匹配过滤规则中的某一个data</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Android-开发艺术探索-第一章笔记&quot;&gt;&lt;a href=&quot;#Android-开发艺术探索-第一章笔记&quot; class=&quot;headerlink&quot; title=&quot;Android 开发艺术探索 第一章笔记&quot;&gt;&lt;/a&gt;Android 开发艺术探索 第一章笔记&lt;/h3&gt;&lt;
      
    
    </summary>
    
      <category term="Android开发艺术探索" scheme="http://yoursite.com/categories/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Markdown基本语法速查</title>
    <link href="http://yoursite.com/2020/03/27/Markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E9%80%9F%E6%9F%A5/"/>
    <id>http://yoursite.com/2020/03/27/Markdown基本语法速查/</id>
    <published>2020-03-27T13:53:39.000Z</published>
    <updated>2020-06-21T02:29:09.175Z</updated>
    
    <content type="html"><![CDATA[<h4 id="MarkDown基本语法"><a href="#MarkDown基本语法" class="headerlink" title="MarkDown基本语法"></a>MarkDown基本语法</h4><hr><ol><li><p>简介</p><blockquote><p><strong>Markdown</strong>是一种轻量级标记语言，创始人为约翰·格鲁伯（英语：John Gruber）。它允许人们使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML（或者HTML）文档。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。</p><p>由于Markdown的轻量化、易读易写特性，并且对于图片，图表、数学式都有支持，当前许多网站都广泛使用Markdown来撰写帮助文档或是用于论坛上发表消息。如GitHub、Reddit、Diaspora、Stack Exchange、OpenStreetMap 、SourceForge、简书等，甚至还能被使用来撰写电子书。</p><p>​                                                                                                                            —WikiPedia</p></blockquote></li><li><p>基本命令</p><ul><li><p>标题</p><pre><code class="hljs markdown"><span class="hljs-section"># 一级标题</span><span class="hljs-section">## 二级标题</span><span class="hljs-section">### 三级标题</span><span class="hljs-section">#### 四级标题</span><span class="hljs-section">##### 五级标题</span><span class="hljs-section">###### 六级标题</span></code></pre></li><li><p>字体</p></li></ul></li></ol><pre><code>**加粗***斜体*~~删除线~~&lt;u&gt;下划线&lt;/u&gt;`注释`==高亮==</code></pre><ul><li>列表</li></ul><pre><code>## 有序列表1. 2. 3. ## 无序列表- - - ## 任务列表- [ ] 任务1- [ ] 任务2- [x] 任务3 </code></pre><ul><li>引用</li></ul><pre><code>&gt; 这是引用部分内容</code></pre><ul><li>代码块</li></ul><pre><code>​<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123; &#125;​</code></pre></code></pre><ul><li>表格</li></ul><pre><code>| First Header  | Second Header || ------------- | ------------- || Content Cell  | Content Cell  || Content Cell  | Content Cell  |</code></pre><ul><li>目录</li></ul><pre><code>[TOC]</code></pre><ul><li><p>链接</p><ul><li>超链接</li></ul></li></ul><pre><code>  [链接名称](链接地址)- 图片链接  ![图片名称](图片地址)</code></pre><ul><li>脚注</li></ul><pre><code>You can create footnotes like this[^footnote].[^footnote]: Here is the *text* of the **footnote**.</code></pre><ul><li>Emoji表情</li></ul><pre><code>:smile::kissing_smiling_eyes::kissing_smiling_eyes:</code></pre><ul><li>视频</li></ul><pre><code>&lt;video src=&quot;xxx.mp4&quot;</code></pre><ul><li>HTML</li></ul><pre><code>&lt;span style=&quot;color:red&quot;&gt;红色的文本&lt;/span&gt;</code></pre><ol start="3"><li><p>绘制结构图</p><ul><li>流程图</li></ul></li></ol><pre><code>## Flowchart.js​<pre><code class="hljs flow">st=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op    ## Mermaid​&lt;pre class=&quot;mermaid&quot;&gt;     graph LRA[Hard edge] --&gt;B(Round edge)    B --&gt; C&#123;Decision&#125;    C --&gt;|One| D[Result one]    C --&gt;|Two| E[Result two]​&lt;/pre&gt;</code></pre></code></pre><ul><li>时序图</li></ul><pre><code>## js-sequence​<pre><code class="hljs sequence">Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks!​</code></pre>## Mermaid​&lt;pre class=&quot;mermaid&quot;&gt;     %% Example of sequence diagram  sequenceDiagram    Alice-&gt;&gt;Bob: Hello Bob, how are you?    alt is sick    Bob-&gt;&gt;Alice: Not so good :(    else is well    Bob-&gt;&gt;Alice: Feeling fresh like a daisy    end    opt Extra response    Bob-&gt;&gt;Alice: Thanks for asking    end​&lt;/pre&gt;</code></pre><ul><li>甘特图</li></ul><pre><code>## Mermaid​&lt;pre class=&quot;mermaid&quot;&gt;     %% Example with selection of syntaxes        gantt        dateFormat  YYYY-MM-DD        title Adding GANTT diagram functionality to mermaid        section A section        Completed task            :done,    des1, 2014-01-06,2014-01-08        Active task               :active,  des2, 2014-01-09, 3d        Future task               :         des3, after des2, 5d        Future task2               :         des4, after des3, 5d​&lt;/pre&gt;</code></pre><ul><li>类图</li></ul><pre><code>## Mermaid​&lt;pre class=&quot;mermaid&quot;&gt;     classDiagram      Animal &lt;|-- Duck      Animal &lt;|-- Fish      Animal &lt;|-- Zebra      Animal : +int age      Animal : +String gender      Animal: +isMammal()      Animal: +mate()      class Duck{          +String beakColor          +swim()          +quack()      }      class Fish{          -int sizeInFeet          -canEat()      }      class Zebra{          +bool is_wild          +run()      }​&lt;/pre&gt;</code></pre><ul><li>状态图</li></ul><pre><code>​&lt;pre class=&quot;mermaid&quot;&gt;     stateDiagram    [*] --&gt; Still    Still --&gt; [*]    Still --&gt; Moving    Moving --&gt; Still    Moving --&gt; Crash    Crash --&gt; [*]​&lt;/pre&gt;<pre><code class="hljs undefined">   - 饼图     ​&lt;pre class=<span class="hljs-string">"mermaid"</span>&gt;     pie         title Pie Chart         <span class="hljs-string">"Dogs"</span> : <span class="hljs-number">386</span>         <span class="hljs-string">"Cats"</span> : <span class="hljs-number">85</span>         <span class="hljs-string">"Rats"</span> : <span class="hljs-number">150</span>      ​&lt;/pre&gt;<span class="hljs-number">4.</span> 数学公式   ```markdown   ## 行内公式   <span class="hljs-symbol">$</span> a^<span class="hljs-number">2</span> + b^<span class="hljs-number">2</span> = c^<span class="hljs-number">2</span> <span class="hljs-symbol">$</span>   ## 行间公式   <span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>    y = x ^ &#123;<span class="hljs-number">2</span>&#125;    x_&#123;a + b&#125;     x^&#123;a + b&#125;   <span class="hljs-symbol">$</span><span class="hljs-symbol">$</span></code></pre></code></pre><table><thead><tr><th>符号</th><th>代码</th><th>具体含义</th></tr></thead><tbody><tr><td>$\sum$</td><td><code>$\sum$</code></td><td>求和公式</td></tr><tr><td>$\sum_{i=0}^n$</td><td><code>$\sum_{i=0}^n$</code></td><td>求和上下标</td></tr><tr><td>$\times$</td><td><code>$\times$</code></td><td>乘号</td></tr><tr><td>$\pm$</td><td><code>$\pm$</code></td><td>正负号</td></tr><tr><td>$\div$</td><td><code>$\div$</code></td><td>除号</td></tr><tr><td>$\mid$</td><td><code>$\mid$</code></td><td>竖线</td></tr><tr><td>$\cdot$</td><td><code>$\cdot$</code></td><td>点</td></tr><tr><td>$\circ$</td><td><code>$\circ$</code></td><td>圈</td></tr><tr><td>$\ast $</td><td><code>$\ast $</code></td><td>星号</td></tr><tr><td>$\bigotimes$</td><td><code>$\bigotimes$</code></td><td>克罗内克积</td></tr><tr><td>$\bigoplus$</td><td><code>$\bigoplus$</code></td><td>异或</td></tr><tr><td>$\leq$</td><td><code>$\leq$</code></td><td>小于等于</td></tr><tr><td>$\geq$</td><td><code>$\geq$</code></td><td>大于等于</td></tr><tr><td>$\neq$</td><td><code>$\neq$</code></td><td>不等于</td></tr><tr><td>$\approx$</td><td><code>$\approx$</code></td><td>约等于</td></tr><tr><td>$\prod$</td><td><code>$\prod$</code></td><td>N元乘积</td></tr><tr><td>$\coprod$</td><td><code>$\coprod$</code></td><td>N元余积</td></tr><tr><td>$\cdots$</td><td><code>$\cdots$</code></td><td>省略号</td></tr><tr><td>$\int$</td><td><code>$\int$</code></td><td>积分</td></tr><tr><td>$\iint$</td><td><code>$\iint$</code></td><td>双重积分</td></tr><tr><td>$\oint$</td><td><code>$\oint$</code></td><td>曲线积分</td></tr><tr><td>$\infty$</td><td><code>$\infty$</code></td><td>无穷</td></tr><tr><td>$\nabla$</td><td><code>$\nabla$</code></td><td>梯度</td></tr><tr><td>$\because$</td><td><code>$\because$</code></td><td>因为</td></tr><tr><td>$\therefore$</td><td><code>$\therefore$</code></td><td>所以</td></tr><tr><td>$\forall$</td><td><code>$\forall$</code></td><td>任意</td></tr><tr><td>$\exists$</td><td><code>$\exists$</code></td><td>存在</td></tr><tr><td>$\not=$</td><td><code>$\not=$</code></td><td>不等于</td></tr><tr><td>$\not&gt;$</td><td><code>$\not&gt;$</code></td><td>不大于</td></tr><tr><td>$\leq$</td><td><code>$\leq$</code></td><td>小于等于</td></tr><tr><td>$\geq$</td><td><code>$\geq$</code></td><td>大于等于</td></tr><tr><td>$\not\subset$</td><td><code>$\not\subset$</code></td><td>不属于</td></tr><tr><td>$\emptyset$</td><td><code>$\emptyset$</code></td><td>空集</td></tr><tr><td>$\in$</td><td><code>$\in$</code></td><td>属于</td></tr><tr><td>$\notin$</td><td><code>$\notin$</code></td><td>不属于</td></tr><tr><td>$\subset$</td><td><code>$\subset$</code></td><td>子集</td></tr><tr><td>$\subseteq$</td><td><code>$\subseteq$</code></td><td>真子集</td></tr><tr><td>$\bigcup$</td><td><code>$\bigcup$</code></td><td>并集</td></tr><tr><td>$\bigcap$</td><td><code>$\bigcap$</code></td><td>交集</td></tr><tr><td>$\bigvee$</td><td><code>$\bigvee$</code></td><td>逻辑或</td></tr><tr><td>$\bigwedge$</td><td><code>$\bigwedge$</code></td><td>逻辑与</td></tr><tr><td>$\alpha$</td><td><code>$\alpha$</code></td><td></td></tr><tr><td>$\beta$</td><td><code>$\beta$</code></td><td></td></tr><tr><td>$\gamma$</td><td><code>$\gamma$</code></td><td></td></tr><tr><td>$\Gamma$</td><td><code>$\Gamma$</code></td><td></td></tr><tr><td>$\delta$</td><td><code>$\delta$</code></td><td></td></tr><tr><td>$\Delta$</td><td><code>$\Delta$</code></td><td></td></tr><tr><td>$\epsilon$</td><td><code>$\epsilon$</code></td><td></td></tr><tr><td>$\varepsilon$</td><td><code>$\varepsilon$</code></td><td></td></tr><tr><td>$\zeta$</td><td><code>$\zeta$</code></td><td></td></tr><tr><td>$\eta$</td><td><code>$\eta$</code></td><td></td></tr><tr><td>$\theta$</td><td><code>$\theta$</code></td><td></td></tr><tr><td>$\Theta$</td><td><code>$\Theta$</code></td><td></td></tr><tr><td><em>ϑ</em></td><td><code>$\vartheta$</code></td><td></td></tr><tr><td><em>ι</em></td><td><code>$\iota$</code></td><td></td></tr><tr><td><em>π</em></td><td><code>$\pi$</code></td><td></td></tr><tr><td><em>ϕ</em></td><td><code>$\phi$</code></td><td></td></tr><tr><td>Φ</td><td><code>$\Phi$</code></td><td></td></tr><tr><td><em>ψ</em></td><td><code>$\psi$</code></td><td></td></tr><tr><td>Ψ</td><td><code>$\Psi$</code></td><td></td></tr><tr><td><em>ω</em></td><td><code>$\omega$</code></td><td></td></tr><tr><td>Ω</td><td><code>$\Omega$</code></td><td></td></tr><tr><td><em>χ</em></td><td><code>\chi</code></td><td></td></tr><tr><td><em>ρ</em></td><td><code>$\rho$</code></td><td></td></tr><tr><td><em>ο</em></td><td><code>$\omicron$</code></td><td></td></tr><tr><td><em>σ</em></td><td><code>$\sigma$</code></td><td></td></tr><tr><td>Σ</td><td><code>$\Sigma$</code></td><td></td></tr><tr><td><em>ν</em></td><td><code>$\nu$</code></td><td></td></tr><tr><td><em>ξ</em></td><td><code>$\xi$</code></td><td></td></tr><tr><td><em>τ</em></td><td><code>$\tau$</code></td><td></td></tr><tr><td><em>λ</em></td><td><code>$\lambda$</code></td><td></td></tr><tr><td>Λ</td><td><code>$\Lambda$</code></td><td></td></tr><tr><td><em>μ</em></td><td><code>\mu</code></td><td></td></tr><tr><td>∂</td><td><code>$\partial$</code></td><td></td></tr><tr><td>{}</td><td><code>$\lbrace \rbrace$</code></td><td></td></tr><tr><td><em>a</em></td><td><code>$\overline{a}$</code></td></tr></tbody></table><p>​     </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;MarkDown基本语法&quot;&gt;&lt;a href=&quot;#MarkDown基本语法&quot; class=&quot;headerlink&quot; title=&quot;MarkDown基本语法&quot;&gt;&lt;/a&gt;MarkDown基本语法&lt;/h4&gt;&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;简介&lt;/p&gt;
&lt;blockquo
      
    
    </summary>
    
    
      <category term="Markdown" scheme="http://yoursite.com/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>ProtocolBuffers-基本使用</title>
    <link href="http://yoursite.com/2020/03/12/ProtocolBuffers-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/03/12/ProtocolBuffers-基本使用/</id>
    <published>2020-03-12T13:11:49.000Z</published>
    <updated>2020-03-14T13:55:55.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Protocol-Buffers"><a href="#Protocol-Buffers" class="headerlink" title="Protocol Buffers"></a>Protocol Buffers</h4><p>​    <em>一种跨语言，跨平台的可扩展的序列化数据格式</em></p><ol><li><p>相比XML的优势</p><ul><li>更简单</li><li>更轻量（数据体积小3~10倍）</li><li>更快速（20～100倍）</li><li>自动化生成更易于编码方式使用的数据访问类</li></ul></li><li><p>使用方法</p><pre class="mermaid">   graph TD;   A[定义protobuf消息格式]　--> B[编译protobuf];   B --> C[使用protobuf API进行读写];</pre><ol><li><p>使用protobuf语法描述需要存储的数据结构（编写．proto文件）</p><pre><code class="hljs protobuf">syntax = <span class="hljs-string">"proto3"</span>; <span class="hljs-comment">//默认为proto2,不能为空</span><span class="hljs-keyword">package</span> tutorial;　<span class="hljs-comment">//避免命名冲突</span><span class="hljs-keyword">option</span> java_package = <span class="hljs-string">"com.example.tutorial"</span>;　<span class="hljs-comment">//生成类的包结构</span><span class="hljs-keyword">option</span> java_outer_classname = <span class="hljs-string">"AddressBookProtos"</span>;　<span class="hljs-comment">//生成包括当前文件所有类的类名，默认是MyProto,生成my_proto.proto，不能与内部定义的类名称相同（不能设为AddressBook）</span><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">Person</span> </span>&#123;   <span class="hljs-built_in">string</span> name = <span class="hljs-number">1</span>;　<span class="hljs-comment">//用于二进制编码的唯一标识</span>   <span class="hljs-built_in">int32</span> id = <span class="hljs-number">2</span>;   <span class="hljs-built_in">string</span> email = <span class="hljs-number">3</span>;  <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">PhoneType</span> </span>&#123;    MOBILE = <span class="hljs-number">0</span>;　<span class="hljs-comment">//必须包含标识０，用于设置默认值和与proto2语义兼容</span>    HOME = <span class="hljs-number">1</span>;    WORK = <span class="hljs-number">2</span>;  &#125;  <span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">PhoneNumber</span> </span>&#123;     <span class="hljs-built_in">string</span> number = <span class="hljs-number">1</span>;     PhoneType type = <span class="hljs-number">2</span> [packed = HOME];  &#125;   PhoneNumber phones = <span class="hljs-number">4</span>;&#125;<span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">AddressBook</span> </span>&#123;   Person people = <span class="hljs-number">1</span>;&#125;</code></pre><blockquote><p>基本语法（proto3）：</p><ol><li><p>消息是各种类型数据的集合，</p></li><li><p>可以包含<code>bool</code>,<code>int32</code>,<code>float</code>,<code>double</code>,<code>string</code>,枚举或者其他的消息</p></li><li><p>标识的范围为1 ~ 2^29^ - 1,1~15的标识比较高的数字少一个字节进行编码，适宜一些常用或者重复的字段;16以上的适用不太常使用的可选字段;19000 ~ 19999不可使用，为内置保留．</p></li><li><p>每个字段都必须标明注解：</p><ol><li><code>required</code>:该字段必须设置值，否则该消息将被视为“未初始化”,构建未初始化的消息将抛出RuntimeException,解析未初始化的消息将抛出IOException;除此之外与<code>optional</code>一致</li><li><code>optional</code>:该字段是可选字段，可以设置值也可以不设置值。如果不设置值，则使用默认值．</li><li><code>repeated</code>:该字段可以重复任意次数（包括零），重复值的顺序将保留在<strong>protobuf</strong>中。可将其视为动态大小的数组．</li></ol></li><li><p>Any字段：</p><pre><code class="hljs protobuf">&gt;    import "google/protobuf/any.proto";&gt;    &gt;    message ErrorStatus &#123;&gt;      string message = 1;&gt;      google.protobuf.Any details = 2;&gt;    &#125;&gt;</code></pre></li></ol></blockquote><blockquote><ol start="6"><li><p>Oneof字段：</p></li><li><p>一个.proto文件中可以定义多种消息</p></li><li><p>每个message类以及它的子类有自己的<code>builder</code>类 ，通过<code>builder</code>类来进行设置</p></li><li><p>数据类型</p></li><li><p>不能在proto3中直接导入proto2的枚举进行使用，要导入其消息．</p></li><li><p>Map类型</p><pre><code class="hljs protobuf">&gt;     map&lt;key_type, value_type&gt; map_field = N;&gt;     map&lt;<span class="hljs-built_in">string</span>, Project&gt; projects = <span class="hljs-number">3</span>;&gt;</code></pre></li></ol></blockquote><blockquote><pre><code>1. `key_type` 可以是任何 int 或者 string 类型(任何的标量类型，具体可以见上面标量类型对应表格，但是要除去 float、double 和 bytes)2. `value_type` 可以是除去 map 以外的任何类型。</code></pre><ol start="12"><li><p>定义service</p><p>如果要使用 RPC（远程过程调用）系统的消息类型，可以在 <code>.proto</code> 文件中定义 RPC 服务接口，protocol buffer 编译器将使用所选语言生成服务接口代码和 stubs</p><pre><code class="hljs protobuf">&gt;     <span class="hljs-comment">//参数为SearchRequest,返回值为SearchResponse</span>&gt;     <span class="hljs-class"><span class="hljs-keyword">service</span> <span class="hljs-title">SearchService</span> </span>&#123;&gt;       <span class="hljs-function"><span class="hljs-keyword">rpc</span> Search (SearchRequest) <span class="hljs-keyword">returns</span> (SearchResponse)</span>;&gt;     &#125;&gt;</code></pre></li></ol></blockquote><blockquote><ol start="13"><li>JSON Map</li></ol><p>如果一个值在json编码的数据中丢失或者它的值是null, 在被解析成protocol buffer时它将设置为对应的默认值.如果一个字段的值正好是protocol buffer的默认值, 这个字段默认就不会出现在json编码的数据中以便节约空间.</p></blockquote></li><li><p>通过protobuf编译器编译．proto文件（生成对应平台的文件）</p><ul><li>使用命令</li></ul><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#命令格式</span></span>protoc [option] PROTO_FILES<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#Java</span></span>protoc -I=$SRC_DIR --java_out=$DST_DIR $SRC_DIR/addressbook.proto<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#Python</span></span>protoc -I=$SRC_DIR --python_out=$DST_DIR $SRC_DIR/addressbook.proto</code></pre><blockquote><ul><li><p>SRC_DIR:源代码路径，默认为当前文件夹</p></li><li><p>DST_DIR:生成的代码路径，默认与SRC_DIR相同</p></li><li><p>–Java_out:生成不同语言对应的文件</p></li><li><p>对于Android使用Java Lite可以减小生成类的体积</p><p>1.安装java_lite环境</p><p>2.编译java_lite版文件</p><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">   protoc --javalite_out=<span class="hljs-variable">$DST_DIR</span> PROTO_FILES</span><span class="hljs-meta">&gt;</span><span class="bash"></span></code></pre></li></ul></blockquote><ul><li><p>使用Android Studio</p><ol><li>安装Protocol Support插件</li><li>配置gradle</li><li>编写．proto文件</li><li>编译项目</li></ol><p><img src="https://img2.tuicool.com/AnMFRbi.jpg!web" srcset="/img/loading.gif" alt="img"></p></li></ul></li><li><p>使用protobuf进行数据读写</p><p> 除了访问器，生成的类中还有其它的方法：</p><p> 消息构建接口</p><ul><li><code>isInitialized()</code>:检测 所有<code>required</code>的字段是否有被设置</li><li><code>toString()</code>: 生成可读的字符串</li><li><code>mergeFrom(Message other)</code>: (builder only)与另一个消息进行合并</li><li><p><code>clear()</code>: (builder only) 将所有字段清除为空状态</p><p>解析接口</p></li><li><code>byte[] toByteArray();</code>: 序列化数据</li><li><code>static Person parseFrom(byte[] data);</code>: 反序列化数据</li><li><code>void writeTo(OutputStream output);</code>: 序列化数据并写入<code>OutputStream</code></li><li><code>static Person parseFrom(InputStream input);</code>: 从<code>InputStream</code>中解析读取消息</li></ul><ol start="4"><li>具体Demo</li></ol></li><li><p>兼容处理</p><p>如果要让新版本向后兼容，旧版本向前兼容，需要遵守以下规则</p><ol><li>不能修改已存在字段的标识（tag）</li><li>不能添加或删除<code>required</code>字段</li><li>可以删除<code>optional</code>或<code>repeated</code>字段</li><li>可以增加<code>optional</code>或<code>repeated</code>字段，但必须使用没有用过的标识，已经删除的也不能用</li></ol></li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Protocol-Buffers&quot;&gt;&lt;a href=&quot;#Protocol-Buffers&quot; class=&quot;headerlink&quot; title=&quot;Protocol Buffers&quot;&gt;&lt;/a&gt;Protocol Buffers&lt;/h4&gt;&lt;p&gt;​    &lt;em&gt;一种跨语言
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据编码" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Hexo基本命令</title>
    <link href="http://yoursite.com/2020/03/10/Hexo%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2020/03/10/Hexo基本命令/</id>
    <published>2020-03-10T13:13:49.000Z</published>
    <updated>2020-03-12T13:02:40.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="init"><a href="#init" class="headerlink" title="init"></a>init</h4><pre><code class="hljs undefined">hexo init <span class="hljs-string">[folder]</span></code></pre><blockquote><p>新建一个网站</p></blockquote><h4 id="hexo-new"><a href="#hexo-new" class="headerlink" title="hexo new"></a>hexo new</h4><pre><code class="hljs undefined">hexo <span class="hljs-keyword">new</span> [layout] &lt;<span class="hljs-built_in">title</span>&gt;</code></pre><blockquote><ul><li>新建一个title.md文档</li></ul></blockquote><h4 id="hexo-generate-hexo-g"><a href="#hexo-generate-hexo-g" class="headerlink" title="hexo generate(hexo g)"></a>hexo generate(hexo g)</h4><table><thead><tr><th style="text-align:left">选项</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">-d, –deploy</td><td style="text-align:left">文件生成后立即部署网站</td></tr><tr><td style="text-align:left">-w, –watch</td><td style="text-align:left">监视文件变动</td></tr><tr><td style="text-align:left">-b, –bail</td><td style="text-align:left">生成过程中如果发生任何未处理的异常则抛出异常</td></tr><tr><td style="text-align:left">-f, –force</td><td style="text-align:left">强制重新生成文件 Hexo 引入了差分机制，如果 <code>public</code> 目录存在，那么 <code>hexo g</code> 只会重新生成改动的文件。 使用该参数的效果接近 <code>hexo clean &amp;&amp; hexo generate</code></td></tr><tr><td style="text-align:left">-c, –concurrency</td><td style="text-align:left">最大同时生成文件的数量，默认无限制</td></tr></tbody></table><blockquote><p>生成网站静态文件到默认设置的 public 文件夹</p></blockquote><h4 id="publish"><a href="#publish" class="headerlink" title="publish"></a>publish</h4><pre><code class="hljs undefined">hexo publish <span class="hljs-string">[layout]</span> &lt;fileName&gt;</code></pre><blockquote><p>发表草稿</p></blockquote><h4 id="hexo-server-hexo-s"><a href="#hexo-server-hexo-s" class="headerlink" title="hexo server(hexo s)"></a>hexo server(hexo s)</h4><blockquote><p>启动服务器，默认网址为<code>http://localhost:4000/</code></p></blockquote><table><thead><tr><th style="text-align:left">项</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">-p, –port</td><td style="text-align:left">重设端口</td></tr><tr><td style="text-align:left">-s, –static</td><td style="text-align:left">只使用静态文件</td></tr><tr><td style="text-align:left">-l, –log</td><td style="text-align:left">启动日记记录，使用覆盖记录格式</td></tr></tbody></table><h4 id="hexo-deploy-hexo-d"><a href="#hexo-deploy-hexo-d" class="headerlink" title="hexo deploy(hexo d)"></a>hexo deploy(hexo d)</h4><blockquote><p>部署网站到服务器</p></blockquote><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">-g, –generate</td><td style="text-align:left">部署之前预先生成静态文件</td></tr></tbody></table><h4 id="hexo-clean"><a href="#hexo-clean" class="headerlink" title="hexo clean"></a>hexo clean</h4><blockquote><p>清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;init&quot;&gt;&lt;a href=&quot;#init&quot; class=&quot;headerlink&quot; title=&quot;init&quot;&gt;&lt;/a&gt;init&lt;/h4&gt;&lt;pre&gt;&lt;code class=&quot;hljs undefined&quot;&gt;hexo init &lt;span class=&quot;hljs-str
      
    
    </summary>
    
      <category term="Hexo" scheme="http://yoursite.com/categories/Hexo/"/>
    
    
      <category term="博客" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
</feed>
